; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\dataqueue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\dataqueue.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\dataqueue.crf ..\common\dataqueue.c]
                          THUMB

                          AREA ||i.rt_data_queue_init||, CODE, READONLY, ALIGN=2

                  rt_data_queue_init PROC
;;;35     rt_err_t
;;;36     rt_data_queue_init(struct rt_data_queue *queue,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;37                        rt_uint16_t size,
;;;38                        rt_uint16_t lwm,
;;;39                        void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event))
;;;40     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;41         RT_ASSERT(queue != RT_NULL);
00000c  b924              CBNZ     r4,|L1.24|
00000e  2229              MOVS     r2,#0x29
000010  490f              LDR      r1,|L1.80|
000012  a010              ADR      r0,|L1.84|
000014  f7fffffe          BL       rt_assert_handler
                  |L1.24|
;;;42     
;;;43         queue->evt_notify = evt_notify;
000018  6227              STR      r7,[r4,#0x20]
;;;44     
;;;45         queue->size = size;
00001a  8025              STRH     r5,[r4,#0]
;;;46         queue->lwm = lwm;
00001c  8066              STRH     r6,[r4,#2]
;;;47         queue->waiting_lwm = RT_FALSE;
00001e  2000              MOVS     r0,#0
000020  6060              STR      r0,[r4,#4]
;;;48     
;;;49         queue->get_index = 0;
000022  8120              STRH     r0,[r4,#8]
;;;50         queue->put_index = 0;
000024  8160              STRH     r0,[r4,#0xa]
;;;51     
;;;52         rt_list_init(&(queue->suspended_push_list));
000026  f1040010          ADD      r0,r4,#0x10
00002a  f7fffffe          BL       rt_list_init
;;;53         rt_list_init(&(queue->suspended_pop_list));
00002e  f1040018          ADD      r0,r4,#0x18
000032  f7fffffe          BL       rt_list_init
;;;54     
;;;55         queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
000036  00e8              LSLS     r0,r5,#3
000038  f7fffffe          BL       rt_malloc
00003c  60e0              STR      r0,[r4,#0xc]
;;;56         if (queue->queue == RT_NULL)
00003e  68e0              LDR      r0,[r4,#0xc]
000040  b918              CBNZ     r0,|L1.74|
;;;57         {
;;;58             return -RT_ENOMEM;
000042  f06f0004          MVN      r0,#4
                  |L1.70|
;;;59         }
;;;60     
;;;61         return RT_EOK;
;;;62     }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L1.74|
00004a  2000              MOVS     r0,#0                 ;61
00004c  e7fb              B        |L1.70|
;;;63     RTM_EXPORT(rt_data_queue_init);
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      __FUNCTION__
                  |L1.84|
000054  71756575          DCB      "queue != RT_NULL",0
000058  6520213d
00005c  2052545f
000060  4e554c4c
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.rt_data_queue_peak||, CODE, READONLY, ALIGN=2

                  rt_data_queue_peak PROC
;;;264    
;;;265    rt_err_t rt_data_queue_peak(struct rt_data_queue *queue,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;266                                const void** data_ptr,
;;;267                                rt_size_t *size)
;;;268    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;269        rt_ubase_t  level;
;;;270        rt_uint16_t mask;
;;;271    
;;;272        RT_ASSERT(queue != RT_NULL);
00000a  b92c              CBNZ     r4,|L2.24|
00000c  f44f7288          MOV      r2,#0x110
000010  4913              LDR      r1,|L2.96|
000012  a014              ADR      r0,|L2.100|
000014  f7fffffe          BL       rt_assert_handler
                  |L2.24|
;;;273    
;;;274        mask = queue->size - 1;
000018  8820              LDRH     r0,[r4,#0]
00001a  1e40              SUBS     r0,r0,#1
00001c  b285              UXTH     r5,r0
;;;275    
;;;276        level = rt_hw_interrupt_disable();
00001e  f7fffffe          BL       rt_hw_interrupt_disable
000022  4680              MOV      r8,r0
;;;277    
;;;278        if (queue->get_index == queue->put_index) 
000024  8920              LDRH     r0,[r4,#8]
000026  8961              LDRH     r1,[r4,#0xa]
000028  4288              CMP      r0,r1
00002a  d106              BNE      |L2.58|
;;;279        {
;;;280            rt_hw_interrupt_enable(level);
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       rt_hw_interrupt_enable
;;;281            
;;;282            return -RT_EEMPTY;
000032  f06f0003          MVN      r0,#3
                  |L2.54|
;;;283        }
;;;284    
;;;285        *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
;;;286        *size     = queue->queue[queue->get_index & mask].data_size;
;;;287    
;;;288        rt_hw_interrupt_enable(level);
;;;289    
;;;290        return RT_EOK;
;;;291    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L2.58|
00003a  8920              LDRH     r0,[r4,#8]            ;285
00003c  4028              ANDS     r0,r0,r5              ;285
00003e  68e1              LDR      r1,[r4,#0xc]          ;285
000040  f8510030          LDR      r0,[r1,r0,LSL #3]     ;285
000044  6030              STR      r0,[r6,#0]            ;285
000046  8920              LDRH     r0,[r4,#8]            ;286
000048  4028              ANDS     r0,r0,r5              ;286
00004a  68e1              LDR      r1,[r4,#0xc]          ;286
00004c  eb0100c0          ADD      r0,r1,r0,LSL #3       ;286
000050  6840              LDR      r0,[r0,#4]            ;286
000052  6038              STR      r0,[r7,#0]            ;286
000054  4640              MOV      r0,r8                 ;288
000056  f7fffffe          BL       rt_hw_interrupt_enable
00005a  2000              MOVS     r0,#0                 ;290
00005c  e7eb              B        |L2.54|
;;;292    RTM_EXPORT(rt_data_queue_peak);
                          ENDP

00005e  0000              DCW      0x0000
                  |L2.96|
                          DCD      |symbol_number.27|
                  |L2.100|
000064  71756575          DCB      "queue != RT_NULL",0
000068  6520213d
00006c  2052545f
000070  4e554c4c
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.rt_data_queue_pop||, CODE, READONLY, ALIGN=2

                  rt_data_queue_pop PROC
;;;158    
;;;159    rt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;160                               const void** data_ptr,
;;;161                               rt_size_t *size, 
;;;162                               rt_int32_t timeout)
;;;163    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;164        rt_ubase_t  level;
;;;165        rt_thread_t thread;
;;;166        rt_err_t    result;
;;;167        rt_uint16_t mask;
;;;168    
;;;169        RT_ASSERT(queue != RT_NULL);
00000a  b924              CBNZ     r4,|L3.22|
00000c  22a9              MOVS     r2,#0xa9
00000e  4951              LDR      r1,|L3.340|
000010  a051              ADR      r0,|L3.344|
000012  f7fffffe          BL       rt_assert_handler
                  |L3.22|
;;;170        RT_ASSERT(data_ptr != RT_NULL);
000016  b927              CBNZ     r7,|L3.34|
000018  22aa              MOVS     r2,#0xaa
00001a  494e              LDR      r1,|L3.340|
00001c  a053              ADR      r0,|L3.364|
00001e  f7fffffe          BL       rt_assert_handler
                  |L3.34|
;;;171        RT_ASSERT(size != RT_NULL);
000022  f1b80f00          CMP      r8,#0
000026  d104              BNE      |L3.50|
000028  22ab              MOVS     r2,#0xab
00002a  494a              LDR      r1,|L3.340|
00002c  a054              ADR      r0,|L3.384|
00002e  f7fffffe          BL       rt_assert_handler
                  |L3.50|
;;;172    
;;;173        result = RT_EOK;
000032  2600              MOVS     r6,#0
;;;174        thread = rt_thread_self();
000034  f7fffffe          BL       rt_thread_self
000038  4605              MOV      r5,r0
;;;175        mask   = queue->size - 1;
00003a  8820              LDRH     r0,[r4,#0]
00003c  1e40              SUBS     r0,r0,#1
00003e  fa1ff980          UXTH     r9,r0
;;;176    
;;;177        level = rt_hw_interrupt_disable();
000042  f7fffffe          BL       rt_hw_interrupt_disable
000046  4682              MOV      r10,r0
;;;178        while (queue->get_index == queue->put_index)
000048  e03b              B        |L3.194|
                  |L3.74|
;;;179        {
;;;180            /* queue is empty */
;;;181            if (timeout == 0)
00004a  9803              LDR      r0,[sp,#0xc]
00004c  b910              CBNZ     r0,|L3.84|
;;;182            {
;;;183                result = -RT_ETIMEOUT;
00004e  f06f0601          MVN      r6,#1
;;;184                goto __exit;
000052  e073              B        |L3.316|
                  |L3.84|
;;;185            }
;;;186    
;;;187            /* current context checking */
;;;188            RT_DEBUG_NOT_IN_INTERRUPT;
000054  bf00              NOP      
000056  f7fffffe          BL       rt_hw_interrupt_disable
00005a  4683              MOV      r11,r0
00005c  f7fffffe          BL       rt_interrupt_get_nest
000060  b140              CBZ      r0,|L3.116|
000062  493c              LDR      r1,|L3.340|
000064  a04a              ADR      r0,|L3.400|
000066  f7fffffe          BL       rt_kprintf
00006a  22bc              MOVS     r2,#0xbc
00006c  4939              LDR      r1,|L3.340|
00006e  a051              ADR      r0,|L3.436|
000070  f7fffffe          BL       rt_assert_handler
                  |L3.116|
000074  4658              MOV      r0,r11
000076  f7fffffe          BL       rt_hw_interrupt_enable
00007a  bf00              NOP      
;;;189    
;;;190            /* reset thread error number */
;;;191            thread->error = RT_EOK;
00007c  2000              MOVS     r0,#0
00007e  6328              STR      r0,[r5,#0x30]
;;;192            
;;;193            /* suspend thread on the pop list */
;;;194            rt_thread_suspend(thread);
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       rt_thread_suspend
;;;195            rt_list_insert_before(&(queue->suspended_pop_list), &(thread->tlist));
000086  f1050114          ADD      r1,r5,#0x14
00008a  f1040018          ADD      r0,r4,#0x18
00008e  f7fffffe          BL       rt_list_insert_before
;;;196            /* start timer */
;;;197            if (timeout > 0)
000092  9803              LDR      r0,[sp,#0xc]
000094  2800              CMP      r0,#0
000096  dd09              BLE      |L3.172|
;;;198            {
;;;199                /* reset the timeout of thread timer and start it */
;;;200                rt_timer_control(&(thread->thread_timer),
000098  aa03              ADD      r2,sp,#0xc
00009a  2100              MOVS     r1,#0
00009c  f105004c          ADD      r0,r5,#0x4c
0000a0  f7fffffe          BL       rt_timer_control
;;;201                                 RT_TIMER_CTRL_SET_TIME,
;;;202                                 &timeout);
;;;203                rt_timer_start(&(thread->thread_timer));
0000a4  f105004c          ADD      r0,r5,#0x4c
0000a8  f7fffffe          BL       rt_timer_start
                  |L3.172|
;;;204            }
;;;205    
;;;206            /* enable interrupt */
;;;207            rt_hw_interrupt_enable(level);
0000ac  4650              MOV      r0,r10
0000ae  f7fffffe          BL       rt_hw_interrupt_enable
;;;208    
;;;209            /* do schedule */
;;;210            rt_schedule();
0000b2  f7fffffe          BL       rt_schedule
;;;211    
;;;212            /* thread is waked up */
;;;213            result = thread->error;
0000b6  6b2e              LDR      r6,[r5,#0x30]
;;;214            level  = rt_hw_interrupt_disable();
0000b8  f7fffffe          BL       rt_hw_interrupt_disable
0000bc  4682              MOV      r10,r0
;;;215            if (result != RT_EOK)
0000be  b106              CBZ      r6,|L3.194|
;;;216                goto __exit;
0000c0  e03c              B        |L3.316|
                  |L3.194|
0000c2  8920              LDRH     r0,[r4,#8]            ;178
0000c4  8961              LDRH     r1,[r4,#0xa]          ;178
0000c6  4288              CMP      r0,r1                 ;178
0000c8  d0bf              BEQ      |L3.74|
;;;217        }
;;;218    
;;;219        *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
0000ca  8920              LDRH     r0,[r4,#8]
0000cc  ea000009          AND      r0,r0,r9
0000d0  68e1              LDR      r1,[r4,#0xc]
0000d2  f8510030          LDR      r0,[r1,r0,LSL #3]
0000d6  6038              STR      r0,[r7,#0]
;;;220        *size     = queue->queue[queue->get_index & mask].data_size;
0000d8  8920              LDRH     r0,[r4,#8]
0000da  ea000009          AND      r0,r0,r9
0000de  68e1              LDR      r1,[r4,#0xc]
0000e0  eb0100c0          ADD      r0,r1,r0,LSL #3
0000e4  6840              LDR      r0,[r0,#4]
0000e6  f8c80000          STR      r0,[r8,#0]
;;;221    
;;;222        queue->get_index += 1;
0000ea  8920              LDRH     r0,[r4,#8]
0000ec  1c40              ADDS     r0,r0,#1
0000ee  8120              STRH     r0,[r4,#8]
;;;223    
;;;224        if ((queue->waiting_lwm == RT_TRUE) && 
0000f0  6860              LDR      r0,[r4,#4]
0000f2  2801              CMP      r0,#1
0000f4  d121              BNE      |L3.314|
;;;225            (queue->put_index - queue->get_index) <= queue->lwm)
0000f6  8960              LDRH     r0,[r4,#0xa]
0000f8  8921              LDRH     r1,[r4,#8]
0000fa  1a40              SUBS     r0,r0,r1
0000fc  8861              LDRH     r1,[r4,#2]
0000fe  4288              CMP      r0,r1
000100  dc1b              BGT      |L3.314|
;;;226        {
;;;227            queue->waiting_lwm = RT_FALSE;
000102  2000              MOVS     r0,#0
000104  6060              STR      r0,[r4,#4]
;;;228    
;;;229            /*
;;;230             * there is at least one thread in suspended list
;;;231             * and less than low water mark
;;;232             */
;;;233            if (!rt_list_isempty(&(queue->suspended_push_list)))
000106  f1040010          ADD      r0,r4,#0x10
00010a  f7fffffe          BL       rt_list_isempty
00010e  b950              CBNZ     r0,|L3.294|
;;;234            {
;;;235                /* get thread entry */
;;;236                thread = rt_list_entry(queue->suspended_push_list.next,
000110  6920              LDR      r0,[r4,#0x10]
000112  f1a00514          SUB      r5,r0,#0x14
;;;237                                       struct rt_thread,
;;;238                                       tlist);
;;;239    
;;;240                /* resume it */
;;;241                rt_thread_resume(thread);
000116  4628              MOV      r0,r5
000118  f7fffffe          BL       rt_thread_resume
;;;242                rt_hw_interrupt_enable(level);
00011c  4650              MOV      r0,r10
00011e  f7fffffe          BL       rt_hw_interrupt_enable
;;;243    
;;;244                /* perform a schedule */
;;;245                rt_schedule();
000122  f7fffffe          BL       rt_schedule
                  |L3.294|
;;;246            }
;;;247    
;;;248            if (queue->evt_notify != RT_NULL)
000126  6a20              LDR      r0,[r4,#0x20]
000128  b118              CBZ      r0,|L3.306|
;;;249                queue->evt_notify(queue, RT_DATAQUEUE_EVENT_LWM);
00012a  2103              MOVS     r1,#3
00012c  4620              MOV      r0,r4
00012e  6a22              LDR      r2,[r4,#0x20]
000130  4790              BLX      r2
                  |L3.306|
;;;250    
;;;251            return result;
000132  4630              MOV      r0,r6
                  |L3.308|
;;;252        }
;;;253    
;;;254    __exit:
;;;255        rt_hw_interrupt_enable(level);
;;;256        if ((result == RT_EOK) && (queue->evt_notify != RT_NULL))
;;;257        {
;;;258            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_POP);
;;;259        }
;;;260    
;;;261        return result;
;;;262    }
000134  b004              ADD      sp,sp,#0x10
000136  e8bd9ff0          POP      {r4-r12,pc}
                  |L3.314|
00013a  bf00              NOP                            ;254
                  |L3.316|
00013c  4650              MOV      r0,r10                ;255
00013e  f7fffffe          BL       rt_hw_interrupt_enable
000142  b92e              CBNZ     r6,|L3.336|
000144  6a20              LDR      r0,[r4,#0x20]         ;256
000146  b118              CBZ      r0,|L3.336|
000148  2101              MOVS     r1,#1                 ;258
00014a  4620              MOV      r0,r4                 ;258
00014c  6a22              LDR      r2,[r4,#0x20]         ;258
00014e  4790              BLX      r2                    ;258
                  |L3.336|
000150  4630              MOV      r0,r6                 ;261
000152  e7ef              B        |L3.308|
;;;263    RTM_EXPORT(rt_data_queue_pop);
                          ENDP

                  |L3.340|
                          DCD      |symbol_number.26|
                  |L3.344|
000158  71756575          DCB      "queue != RT_NULL",0
00015c  6520213d
000160  2052545f
000164  4e554c4c
000168  00      
000169  00                DCB      0
00016a  00                DCB      0
00016b  00                DCB      0
                  |L3.364|
00016c  64617461          DCB      "data_ptr != RT_NULL",0
000170  5f707472
000174  20213d20
000178  52545f4e
00017c  554c4c00
                  |L3.384|
000180  73697a65          DCB      "size != RT_NULL",0
000184  20213d20
000188  52545f4e
00018c  554c4c00
                  |L3.400|
000190  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000194  74696f6e
000198  5b25735d
00019c  20736861
0001a0  6c6c206e
0001a4  6f742075
0001a8  73656420
0001ac  696e2049
0001b0  53520a00
                  |L3.436|
0001b4  3000              DCB      "0",0
0001b6  00                DCB      0
0001b7  00                DCB      0

                          AREA ||i.rt_data_queue_push||, CODE, READONLY, ALIGN=2

                  rt_data_queue_push PROC
;;;64     
;;;65     rt_err_t rt_data_queue_push(struct rt_data_queue *queue,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;66                                 const void *data_ptr,
;;;67                                 rt_size_t data_size,
;;;68                                 rt_int32_t timeout)
;;;69     {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;70         rt_uint16_t mask;
;;;71         rt_ubase_t  level;
;;;72         rt_thread_t thread;
;;;73         rt_err_t    result;
;;;74         
;;;75         RT_ASSERT(queue != RT_NULL);
00000a  b924              CBNZ     r4,|L4.22|
00000c  224b              MOVS     r2,#0x4b
00000e  4941              LDR      r1,|L4.276|
000010  a041              ADR      r0,|L4.280|
000012  f7fffffe          BL       rt_assert_handler
                  |L4.22|
;;;76     
;;;77         result = RT_EOK;
000016  2600              MOVS     r6,#0
;;;78         thread = rt_thread_self();
000018  f7fffffe          BL       rt_thread_self
00001c  4605              MOV      r5,r0
;;;79         mask = queue->size - 1;
00001e  8820              LDRH     r0,[r4,#0]
000020  1e40              SUBS     r0,r0,#1
000022  b287              UXTH     r7,r0
;;;80     
;;;81         level = rt_hw_interrupt_disable();
000024  f7fffffe          BL       rt_hw_interrupt_disable
000028  4682              MOV      r10,r0
;;;82         while (queue->put_index - queue->get_index == queue->size)
00002a  e03d              B        |L4.168|
                  |L4.44|
;;;83         {
;;;84             queue->waiting_lwm = RT_TRUE;
00002c  2001              MOVS     r0,#1
00002e  6060              STR      r0,[r4,#4]
;;;85     
;;;86             /* queue is full */
;;;87             if (timeout == 0)
000030  9803              LDR      r0,[sp,#0xc]
000032  b910              CBNZ     r0,|L4.58|
;;;88             {
;;;89                 result = -RT_ETIMEOUT;
000034  f06f0601          MVN      r6,#1
;;;90     
;;;91                 goto __exit;
000038  e060              B        |L4.252|
                  |L4.58|
;;;92             }
;;;93     
;;;94             /* current context checking */
;;;95             RT_DEBUG_NOT_IN_INTERRUPT;
00003a  bf00              NOP      
00003c  f7fffffe          BL       rt_hw_interrupt_disable
000040  4683              MOV      r11,r0
000042  f7fffffe          BL       rt_interrupt_get_nest
000046  b140              CBZ      r0,|L4.90|
000048  4932              LDR      r1,|L4.276|
00004a  a038              ADR      r0,|L4.300|
00004c  f7fffffe          BL       rt_kprintf
000050  225f              MOVS     r2,#0x5f
000052  4930              LDR      r1,|L4.276|
000054  a03e              ADR      r0,|L4.336|
000056  f7fffffe          BL       rt_assert_handler
                  |L4.90|
00005a  4658              MOV      r0,r11
00005c  f7fffffe          BL       rt_hw_interrupt_enable
000060  bf00              NOP      
;;;96     
;;;97             /* reset thread error number */
;;;98             thread->error = RT_EOK;
000062  2000              MOVS     r0,#0
000064  6328              STR      r0,[r5,#0x30]
;;;99             
;;;100            /* suspend thread on the push list */
;;;101            rt_thread_suspend(thread);
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       rt_thread_suspend
;;;102            rt_list_insert_before(&(queue->suspended_push_list), &(thread->tlist));
00006c  f1050114          ADD      r1,r5,#0x14
000070  f1040010          ADD      r0,r4,#0x10
000074  f7fffffe          BL       rt_list_insert_before
;;;103            /* start timer */
;;;104            if (timeout > 0)
000078  9803              LDR      r0,[sp,#0xc]
00007a  2800              CMP      r0,#0
00007c  dd09              BLE      |L4.146|
;;;105            {
;;;106                /* reset the timeout of thread timer and start it */
;;;107                rt_timer_control(&(thread->thread_timer),
00007e  aa03              ADD      r2,sp,#0xc
000080  2100              MOVS     r1,#0
000082  f105004c          ADD      r0,r5,#0x4c
000086  f7fffffe          BL       rt_timer_control
;;;108                                 RT_TIMER_CTRL_SET_TIME,
;;;109                                 &timeout);
;;;110                rt_timer_start(&(thread->thread_timer));
00008a  f105004c          ADD      r0,r5,#0x4c
00008e  f7fffffe          BL       rt_timer_start
                  |L4.146|
;;;111            }
;;;112    
;;;113            /* enable interrupt */
;;;114            rt_hw_interrupt_enable(level);
000092  4650              MOV      r0,r10
000094  f7fffffe          BL       rt_hw_interrupt_enable
;;;115    
;;;116            /* do schedule */
;;;117            rt_schedule();
000098  f7fffffe          BL       rt_schedule
;;;118    
;;;119            /* thread is waked up */
;;;120            result = thread->error;
00009c  6b2e              LDR      r6,[r5,#0x30]
;;;121            level = rt_hw_interrupt_disable();
00009e  f7fffffe          BL       rt_hw_interrupt_disable
0000a2  4682              MOV      r10,r0
;;;122            if (result != RT_EOK) goto __exit;
0000a4  b106              CBZ      r6,|L4.168|
0000a6  e029              B        |L4.252|
                  |L4.168|
0000a8  8960              LDRH     r0,[r4,#0xa]          ;82
0000aa  8921              LDRH     r1,[r4,#8]            ;82
0000ac  1a40              SUBS     r0,r0,r1              ;82
0000ae  8821              LDRH     r1,[r4,#0]            ;82
0000b0  4288              CMP      r0,r1                 ;82
0000b2  d0bb              BEQ      |L4.44|
;;;123        }
;;;124    
;;;125        queue->queue[queue->put_index & mask].data_ptr  = data_ptr;
0000b4  8960              LDRH     r0,[r4,#0xa]
0000b6  4038              ANDS     r0,r0,r7
0000b8  68e1              LDR      r1,[r4,#0xc]
0000ba  f8418030          STR      r8,[r1,r0,LSL #3]
;;;126        queue->queue[queue->put_index & mask].data_size = data_size;
0000be  8960              LDRH     r0,[r4,#0xa]
0000c0  4038              ANDS     r0,r0,r7
0000c2  68e1              LDR      r1,[r4,#0xc]
0000c4  eb0100c0          ADD      r0,r1,r0,LSL #3
0000c8  f8c09004          STR      r9,[r0,#4]
;;;127        queue->put_index += 1;
0000cc  8960              LDRH     r0,[r4,#0xa]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  8160              STRH     r0,[r4,#0xa]
;;;128    
;;;129        if (!rt_list_isempty(&(queue->suspended_pop_list)))
0000d2  f1040018          ADD      r0,r4,#0x18
0000d6  f7fffffe          BL       rt_list_isempty
0000da  b970              CBNZ     r0,|L4.250|
;;;130        {
;;;131            /* there is at least one thread in suspended list */
;;;132    
;;;133            /* get thread entry */
;;;134            thread = rt_list_entry(queue->suspended_pop_list.next,
0000dc  69a0              LDR      r0,[r4,#0x18]
0000de  f1a00514          SUB      r5,r0,#0x14
;;;135                                   struct rt_thread,
;;;136                                   tlist);
;;;137    
;;;138            /* resume it */
;;;139            rt_thread_resume(thread);
0000e2  4628              MOV      r0,r5
0000e4  f7fffffe          BL       rt_thread_resume
;;;140            rt_hw_interrupt_enable(level);
0000e8  4650              MOV      r0,r10
0000ea  f7fffffe          BL       rt_hw_interrupt_enable
;;;141    
;;;142            /* perform a schedule */
;;;143            rt_schedule();
0000ee  f7fffffe          BL       rt_schedule
;;;144    
;;;145            return result;
0000f2  4630              MOV      r0,r6
                  |L4.244|
;;;146        }
;;;147    
;;;148    __exit:
;;;149        rt_hw_interrupt_enable(level);
;;;150        if ((result == RT_EOK) && queue->evt_notify != RT_NULL)
;;;151        {
;;;152            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_PUSH);
;;;153        }
;;;154    
;;;155        return result;
;;;156    }
0000f4  b004              ADD      sp,sp,#0x10
0000f6  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.250|
0000fa  bf00              NOP                            ;148
                  |L4.252|
0000fc  4650              MOV      r0,r10                ;149
0000fe  f7fffffe          BL       rt_hw_interrupt_enable
000102  b92e              CBNZ     r6,|L4.272|
000104  6a20              LDR      r0,[r4,#0x20]         ;150
000106  b118              CBZ      r0,|L4.272|
000108  2102              MOVS     r1,#2                 ;152
00010a  4620              MOV      r0,r4                 ;152
00010c  6a22              LDR      r2,[r4,#0x20]         ;152
00010e  4790              BLX      r2                    ;152
                  |L4.272|
000110  4630              MOV      r0,r6                 ;155
000112  e7ef              B        |L4.244|
;;;157    RTM_EXPORT(rt_data_queue_push);
                          ENDP

                  |L4.276|
                          DCD      |symbol_number.25|
                  |L4.280|
000118  71756575          DCB      "queue != RT_NULL",0
00011c  6520213d
000120  2052545f
000124  4e554c4c
000128  00      
000129  00                DCB      0
00012a  00                DCB      0
00012b  00                DCB      0
                  |L4.300|
00012c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000130  74696f6e
000134  5b25735d
000138  20736861
00013c  6c6c206e
000140  6f742075
000144  73656420
000148  696e2049
00014c  53520a00
                  |L4.336|
000150  3000              DCB      "0",0
000152  00                DCB      0
000153  00                DCB      0

                          AREA ||i.rt_data_queue_reset||, CODE, READONLY, ALIGN=1

                  rt_data_queue_reset PROC
;;;293    
;;;294    void rt_data_queue_reset(struct rt_data_queue *queue)
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
000002  4604              MOV      r4,r0
;;;296        struct rt_thread *thread;
;;;297        register rt_ubase_t temp;
;;;298    
;;;299        rt_enter_critical();
000004  f7fffffe          BL       rt_enter_critical
;;;300        /* wakeup all suspend threads */
;;;301    
;;;302        /* resume on pop list */
;;;303        while (!rt_list_isempty(&(queue->suspended_pop_list)))
000008  e00e              B        |L5.40|
                  |L5.10|
;;;304        {
;;;305            /* disable interrupt */
;;;306            temp = rt_hw_interrupt_disable();
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4606              MOV      r6,r0
;;;307    
;;;308            /* get next suspend thread */
;;;309            thread = rt_list_entry(queue->suspended_pop_list.next,
000010  69a0              LDR      r0,[r4,#0x18]
000012  f1a00514          SUB      r5,r0,#0x14
;;;310                                   struct rt_thread,
;;;311                                   tlist);
;;;312            /* set error code to RT_ERROR */
;;;313            thread->error = -RT_ERROR;
000016  f04f30ff          MOV      r0,#0xffffffff
00001a  6328              STR      r0,[r5,#0x30]
;;;314    
;;;315            /*
;;;316             * resume thread
;;;317             * In rt_thread_resume function, it will remove current thread from
;;;318             * suspend list
;;;319             */
;;;320            rt_thread_resume(thread);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       rt_thread_resume
;;;321    
;;;322            /* enable interrupt */
;;;323            rt_hw_interrupt_enable(temp);
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       rt_hw_interrupt_enable
                  |L5.40|
000028  f1040018          ADD      r0,r4,#0x18           ;303
00002c  f7fffffe          BL       rt_list_isempty
000030  2800              CMP      r0,#0                 ;303
000032  d0ea              BEQ      |L5.10|
;;;324        }
;;;325    
;;;326        /* resume on push list */
;;;327        while (!rt_list_isempty(&(queue->suspended_push_list)))
000034  e00e              B        |L5.84|
                  |L5.54|
;;;328        {
;;;329            /* disable interrupt */
;;;330            temp = rt_hw_interrupt_disable();
000036  f7fffffe          BL       rt_hw_interrupt_disable
00003a  4606              MOV      r6,r0
;;;331    
;;;332            /* get next suspend thread */
;;;333            thread = rt_list_entry(queue->suspended_push_list.next,
00003c  6920              LDR      r0,[r4,#0x10]
00003e  f1a00514          SUB      r5,r0,#0x14
;;;334                                   struct rt_thread,
;;;335                                   tlist);
;;;336            /* set error code to RT_ERROR */
;;;337            thread->error = -RT_ERROR;
000042  f04f30ff          MOV      r0,#0xffffffff
000046  6328              STR      r0,[r5,#0x30]
;;;338    
;;;339            /*
;;;340             * resume thread
;;;341             * In rt_thread_resume function, it will remove current thread from
;;;342             * suspend list
;;;343             */
;;;344            rt_thread_resume(thread);
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       rt_thread_resume
;;;345    
;;;346            /* enable interrupt */
;;;347            rt_hw_interrupt_enable(temp);
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       rt_hw_interrupt_enable
                  |L5.84|
000054  f1040010          ADD      r0,r4,#0x10           ;327
000058  f7fffffe          BL       rt_list_isempty
00005c  2800              CMP      r0,#0                 ;327
00005e  d0ea              BEQ      |L5.54|
;;;348        }
;;;349        rt_exit_critical();
000060  f7fffffe          BL       rt_exit_critical
;;;350    
;;;351        rt_schedule();
000064  f7fffffe          BL       rt_schedule
;;;352    }
000068  bd70              POP      {r4-r6,pc}
;;;353    RTM_EXPORT(rt_data_queue_reset);
                          ENDP


                          AREA ||i.rt_list_init||, CODE, READONLY, ALIGN=1

                  rt_list_init PROC
;;;50      */
;;;51     rt_inline void rt_list_init(rt_list_t *l)
000000  6040              STR      r0,[r0,#4]
;;;52     {
;;;53         l->next = l->prev = l;
000002  6000              STR      r0,[r0,#0]
;;;54     }
000004  4770              BX       lr
;;;55     
                          ENDP


                          AREA ||i.rt_list_insert_before||, CODE, READONLY, ALIGN=1

                  rt_list_insert_before PROC
;;;76      */
;;;77     rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
000000  6842              LDR      r2,[r0,#4]
;;;78     {
;;;79         l->prev->next = n;
000002  6011              STR      r1,[r2,#0]
;;;80         n->prev = l->prev;
000004  6842              LDR      r2,[r0,#4]
000006  604a              STR      r2,[r1,#4]
;;;81     
;;;82         l->prev = n;
000008  6041              STR      r1,[r0,#4]
;;;83         n->next = l;
00000a  6008              STR      r0,[r1,#0]
;;;84     }
00000c  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;101     */
;;;102    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  4601              MOV      r1,r0
;;;103    {
;;;104        return l->next == l;
000002  6808              LDR      r0,[r1,#0]
000004  4288              CMP      r0,r1
000006  d101              BNE      |L8.12|
000008  2001              MOVS     r0,#1
                  |L8.10|
;;;105    }
00000a  4770              BX       lr
                  |L8.12|
00000c  2000              MOVS     r0,#0                 ;104
00000e  e7fc              B        |L8.10|
;;;106    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f64          DCB      0x72,0x74,0x5f,0x64
000004  6174615f          DCB      0x61,0x74,0x61,0x5f
000008  71756575          DCB      0x71,0x75,0x65,0x75
00000c  655f696e          DCB      0x65,0x5f,0x69,0x6e
000010  697400            DCB      0x69,0x74,0x00
                  |symbol_number.25|
000013  72                DCB      0x72
000014  745f6461          DCB      0x74,0x5f,0x64,0x61
000018  74615f71          DCB      0x74,0x61,0x5f,0x71
00001c  75657565          DCB      0x75,0x65,0x75,0x65
000020  5f707573          DCB      0x5f,0x70,0x75,0x73
000024  6800              DCB      0x68,0x00
                  |symbol_number.26|
000026  7274              DCB      0x72,0x74
000028  5f646174          DCB      0x5f,0x64,0x61,0x74
00002c  615f7175          DCB      0x61,0x5f,0x71,0x75
000030  6575655f          DCB      0x65,0x75,0x65,0x5f
000034  706f7000          DCB      0x70,0x6f,0x70,0x00
                  |symbol_number.27|
000038  72745f64          DCB      0x72,0x74,0x5f,0x64
00003c  6174615f          DCB      0x61,0x74,0x61,0x5f
000040  71756575          DCB      0x71,0x75,0x65,0x75
000044  655f7065          DCB      0x65,0x5f,0x70,0x65
000048  616b00            DCB      0x61,0x6b,0x00
