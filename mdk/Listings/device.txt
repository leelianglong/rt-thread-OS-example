; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\device.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\device.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\device.crf ..\rt_thread\kernel\device.c]
                          THUMB

                          AREA ||i.rt_device_close||, CODE, READONLY, ALIGN=2

                  rt_device_close PROC
;;;238     */
;;;239    rt_err_t rt_device_close(rt_device_t dev)
000000  b570              PUSH     {r4-r6,lr}
;;;240    {
000002  4604              MOV      r4,r0
;;;241        rt_err_t result = RT_EOK;
000004  2500              MOVS     r5,#0
;;;242    
;;;243        RT_ASSERT(dev != RT_NULL);
000006  b924              CBNZ     r4,|L1.18|
000008  22f3              MOVS     r2,#0xf3
00000a  490e              LDR      r1,|L1.68|
00000c  a00e              ADR      r0,|L1.72|
00000e  f7fffffe          BL       rt_assert_handler
                  |L1.18|
;;;244    
;;;245        if (dev->ref_count == 0)
000012  7ea0              LDRB     r0,[r4,#0x1a]
000014  b910              CBNZ     r0,|L1.28|
;;;246            return -RT_ERROR;
000016  f04f30ff          MOV      r0,#0xffffffff
                  |L1.26|
;;;247    
;;;248        dev->ref_count--;
;;;249    
;;;250        if (dev->ref_count != 0)
;;;251            return RT_EOK;
;;;252    
;;;253        /* call device close interface */
;;;254        if (dev->close != RT_NULL)
;;;255        {
;;;256            result = dev->close(dev);
;;;257        }
;;;258    
;;;259        /* set open flag */
;;;260        if (result == RT_EOK || result == -RT_ENOSYS)
;;;261            dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
;;;262    
;;;263        return result;
;;;264    }
00001a  bd70              POP      {r4-r6,pc}
                  |L1.28|
00001c  7ea0              LDRB     r0,[r4,#0x1a]         ;248
00001e  1e40              SUBS     r0,r0,#1              ;248
000020  76a0              STRB     r0,[r4,#0x1a]         ;248
000022  7ea0              LDRB     r0,[r4,#0x1a]         ;250
000024  b108              CBZ      r0,|L1.42|
000026  2000              MOVS     r0,#0                 ;251
000028  e7f7              B        |L1.26|
                  |L1.42|
00002a  6ae0              LDR      r0,[r4,#0x2c]         ;254
00002c  b118              CBZ      r0,|L1.54|
00002e  4620              MOV      r0,r4                 ;256
000030  6ae1              LDR      r1,[r4,#0x2c]         ;256
000032  4788              BLX      r1                    ;256
000034  4605              MOV      r5,r0                 ;256
                  |L1.54|
000036  b10d              CBZ      r5,|L1.60|
000038  1da8              ADDS     r0,r5,#6              ;260
00003a  b908              CBNZ     r0,|L1.64|
                  |L1.60|
00003c  2000              MOVS     r0,#0                 ;261
00003e  8320              STRH     r0,[r4,#0x18]         ;261
                  |L1.64|
000040  4628              MOV      r0,r5                 ;263
000042  e7ea              B        |L1.26|
;;;265    RTM_EXPORT(rt_device_close);
                          ENDP

                  |L1.68|
                          DCD      |symbol_number.41|
                  |L1.72|
000048  64657620          DCB      "dev != RT_NULL",0
00004c  213d2052
000050  545f4e55
000054  4c4c00  
000057  00                DCB      0

                          AREA ||i.rt_device_control||, CODE, READONLY, ALIGN=2

                  rt_device_control PROC
;;;351     */
;;;352    rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;353    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;354        RT_ASSERT(dev != RT_NULL);
000008  b92c              CBNZ     r4,|L2.22|
00000a  f44f72b1          MOV      r2,#0x162
00000e  4907              LDR      r1,|L2.44|
000010  a007              ADR      r0,|L2.48|
000012  f7fffffe          BL       rt_assert_handler
                  |L2.22|
;;;355    
;;;356        /* call device write interface */
;;;357        if (dev->control != RT_NULL)
000016  6ba0              LDR      r0,[r4,#0x38]
000018  b128              CBZ      r0,|L2.38|
;;;358        {
;;;359            return dev->control(dev, cmd, arg);
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  6ba3              LDR      r3,[r4,#0x38]
000022  4798              BLX      r3
                  |L2.36|
;;;360        }
;;;361    
;;;362        return RT_EOK;
;;;363    }
000024  bd70              POP      {r4-r6,pc}
                  |L2.38|
000026  2000              MOVS     r0,#0                 ;362
000028  e7fc              B        |L2.36|
;;;364    RTM_EXPORT(rt_device_control);
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      |symbol_number.44|
                  |L2.48|
000030  64657620          DCB      "dev != RT_NULL",0
000034  213d2052
000038  545f4e55
00003c  4c4c00  
00003f  00                DCB      0

                          AREA ||i.rt_device_find||, CODE, READONLY, ALIGN=2

                  rt_device_find PROC
;;;99      */
;;;100    rt_device_t rt_device_find(const char *name)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;101    {
000004  4606              MOV      r6,r0
;;;102        struct rt_object *object;
;;;103        struct rt_list_node *node;
;;;104        struct rt_object_information *information;
;;;105    
;;;106        extern struct rt_object_information rt_object_container[];
;;;107    
;;;108        /* enter critical */
;;;109        if (rt_thread_self() != RT_NULL)
000006  f7fffffe          BL       rt_thread_self
00000a  b108              CBZ      r0,|L3.16|
;;;110            rt_enter_critical();
00000c  f7fffffe          BL       rt_enter_critical
                  |L3.16|
;;;111    
;;;112        /* try to find device object */
;;;113        information = &rt_object_container[RT_Object_Class_Device];
000010  4d0e              LDR      r5,|L3.76|
;;;114        for (node  = information->object_list.next;
000012  686c              LDR      r4,[r5,#4]
000014  e010              B        |L3.56|
                  |L3.22|
;;;115             node != &(information->object_list);
;;;116             node  = node->next)
;;;117        {
;;;118            object = rt_list_entry(node, struct rt_object, list);
000016  f1a4070c          SUB      r7,r4,#0xc
;;;119            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
00001a  2208              MOVS     r2,#8
00001c  4631              MOV      r1,r6
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       rt_strncmp
000024  b938              CBNZ     r0,|L3.54|
;;;120            {
;;;121                /* leave critical */
;;;122                if (rt_thread_self() != RT_NULL)
000026  f7fffffe          BL       rt_thread_self
00002a  b108              CBZ      r0,|L3.48|
;;;123                    rt_exit_critical();
00002c  f7fffffe          BL       rt_exit_critical
                  |L3.48|
;;;124    
;;;125                return (rt_device_t)object;
000030  4638              MOV      r0,r7
                  |L3.50|
;;;126            }
;;;127        }
;;;128    
;;;129        /* leave critical */
;;;130        if (rt_thread_self() != RT_NULL)
;;;131            rt_exit_critical();
;;;132    
;;;133        /* not found */
;;;134        return RT_NULL;
;;;135    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L3.54|
000036  6824              LDR      r4,[r4,#0]            ;116
                  |L3.56|
000038  1d28              ADDS     r0,r5,#4              ;115
00003a  4284              CMP      r4,r0                 ;115
00003c  d1eb              BNE      |L3.22|
00003e  f7fffffe          BL       rt_thread_self
000042  b108              CBZ      r0,|L3.72|
000044  f7fffffe          BL       rt_exit_critical
                  |L3.72|
000048  2000              MOVS     r0,#0                 ;134
00004a  e7f2              B        |L3.50|
;;;136    RTM_EXPORT(rt_device_find);
                          ENDP

                  |L3.76|
                          DCD      rt_object_container+0x70

                          AREA ||i.rt_device_init||, CODE, READONLY, ALIGN=2

                  rt_device_init PROC
;;;144     */
;;;145    rt_err_t rt_device_init(rt_device_t dev)
000000  b570              PUSH     {r4-r6,lr}
;;;146    {
000002  4604              MOV      r4,r0
;;;147        rt_err_t result = RT_EOK;
000004  2500              MOVS     r5,#0
;;;148    
;;;149        RT_ASSERT(dev != RT_NULL);
000006  b924              CBNZ     r4,|L4.18|
000008  2295              MOVS     r2,#0x95
00000a  490d              LDR      r1,|L4.64|
00000c  a00d              ADR      r0,|L4.68|
00000e  f7fffffe          BL       rt_assert_handler
                  |L4.18|
;;;150    
;;;151        /* get device init handler */
;;;152        if (dev->init != RT_NULL)
000012  6a60              LDR      r0,[r4,#0x24]
000014  b190              CBZ      r0,|L4.60|
;;;153        {
;;;154            if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
000016  7da0              LDRB     r0,[r4,#0x16]
000018  f0000010          AND      r0,r0,#0x10
00001c  b970              CBNZ     r0,|L4.60|
;;;155            {
;;;156                result = dev->init(dev);
00001e  4620              MOV      r0,r4
000020  6a61              LDR      r1,[r4,#0x24]
000022  4788              BLX      r1
000024  4605              MOV      r5,r0
;;;157                if (result != RT_EOK)
000026  b12d              CBZ      r5,|L4.52|
;;;158                {
;;;159                    rt_kprintf("To initialize device:%s failed. The error code is %d\n",
000028  462a              MOV      r2,r5
00002a  4621              MOV      r1,r4
00002c  a009              ADR      r0,|L4.84|
00002e  f7fffffe          BL       rt_kprintf
000032  e003              B        |L4.60|
                  |L4.52|
;;;160                               dev->parent.name, result);
;;;161                }
;;;162                else
;;;163                {
;;;164                    dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
000034  8ae0              LDRH     r0,[r4,#0x16]
000036  f0400010          ORR      r0,r0,#0x10
00003a  82e0              STRH     r0,[r4,#0x16]
                  |L4.60|
;;;165                }
;;;166            }
;;;167        }
;;;168    
;;;169        return result;
00003c  4628              MOV      r0,r5
;;;170    }
00003e  bd70              POP      {r4-r6,pc}
;;;171    
                          ENDP

                  |L4.64|
                          DCD      |symbol_number.39|
                  |L4.68|
000044  64657620          DCB      "dev != RT_NULL",0
000048  213d2052
00004c  545f4e55
000050  4c4c00  
000053  00                DCB      0
                  |L4.84|
000054  546f2069          DCB      "To initialize device:%s failed. The error code is %d\n",0
000058  6e697469
00005c  616c697a
000060  65206465
000064  76696365
000068  3a257320
00006c  6661696c
000070  65642e20
000074  54686520
000078  6572726f
00007c  7220636f
000080  64652069
000084  73202564
000088  0a00    
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.rt_device_init_all||, CODE, READONLY, ALIGN=1

                  rt_device_init_all PROC
;;;87      */
;;;88     rt_err_t rt_device_init_all(void)
000000  2000              MOVS     r0,#0
;;;89     {
;;;90         return RT_EOK;
;;;91     }
000002  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||i.rt_device_open||, CODE, READONLY, ALIGN=2

                  rt_device_open PROC
;;;179     */
;;;180    rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
000000  b570              PUSH     {r4-r6,lr}
;;;181    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;182        rt_err_t result = RT_EOK;
000006  2500              MOVS     r5,#0
;;;183    
;;;184        RT_ASSERT(dev != RT_NULL);
000008  b924              CBNZ     r4,|L6.20|
00000a  22b8              MOVS     r2,#0xb8
00000c  491e              LDR      r1,|L6.136|
00000e  a01f              ADR      r0,|L6.140|
000010  f7fffffe          BL       rt_assert_handler
                  |L6.20|
;;;185    
;;;186        /* if device is not initialized, initialize it. */
;;;187        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
000014  7da0              LDRB     r0,[r4,#0x16]
000016  f0000010          AND      r0,r0,#0x10
00001a  b988              CBNZ     r0,|L6.64|
;;;188        {
;;;189            if (dev->init != RT_NULL)
00001c  6a60              LDR      r0,[r4,#0x24]
00001e  b158              CBZ      r0,|L6.56|
;;;190            {
;;;191                result = dev->init(dev);
000020  4620              MOV      r0,r4
000022  6a61              LDR      r1,[r4,#0x24]
000024  4788              BLX      r1
000026  4605              MOV      r5,r0
;;;192                if (result != RT_EOK)
000028  b135              CBZ      r5,|L6.56|
;;;193                {
;;;194                    rt_kprintf("To initialize device:%s failed. The error code is %d\n",
00002a  462a              MOV      r2,r5
00002c  4621              MOV      r1,r4
00002e  a01b              ADR      r0,|L6.156|
000030  f7fffffe          BL       rt_kprintf
;;;195                               dev->parent.name, result);
;;;196    
;;;197                    return result;
000034  4628              MOV      r0,r5
                  |L6.54|
;;;198                }
;;;199            }
;;;200    
;;;201            dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
;;;202        }
;;;203    
;;;204        /* device is a stand alone device and opened */
;;;205        if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
;;;206            (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
;;;207        {
;;;208            return -RT_EBUSY;
;;;209        }
;;;210    
;;;211        /* call device open interface */
;;;212        if (dev->open != RT_NULL)
;;;213        {
;;;214            result = dev->open(dev, oflag);
;;;215        }
;;;216    
;;;217        /* set open flag */
;;;218        if (result == RT_EOK || result == -RT_ENOSYS)
;;;219        {
;;;220            dev->open_flag = oflag | RT_DEVICE_OFLAG_OPEN;
;;;221    
;;;222            dev->ref_count++;
;;;223            /* don't let bad things happen silently. If you are bitten by this assert,
;;;224             * please set the ref_count to a bigger type. */
;;;225            RT_ASSERT(dev->ref_count != 0);
;;;226        }
;;;227    
;;;228        return result;
;;;229    }
000036  bd70              POP      {r4-r6,pc}
                  |L6.56|
000038  8ae0              LDRH     r0,[r4,#0x16]         ;201
00003a  f0400010          ORR      r0,r0,#0x10           ;201
00003e  82e0              STRH     r0,[r4,#0x16]         ;201
                  |L6.64|
000040  7da0              LDRB     r0,[r4,#0x16]         ;205
000042  f0000008          AND      r0,r0,#8              ;205
000046  b130              CBZ      r0,|L6.86|
000048  7e20              LDRB     r0,[r4,#0x18]         ;206
00004a  f0000008          AND      r0,r0,#8              ;206
00004e  b110              CBZ      r0,|L6.86|
000050  f06f0006          MVN      r0,#6                 ;208
000054  e7ef              B        |L6.54|
                  |L6.86|
000056  6aa0              LDR      r0,[r4,#0x28]         ;212
000058  b120              CBZ      r0,|L6.100|
00005a  4631              MOV      r1,r6                 ;214
00005c  4620              MOV      r0,r4                 ;214
00005e  6aa2              LDR      r2,[r4,#0x28]         ;214
000060  4790              BLX      r2                    ;214
000062  4605              MOV      r5,r0                 ;214
                  |L6.100|
000064  b10d              CBZ      r5,|L6.106|
000066  1da8              ADDS     r0,r5,#6              ;218
000068  b960              CBNZ     r0,|L6.132|
                  |L6.106|
00006a  f0460008          ORR      r0,r6,#8              ;220
00006e  8320              STRH     r0,[r4,#0x18]         ;220
000070  7ea0              LDRB     r0,[r4,#0x1a]         ;222
000072  1c40              ADDS     r0,r0,#1              ;222
000074  76a0              STRB     r0,[r4,#0x1a]         ;222
000076  7ea0              LDRB     r0,[r4,#0x1a]         ;225
000078  b920              CBNZ     r0,|L6.132|
00007a  22e1              MOVS     r2,#0xe1              ;225
00007c  4902              LDR      r1,|L6.136|
00007e  a015              ADR      r0,|L6.212|
000080  f7fffffe          BL       rt_assert_handler
                  |L6.132|
000084  4628              MOV      r0,r5                 ;228
000086  e7d6              B        |L6.54|
;;;230    RTM_EXPORT(rt_device_open);
                          ENDP

                  |L6.136|
                          DCD      |symbol_number.40|
                  |L6.140|
00008c  64657620          DCB      "dev != RT_NULL",0
000090  213d2052
000094  545f4e55
000098  4c4c00  
00009b  00                DCB      0
                  |L6.156|
00009c  546f2069          DCB      "To initialize device:%s failed. The error code is %d\n",0
0000a0  6e697469
0000a4  616c697a
0000a8  65206465
0000ac  76696365
0000b0  3a257320
0000b4  6661696c
0000b8  65642e20
0000bc  54686520
0000c0  6572726f
0000c4  7220636f
0000c8  64652069
0000cc  73202564
0000d0  0a00    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L6.212|
0000d4  6465762d          DCB      "dev->ref_count != 0",0
0000d8  3e726566
0000dc  5f636f75
0000e0  6e742021
0000e4  3d203000

                          AREA ||i.rt_device_read||, CODE, READONLY, ALIGN=2

                  rt_device_read PROC
;;;278     */
;;;279    rt_size_t rt_device_read(rt_device_t dev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;280                             rt_off_t    pos,
;;;281                             void       *buffer,
;;;282                             rt_size_t   size)
;;;283    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;284        RT_ASSERT(dev != RT_NULL);
00000c  b92c              CBNZ     r4,|L7.26|
00000e  f44f728e          MOV      r2,#0x11c
000012  490e              LDR      r1,|L7.76|
000014  a00e              ADR      r0,|L7.80|
000016  f7fffffe          BL       rt_assert_handler
                  |L7.26|
;;;285    
;;;286        if (dev->ref_count == 0)
00001a  7ea0              LDRB     r0,[r4,#0x1a]
00001c  b930              CBNZ     r0,|L7.44|
;;;287        {
;;;288            rt_set_errno(-RT_ERROR);
00001e  f04f30ff          MOV      r0,#0xffffffff
000022  f7fffffe          BL       rt_set_errno
;;;289            return 0;
000026  2000              MOVS     r0,#0
                  |L7.40|
;;;290        }
;;;291    
;;;292        /* call device read interface */
;;;293        if (dev->read != RT_NULL)
;;;294        {
;;;295            return dev->read(dev, pos, buffer, size);
;;;296        }
;;;297    
;;;298        /* set error code */
;;;299        rt_set_errno(-RT_ENOSYS);
;;;300    
;;;301        return 0;
;;;302    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L7.44|
00002c  6b20              LDR      r0,[r4,#0x30]         ;293
00002e  b138              CBZ      r0,|L7.64|
000030  463b              MOV      r3,r7                 ;295
000032  4632              MOV      r2,r6                 ;295
000034  4629              MOV      r1,r5                 ;295
000036  4620              MOV      r0,r4                 ;295
000038  f8d4c030          LDR      r12,[r4,#0x30]        ;295
00003c  47e0              BLX      r12                   ;295
00003e  e7f3              B        |L7.40|
                  |L7.64|
000040  f06f0005          MVN      r0,#5                 ;299
000044  f7fffffe          BL       rt_set_errno
000048  2000              MOVS     r0,#0                 ;301
00004a  e7ed              B        |L7.40|
;;;303    RTM_EXPORT(rt_device_read);
                          ENDP

                  |L7.76|
                          DCD      |symbol_number.42|
                  |L7.80|
000050  64657620          DCB      "dev != RT_NULL",0
000054  213d2052
000058  545f4e55
00005c  4c4c00  
00005f  00                DCB      0

                          AREA ||i.rt_device_register||, CODE, READONLY, ALIGN=1

                  rt_device_register PROC
;;;43      */
;;;44     rt_err_t rt_device_register(rt_device_t dev,
000000  b570              PUSH     {r4-r6,lr}
;;;45                                 const char *name,
;;;46                                 rt_uint16_t flags)
;;;47     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;48         if (dev == RT_NULL)
000008  b914              CBNZ     r4,|L8.16|
;;;49             return -RT_ERROR;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L8.14|
;;;50     
;;;51         if (rt_device_find(name) != RT_NULL)
;;;52             return -RT_ERROR;
;;;53     
;;;54         rt_object_init(&(dev->parent), RT_Object_Class_Device, name);
;;;55         dev->flag = flags;
;;;56         dev->ref_count = 0;
;;;57         dev->open_flag = 0;
;;;58     
;;;59         return RT_EOK;
;;;60     }
00000e  bd70              POP      {r4-r6,pc}
                  |L8.16|
000010  4628              MOV      r0,r5                 ;51
000012  f7fffffe          BL       rt_device_find
000016  b110              CBZ      r0,|L8.30|
000018  f04f30ff          MOV      r0,#0xffffffff        ;52
00001c  e7f7              B        |L8.14|
                  |L8.30|
00001e  462a              MOV      r2,r5                 ;54
000020  2107              MOVS     r1,#7                 ;54
000022  4620              MOV      r0,r4                 ;54
000024  f7fffffe          BL       rt_object_init
000028  82e6              STRH     r6,[r4,#0x16]         ;55
00002a  2000              MOVS     r0,#0                 ;56
00002c  76a0              STRB     r0,[r4,#0x1a]         ;56
00002e  8320              STRH     r0,[r4,#0x18]         ;57
000030  bf00              NOP                            ;59
000032  e7ec              B        |L8.14|
;;;61     RTM_EXPORT(rt_device_register);
                          ENDP


                          AREA ||i.rt_device_set_rx_indicate||, CODE, READONLY, ALIGN=2

                  rt_device_set_rx_indicate PROC
;;;375    rt_err_t
;;;376    rt_device_set_rx_indicate(rt_device_t dev,
000000  b570              PUSH     {r4-r6,lr}
;;;377                              rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
;;;378    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;379        RT_ASSERT(dev != RT_NULL);
000006  b92c              CBNZ     r4,|L9.20|
000008  f240127b          MOV      r2,#0x17b
00000c  4903              LDR      r1,|L9.28|
00000e  a004              ADR      r0,|L9.32|
000010  f7fffffe          BL       rt_assert_handler
                  |L9.20|
;;;380    
;;;381        dev->rx_indicate = rx_ind;
000014  61e5              STR      r5,[r4,#0x1c]
;;;382    
;;;383        return RT_EOK;
000016  2000              MOVS     r0,#0
;;;384    }
000018  bd70              POP      {r4-r6,pc}
;;;385    RTM_EXPORT(rt_device_set_rx_indicate);
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      |symbol_number.45|
                  |L9.32|
000020  64657620          DCB      "dev != RT_NULL",0
000024  213d2052
000028  545f4e55
00002c  4c4c00  
00002f  00                DCB      0

                          AREA ||i.rt_device_set_tx_complete||, CODE, READONLY, ALIGN=2

                  rt_device_set_tx_complete PROC
;;;396    rt_err_t
;;;397    rt_device_set_tx_complete(rt_device_t dev,
000000  b570              PUSH     {r4-r6,lr}
;;;398                              rt_err_t (*tx_done)(rt_device_t dev, void *buffer))
;;;399    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;400        RT_ASSERT(dev != RT_NULL);
000006  b92c              CBNZ     r4,|L10.20|
000008  f44f72c8          MOV      r2,#0x190
00000c  4903              LDR      r1,|L10.28|
00000e  a004              ADR      r0,|L10.32|
000010  f7fffffe          BL       rt_assert_handler
                  |L10.20|
;;;401    
;;;402        dev->tx_complete = tx_done;
000014  6225              STR      r5,[r4,#0x20]
;;;403    
;;;404        return RT_EOK;
000016  2000              MOVS     r0,#0
;;;405    }
000018  bd70              POP      {r4-r6,pc}
;;;406    RTM_EXPORT(rt_device_set_tx_complete);
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      |symbol_number.46|
                  |L10.32|
000020  64657620          DCB      "dev != RT_NULL",0
000024  213d2052
000028  545f4e55
00002c  4c4c00  
00002f  00                DCB      0

                          AREA ||i.rt_device_unregister||, CODE, READONLY, ALIGN=2

                  rt_device_unregister PROC
;;;69      */
;;;70     rt_err_t rt_device_unregister(rt_device_t dev)
000000  b510              PUSH     {r4,lr}
;;;71     {
000002  4604              MOV      r4,r0
;;;72         RT_ASSERT(dev != RT_NULL);
000004  b924              CBNZ     r4,|L11.16|
000006  2248              MOVS     r2,#0x48
000008  4904              LDR      r1,|L11.28|
00000a  a005              ADR      r0,|L11.32|
00000c  f7fffffe          BL       rt_assert_handler
                  |L11.16|
;;;73     
;;;74         rt_object_detach(&(dev->parent));
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       rt_object_detach
;;;75     
;;;76         return RT_EOK;
000016  2000              MOVS     r0,#0
;;;77     }
000018  bd10              POP      {r4,pc}
;;;78     RTM_EXPORT(rt_device_unregister);
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      __FUNCTION__
                  |L11.32|
000020  64657620          DCB      "dev != RT_NULL",0
000024  213d2052
000028  545f4e55
00002c  4c4c00  
00002f  00                DCB      0

                          AREA ||i.rt_device_write||, CODE, READONLY, ALIGN=2

                  rt_device_write PROC
;;;316     */
;;;317    rt_size_t rt_device_write(rt_device_t dev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;318                              rt_off_t    pos,
;;;319                              const void *buffer,
;;;320                              rt_size_t   size)
;;;321    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;322        RT_ASSERT(dev != RT_NULL);
00000c  b92c              CBNZ     r4,|L12.26|
00000e  f44f72a1          MOV      r2,#0x142
000012  490e              LDR      r1,|L12.76|
000014  a00e              ADR      r0,|L12.80|
000016  f7fffffe          BL       rt_assert_handler
                  |L12.26|
;;;323    
;;;324        if (dev->ref_count == 0)
00001a  7ea0              LDRB     r0,[r4,#0x1a]
00001c  b930              CBNZ     r0,|L12.44|
;;;325        {
;;;326            rt_set_errno(-RT_ERROR);
00001e  f04f30ff          MOV      r0,#0xffffffff
000022  f7fffffe          BL       rt_set_errno
;;;327            return 0;
000026  2000              MOVS     r0,#0
                  |L12.40|
;;;328        }
;;;329    
;;;330        /* call device write interface */
;;;331        if (dev->write != RT_NULL)
;;;332        {
;;;333            return dev->write(dev, pos, buffer, size);
;;;334        }
;;;335    
;;;336        /* set error code */
;;;337        rt_set_errno(-RT_ENOSYS);
;;;338    
;;;339        return 0;
;;;340    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L12.44|
00002c  6b60              LDR      r0,[r4,#0x34]         ;331
00002e  b138              CBZ      r0,|L12.64|
000030  463b              MOV      r3,r7                 ;333
000032  4632              MOV      r2,r6                 ;333
000034  4629              MOV      r1,r5                 ;333
000036  4620              MOV      r0,r4                 ;333
000038  f8d4c034          LDR      r12,[r4,#0x34]        ;333
00003c  47e0              BLX      r12                   ;333
00003e  e7f3              B        |L12.40|
                  |L12.64|
000040  f06f0005          MVN      r0,#5                 ;337
000044  f7fffffe          BL       rt_set_errno
000048  2000              MOVS     r0,#0                 ;339
00004a  e7ed              B        |L12.40|
;;;341    RTM_EXPORT(rt_device_write);
                          ENDP

                  |L12.76|
                          DCD      |symbol_number.43|
                  |L12.80|
000050  64657620          DCB      "dev != RT_NULL",0
000054  213d2052
000058  545f4e55
00005c  4c4c00  
00005f  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f64          DCB      0x72,0x74,0x5f,0x64
000004  65766963          DCB      0x65,0x76,0x69,0x63
000008  655f756e          DCB      0x65,0x5f,0x75,0x6e
00000c  72656769          DCB      0x72,0x65,0x67,0x69
000010  73746572          DCB      0x73,0x74,0x65,0x72
000014  00                DCB      0x00
                  |symbol_number.39|
000015  72745f            DCB      0x72,0x74,0x5f
000018  64657669          DCB      0x64,0x65,0x76,0x69
00001c  63655f69          DCB      0x63,0x65,0x5f,0x69
000020  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.40|
000024  72745f64          DCB      0x72,0x74,0x5f,0x64
000028  65766963          DCB      0x65,0x76,0x69,0x63
00002c  655f6f70          DCB      0x65,0x5f,0x6f,0x70
000030  656e00            DCB      0x65,0x6e,0x00
                  |symbol_number.41|
000033  72                DCB      0x72
000034  745f6465          DCB      0x74,0x5f,0x64,0x65
000038  76696365          DCB      0x76,0x69,0x63,0x65
00003c  5f636c6f          DCB      0x5f,0x63,0x6c,0x6f
000040  736500            DCB      0x73,0x65,0x00
                  |symbol_number.42|
000043  72                DCB      0x72
000044  745f6465          DCB      0x74,0x5f,0x64,0x65
000048  76696365          DCB      0x76,0x69,0x63,0x65
00004c  5f726561          DCB      0x5f,0x72,0x65,0x61
000050  6400              DCB      0x64,0x00
                  |symbol_number.43|
000052  7274              DCB      0x72,0x74
000054  5f646576          DCB      0x5f,0x64,0x65,0x76
000058  6963655f          DCB      0x69,0x63,0x65,0x5f
00005c  77726974          DCB      0x77,0x72,0x69,0x74
000060  6500              DCB      0x65,0x00
                  |symbol_number.44|
000062  7274              DCB      0x72,0x74
000064  5f646576          DCB      0x5f,0x64,0x65,0x76
000068  6963655f          DCB      0x69,0x63,0x65,0x5f
00006c  636f6e74          DCB      0x63,0x6f,0x6e,0x74
000070  726f6c00          DCB      0x72,0x6f,0x6c,0x00
                  |symbol_number.45|
000074  72745f64          DCB      0x72,0x74,0x5f,0x64
000078  65766963          DCB      0x65,0x76,0x69,0x63
00007c  655f7365          DCB      0x65,0x5f,0x73,0x65
000080  745f7278          DCB      0x74,0x5f,0x72,0x78
000084  5f696e64          DCB      0x5f,0x69,0x6e,0x64
000088  69636174          DCB      0x69,0x63,0x61,0x74
00008c  6500              DCB      0x65,0x00
                  |symbol_number.46|
00008e  7274              DCB      0x72,0x74
000090  5f646576          DCB      0x5f,0x64,0x65,0x76
000094  6963655f          DCB      0x69,0x63,0x65,0x5f
000098  7365745f          DCB      0x73,0x65,0x74,0x5f
00009c  74785f63          DCB      0x74,0x78,0x5f,0x63
0000a0  6f6d706c          DCB      0x6f,0x6d,0x70,0x6c
0000a4  65746500          DCB      0x65,0x74,0x65,0x00
