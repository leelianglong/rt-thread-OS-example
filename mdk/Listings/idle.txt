; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\idle.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\idle.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\idle.crf ..\rt_thread\kernel\idle.c]
                          THUMB

                          AREA ||i._has_defunct_thread||, CODE, READONLY, ALIGN=2

                  _has_defunct_thread PROC
;;;64     /* Return whether there is defunctional thread to be deleted. */
;;;65     rt_inline int _has_defunct_thread(void)
000000  4903              LDR      r1,|L1.16|
;;;66     {
;;;67         /* The rt_list_isempty has prototype of "int rt_list_isempty(const rt_list_t *l)".
;;;68          * So the compiler has a good reason that the rt_thread_defunct list does
;;;69          * not change within rt_thread_idle_excute thus optimize the "while" loop
;;;70          * into a "if".
;;;71          *
;;;72          * So add the volatile qualifier here. */
;;;73         const volatile rt_list_t *l = (const volatile rt_list_t*)&rt_thread_defunct;
;;;74     
;;;75         return l->next != l;
000002  6808              LDR      r0,[r1,#0]
000004  4288              CMP      r0,r1
000006  d001              BEQ      |L1.12|
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;76     }
00000a  4770              BX       lr
                  |L1.12|
00000c  2000              MOVS     r0,#0                 ;75
00000e  e7fc              B        |L1.10|
;;;77     
                          ENDP

                  |L1.16|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_idle_entry||, CODE, READONLY, ALIGN=2

                  rt_thread_idle_entry PROC
;;;176    
;;;177    static void rt_thread_idle_entry(void *parameter)
000000  e007              B        |L2.18|
                  |L2.2|
;;;178    {
;;;179        while (1)
;;;180        {
;;;181            #ifdef RT_USING_HOOK
;;;182            if (rt_thread_idle_hook != RT_NULL)
000002  4804              LDR      r0,|L2.20|
000004  6800              LDR      r0,[r0,#0]  ; rt_thread_idle_hook
000006  b110              CBZ      r0,|L2.14|
;;;183                rt_thread_idle_hook();
000008  4802              LDR      r0,|L2.20|
00000a  6800              LDR      r0,[r0,#0]  ; rt_thread_idle_hook
00000c  4780              BLX      r0
                  |L2.14|
;;;184            #endif
;;;185    
;;;186            rt_thread_idle_excute();
00000e  f7fffffe          BL       rt_thread_idle_excute
                  |L2.18|
000012  e7f6              B        |L2.2|
;;;187        }
;;;188    }
;;;189    
                          ENDP

                  |L2.20|
                          DCD      rt_thread_idle_hook

                          AREA ||i.rt_thread_idle_excute||, CODE, READONLY, ALIGN=2

                  rt_thread_idle_excute PROC
;;;82      */
;;;83     void rt_thread_idle_excute(void)
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
;;;85         /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
;;;86          * will do all the cleanups. */
;;;87         while (_has_defunct_thread())
000002  e044              B        |L3.142|
                  |L3.4|
;;;88         {
;;;89             rt_base_t lock;
;;;90             rt_thread_t thread;
;;;91     #ifdef RT_USING_MODULE
;;;92             rt_module_t module = RT_NULL;
;;;93     #endif
;;;94             RT_DEBUG_NOT_IN_INTERRUPT;
000004  bf00              NOP      
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  b140              CBZ      r0,|L3.36|
000012  4922              LDR      r1,|L3.156|
000014  a022              ADR      r0,|L3.160|
000016  f7fffffe          BL       rt_kprintf
00001a  225e              MOVS     r2,#0x5e
00001c  491f              LDR      r1,|L3.156|
00001e  a029              ADR      r0,|L3.196|
000020  f7fffffe          BL       rt_assert_handler
                  |L3.36|
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       rt_hw_interrupt_enable
00002a  bf00              NOP      
;;;95     
;;;96             /* disable interrupt */
;;;97             lock = rt_hw_interrupt_disable();
00002c  f7fffffe          BL       rt_hw_interrupt_disable
000030  4605              MOV      r5,r0
;;;98     
;;;99             /* re-check whether list is empty */
;;;100            if (_has_defunct_thread())
000032  f7fffffe          BL       _has_defunct_thread
000036  b1e0              CBZ      r0,|L3.114|
;;;101            {
;;;102                /* get defunct thread */
;;;103                thread = rt_list_entry(rt_thread_defunct.next,
000038  4823              LDR      r0,|L3.200|
00003a  6800              LDR      r0,[r0,#0]  ; rt_thread_defunct
00003c  f1a00414          SUB      r4,r0,#0x14
;;;104                                       struct rt_thread,
;;;105                                       tlist);
;;;106    #ifdef RT_USING_MODULE
;;;107                /* get thread's parent module */
;;;108                module = (rt_module_t)thread->module_id;
;;;109    
;;;110                /* if the thread is module's main thread */
;;;111                if (module != RT_NULL && module->module_thread == thread)
;;;112                {
;;;113                    /* detach module's main thread */
;;;114                    module->module_thread = RT_NULL;
;;;115                }
;;;116    #endif
;;;117                /* remove defunct thread */
;;;118                rt_list_remove(&(thread->tlist));
000040  f1040014          ADD      r0,r4,#0x14
000044  e9d02100          LDRD     r2,r1,[r0,#0]
000048  6051              STR      r1,[r2,#4]
00004a  e9d01200          LDRD     r1,r2,[r0,#0]
00004e  6011              STR      r1,[r2,#0]
000050  6040              STR      r0,[r0,#4]
000052  6000              STR      r0,[r0,#0]
000054  bf00              NOP      
;;;119                /* invoke thread cleanup */
;;;120                if (thread->cleanup != RT_NULL)
000056  6fa0              LDR      r0,[r4,#0x78]
000058  b110              CBZ      r0,|L3.96|
;;;121                    thread->cleanup(thread);
00005a  4620              MOV      r0,r4
00005c  6fa1              LDR      r1,[r4,#0x78]
00005e  4788              BLX      r1
                  |L3.96|
;;;122    
;;;123                /* if it's a system object, not delete it */
;;;124                if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       rt_object_is_systemobject
000066  2801              CMP      r0,#1
000068  d107              BNE      |L3.122|
;;;125                {
;;;126                    /* enable interrupt */
;;;127                    rt_hw_interrupt_enable(lock);
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       rt_hw_interrupt_enable
                  |L3.112|
;;;128    
;;;129                    return;
;;;130                }
;;;131            }
;;;132            else
;;;133            {
;;;134                /* enable interrupt */
;;;135                rt_hw_interrupt_enable(lock);
;;;136    
;;;137                /* may the defunct thread list is removed by others, just return */
;;;138                return;
;;;139            }
;;;140    
;;;141            /* enable interrupt */
;;;142            rt_hw_interrupt_enable(lock);
;;;143    
;;;144    #ifdef RT_USING_HEAP
;;;145    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;146            /* the thread belongs to an application module */
;;;147            if (thread->flags & RT_OBJECT_FLAG_MODULE)
;;;148                rt_module_free((rt_module_t)thread->module_id, thread->stack_addr);
;;;149            else
;;;150    #endif
;;;151            /* release thread's stack */
;;;152            RT_KERNEL_FREE(thread->stack_addr);
;;;153            /* delete thread object */
;;;154            rt_object_delete((rt_object_t)thread);
;;;155    #endif
;;;156    
;;;157    #ifdef RT_USING_MODULE
;;;158            if (module != RT_NULL)
;;;159            {
;;;160                extern rt_err_t rt_module_destroy(rt_module_t module);
;;;161    
;;;162                /* if sub thread list and main thread are all empty */
;;;163                if ((module->module_thread == RT_NULL) &&
;;;164                    rt_list_isempty(&module->module_object[RT_Object_Class_Thread].object_list))
;;;165                {
;;;166                    module->nref --;
;;;167                }
;;;168    
;;;169                /* destroy module */
;;;170                if (module->nref == 0)
;;;171                    rt_module_destroy(module);
;;;172            }
;;;173    #endif
;;;174        }
;;;175    }
000070  bd70              POP      {r4-r6,pc}
                  |L3.114|
000072  4628              MOV      r0,r5                 ;135
000074  f7fffffe          BL       rt_hw_interrupt_enable
000078  e7fa              B        |L3.112|
                  |L3.122|
00007a  4628              MOV      r0,r5                 ;142
00007c  f7fffffe          BL       rt_hw_interrupt_enable
000080  6aa0              LDR      r0,[r4,#0x28]         ;152
000082  f7fffffe          BL       rt_free
000086  4620              MOV      r0,r4                 ;154
000088  f7fffffe          BL       rt_object_delete
00008c  bf00              NOP                            ;174
                  |L3.142|
00008e  f7fffffe          BL       _has_defunct_thread
000092  2800              CMP      r0,#0                 ;87
000094  d1b6              BNE      |L3.4|
000096  bf00              NOP      
000098  e7ea              B        |L3.112|
;;;176    
                          ENDP

00009a  0000              DCW      0x0000
                  |L3.156|
                          DCD      __FUNCTION__
                  |L3.160|
0000a0  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0000a4  74696f6e
0000a8  5b25735d
0000ac  20736861
0000b0  6c6c206e
0000b4  6f742075
0000b8  73656420
0000bc  696e2049
0000c0  53520a00
                  |L3.196|
0000c4  3000              DCB      "0",0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L3.200|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_idle_init||, CODE, READONLY, ALIGN=2

                  rt_thread_idle_init PROC
;;;196     */
;;;197    void rt_thread_idle_init(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;198    {
;;;199        /* initialize thread */
;;;200        rt_thread_init(&idle,
000002  2020              MOVS     r0,#0x20
000004  211f              MOVS     r1,#0x1f
000006  00c2              LSLS     r2,r0,#3
000008  4b07              LDR      r3,|L4.40|
00000a  e9cd3200          STRD     r3,r2,[sp,#0]
00000e  e9cd1002          STRD     r1,r0,[sp,#8]
000012  2300              MOVS     r3,#0
000014  4a05              LDR      r2,|L4.44|
000016  a106              ADR      r1,|L4.48|
000018  4807              LDR      r0,|L4.56|
00001a  f7fffffe          BL       rt_thread_init
;;;201                       "tidle",
;;;202                       rt_thread_idle_entry,
;;;203                       RT_NULL,
;;;204                       &rt_thread_stack[0],
;;;205                       sizeof(rt_thread_stack),
;;;206                       RT_THREAD_PRIORITY_MAX - 1,
;;;207                       32);
;;;208    
;;;209        /* startup */
;;;210        rt_thread_startup(&idle);
00001e  4806              LDR      r0,|L4.56|
000020  f7fffffe          BL       rt_thread_startup
;;;211    }
000024  bd1f              POP      {r0-r4,pc}
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      rt_thread_stack
                  |L4.44|
                          DCD      rt_thread_idle_entry
                  |L4.48|
000030  7469646c          DCB      "tidle",0
000034  6500    
000036  00                DCB      0
000037  00                DCB      0
                  |L4.56|
                          DCD      idle

                          AREA ||i.rt_thread_idle_sethook||, CODE, READONLY, ALIGN=2

                  rt_thread_idle_sethook PROC
;;;57      */
;;;58     void rt_thread_idle_sethook(void (*hook)(void))
000000  4901              LDR      r1,|L5.8|
;;;59     {
;;;60         rt_thread_idle_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_thread_idle_hook
;;;61     }
000004  4770              BX       lr
;;;62     #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      rt_thread_idle_hook

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  idle
                          %        128
                  rt_thread_stack
                          %        256

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f74          DCB      0x72,0x74,0x5f,0x74
000004  68726561          DCB      0x68,0x72,0x65,0x61
000008  645f6964          DCB      0x64,0x5f,0x69,0x64
00000c  6c655f65          DCB      0x6c,0x65,0x5f,0x65
000010  78637574          DCB      0x78,0x63,0x75,0x74
000014  6500              DCB      0x65,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  rt_thread_idle_hook
                          DCD      0x00000000
