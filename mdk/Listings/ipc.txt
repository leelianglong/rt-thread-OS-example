; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\ipc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ipc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\ipc.crf ..\rt_thread\kernel\ipc.c]
                          THUMB

                          AREA ||i.rt_event_control||, CODE, READONLY, ALIGN=2

                  rt_event_control PROC
;;;1212    */
;;;1213   rt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1214   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;1215       rt_ubase_t level;
;;;1216       RT_ASSERT(event != RT_NULL);
00000a  b92c              CBNZ     r4,|L1.24|
00000c  f44f6298          MOV      r2,#0x4c0
000010  490c              LDR      r1,|L1.68|
000012  a00d              ADR      r0,|L1.72|
000014  f7fffffe          BL       rt_assert_handler
                  |L1.24|
;;;1217   
;;;1218       if (cmd == RT_IPC_CMD_RESET)
000018  2d01              CMP      r5,#1
00001a  d110              BNE      |L1.62|
;;;1219       {
;;;1220           /* disable interrupt */
;;;1221           level = rt_hw_interrupt_disable();
00001c  f7fffffe          BL       rt_hw_interrupt_disable
000020  4606              MOV      r6,r0
;;;1222   
;;;1223           /* resume all waiting thread */
;;;1224           rt_ipc_list_resume_all(&event->parent.suspend_thread);
000022  f1040014          ADD      r0,r4,#0x14
000026  f7fffffe          BL       rt_ipc_list_resume_all
;;;1225   
;;;1226           /* init event set */
;;;1227           event->set = 0;
00002a  2000              MOVS     r0,#0
00002c  61e0              STR      r0,[r4,#0x1c]
;;;1228   
;;;1229           /* enable interrupt */
;;;1230           rt_hw_interrupt_enable(level);
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       rt_hw_interrupt_enable
;;;1231   
;;;1232           rt_schedule();
000034  f7fffffe          BL       rt_schedule
;;;1233   
;;;1234           return RT_EOK;
000038  2000              MOVS     r0,#0
                  |L1.58|
;;;1235       }
;;;1236   
;;;1237       return -RT_ERROR;
;;;1238   }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.62|
00003e  f04f30ff          MOV      r0,#0xffffffff        ;1237
000042  e7fa              B        |L1.58|
;;;1239   RTM_EXPORT(rt_event_control);
                          ENDP

                  |L1.68|
                          DCD      |symbol_number.147|
                  |L1.72|
000048  6576656e          DCB      "event != RT_NULL",0
00004c  7420213d
000050  2052545f
000054  4e554c4c
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.rt_event_create||, CODE, READONLY, ALIGN=2

                  rt_event_create PROC
;;;939     */
;;;940    rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;941    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;942        rt_event_t event;
;;;943    
;;;944        RT_DEBUG_NOT_IN_INTERRUPT;
000008  bf00              NOP      
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4607              MOV      r7,r0
000010  f7fffffe          BL       rt_interrupt_get_nest
000014  b148              CBZ      r0,|L2.42|
000016  490f              LDR      r1,|L2.84|
000018  a00f              ADR      r0,|L2.88|
00001a  f7fffffe          BL       rt_kprintf
00001e  f44f726c          MOV      r2,#0x3b0
000022  490c              LDR      r1,|L2.84|
000024  a015              ADR      r0,|L2.124|
000026  f7fffffe          BL       rt_assert_handler
                  |L2.42|
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       rt_hw_interrupt_enable
000030  bf00              NOP      
;;;945    
;;;946        /* allocate object */
;;;947        event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
000032  4629              MOV      r1,r5
000034  2003              MOVS     r0,#3
000036  f7fffffe          BL       rt_object_allocate
00003a  4604              MOV      r4,r0
;;;948        if (event == RT_NULL)
00003c  b914              CBNZ     r4,|L2.68|
;;;949            return event;
00003e  4620              MOV      r0,r4
                  |L2.64|
;;;950    
;;;951        /* set parent */
;;;952        event->parent.parent.flag = flag;
;;;953    
;;;954        /* init ipc object */
;;;955        rt_ipc_object_init(&(event->parent));
;;;956    
;;;957        /* init event */
;;;958        event->set = 0;
;;;959    
;;;960        return event;
;;;961    }
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L2.68|
000044  7266              STRB     r6,[r4,#9]            ;952
000046  4620              MOV      r0,r4                 ;955
000048  f7fffffe          BL       rt_ipc_object_init
00004c  2000              MOVS     r0,#0                 ;958
00004e  61e0              STR      r0,[r4,#0x1c]         ;958
000050  4620              MOV      r0,r4                 ;960
000052  e7f5              B        |L2.64|
;;;962    RTM_EXPORT(rt_event_create);
                          ENDP

                  |L2.84|
                          DCD      |symbol_number.143|
                  |L2.88|
000058  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00005c  74696f6e
000060  5b25735d
000064  20736861
000068  6c6c206e
00006c  6f742075
000070  73656420
000074  696e2049
000078  53520a00
                  |L2.124|
00007c  3000              DCB      "0",0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.rt_event_delete||, CODE, READONLY, ALIGN=2

                  rt_event_delete PROC
;;;970     */
;;;971    rt_err_t rt_event_delete(rt_event_t event)
000000  b570              PUSH     {r4-r6,lr}
;;;972    {
000002  4604              MOV      r4,r0
;;;973        /* parameter check */
;;;974        RT_ASSERT(event != RT_NULL);
000004  b92c              CBNZ     r4,|L3.18|
000006  f24032ce          MOV      r2,#0x3ce
00000a  4911              LDR      r1,|L3.80|
00000c  a011              ADR      r0,|L3.84|
00000e  f7fffffe          BL       rt_assert_handler
                  |L3.18|
;;;975    
;;;976        RT_DEBUG_NOT_IN_INTERRUPT;
000012  bf00              NOP      
000014  f7fffffe          BL       rt_hw_interrupt_disable
000018  4605              MOV      r5,r0
00001a  f7fffffe          BL       rt_interrupt_get_nest
00001e  b148              CBZ      r0,|L3.52|
000020  490b              LDR      r1,|L3.80|
000022  a011              ADR      r0,|L3.104|
000024  f7fffffe          BL       rt_kprintf
000028  f44f7274          MOV      r2,#0x3d0
00002c  4908              LDR      r1,|L3.80|
00002e  a017              ADR      r0,|L3.140|
000030  f7fffffe          BL       rt_assert_handler
                  |L3.52|
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       rt_hw_interrupt_enable
00003a  bf00              NOP      
;;;977    
;;;978        /* resume all suspended thread */
;;;979        rt_ipc_list_resume_all(&(event->parent.suspend_thread));
00003c  f1040014          ADD      r0,r4,#0x14
000040  f7fffffe          BL       rt_ipc_list_resume_all
;;;980    
;;;981        /* delete event object */
;;;982        rt_object_delete(&(event->parent.parent));
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       rt_object_delete
;;;983    
;;;984        return RT_EOK;
00004a  2000              MOVS     r0,#0
;;;985    }
00004c  bd70              POP      {r4-r6,pc}
;;;986    RTM_EXPORT(rt_event_delete);
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      |symbol_number.144|
                  |L3.84|
000054  6576656e          DCB      "event != RT_NULL",0
000058  7420213d
00005c  2052545f
000060  4e554c4c
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L3.104|
000068  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00006c  74696f6e
000070  5b25735d
000074  20736861
000078  6c6c206e
00007c  6f742075
000080  73656420
000084  696e2049
000088  53520a00
                  |L3.140|
00008c  3000              DCB      "0",0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.rt_event_detach||, CODE, READONLY, ALIGN=2

                  rt_event_detach PROC
;;;915     */
;;;916    rt_err_t rt_event_detach(rt_event_t event)
000000  b510              PUSH     {r4,lr}
;;;917    {
000002  4604              MOV      r4,r0
;;;918        /* parameter check */
;;;919        RT_ASSERT(event != RT_NULL);
000004  b92c              CBNZ     r4,|L4.18|
000006  f2403297          MOV      r2,#0x397
00000a  4906              LDR      r1,|L4.36|
00000c  a006              ADR      r0,|L4.40|
00000e  f7fffffe          BL       rt_assert_handler
                  |L4.18|
;;;920    
;;;921        /* resume all suspended thread */
;;;922        rt_ipc_list_resume_all(&(event->parent.suspend_thread));
000012  f1040014          ADD      r0,r4,#0x14
000016  f7fffffe          BL       rt_ipc_list_resume_all
;;;923    
;;;924        /* detach event object */
;;;925        rt_object_detach(&(event->parent.parent));
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_object_detach
;;;926    
;;;927        return RT_EOK;
000020  2000              MOVS     r0,#0
;;;928    }
000022  bd10              POP      {r4,pc}
;;;929    RTM_EXPORT(rt_event_detach);
                          ENDP

                  |L4.36|
                          DCD      |symbol_number.142|
                  |L4.40|
000028  6576656e          DCB      "event != RT_NULL",0
00002c  7420213d
000030  2052545f
000034  4e554c4c
000038  00      
000039  00                DCB      0
00003a  00                DCB      0
00003b  00                DCB      0

                          AREA ||i.rt_event_init||, CODE, READONLY, ALIGN=2

                  rt_event_init PROC
;;;888     */
;;;889    rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;890    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;891        RT_ASSERT(event != RT_NULL);
000008  b92c              CBNZ     r4,|L5.22|
00000a  f240327b          MOV      r2,#0x37b
00000e  4908              LDR      r1,|L5.48|
000010  a008              ADR      r0,|L5.52|
000012  f7fffffe          BL       rt_assert_handler
                  |L5.22|
;;;892    
;;;893        /* init object */
;;;894        rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
000016  462a              MOV      r2,r5
000018  2103              MOVS     r1,#3
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_object_init
;;;895    
;;;896        /* set parent flag */
;;;897        event->parent.parent.flag = flag;
000020  7266              STRB     r6,[r4,#9]
;;;898    
;;;899        /* init ipc object */
;;;900        rt_ipc_object_init(&(event->parent));
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_ipc_object_init
;;;901    
;;;902        /* init event */
;;;903        event->set = 0;
000028  2000              MOVS     r0,#0
00002a  61e0              STR      r0,[r4,#0x1c]
;;;904    
;;;905        return RT_EOK;
;;;906    }
00002c  bd70              POP      {r4-r6,pc}
;;;907    RTM_EXPORT(rt_event_init);
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      |symbol_number.141|
                  |L5.52|
000034  6576656e          DCB      "event != RT_NULL",0
000038  7420213d
00003c  2052545f
000040  4e554c4c
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.rt_event_recv||, CODE, READONLY, ALIGN=2

                  rt_event_recv PROC
;;;1092    */
;;;1093   rt_err_t rt_event_recv(rt_event_t   event,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1094                          rt_uint32_t  set,
;;;1095                          rt_uint8_t   option,
;;;1096                          rt_int32_t   timeout,
;;;1097                          rt_uint32_t *recved)
;;;1098   {
000004  b081              SUB      sp,sp,#4
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
00000c  f8dd8038          LDR      r8,[sp,#0x38]
;;;1099       struct rt_thread *thread;
;;;1100       register rt_ubase_t level;
;;;1101       register rt_base_t status;
;;;1102   
;;;1103       RT_DEBUG_IN_THREAD_CONTEXT;
000010  bf00              NOP      
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  9000              STR      r0,[sp,#0]
000018  f7fffffe          BL       rt_thread_self
00001c  b948              CBNZ     r0,|L6.50|
00001e  4954              LDR      r1,|L6.368|
000020  a054              ADR      r0,|L6.372|
000022  f7fffffe          BL       rt_kprintf
000026  f240424f          MOV      r2,#0x44f
00002a  4951              LDR      r1,|L6.368|
00002c  a05f              ADR      r0,|L6.428|
00002e  f7fffffe          BL       rt_assert_handler
                  |L6.50|
000032  bf00              NOP      
000034  f7fffffe          BL       rt_hw_interrupt_disable
000038  4683              MOV      r11,r0
00003a  f7fffffe          BL       rt_interrupt_get_nest
00003e  b148              CBZ      r0,|L6.84|
000040  494b              LDR      r1,|L6.368|
000042  a05b              ADR      r0,|L6.432|
000044  f7fffffe          BL       rt_kprintf
000048  f240424f          MOV      r2,#0x44f
00004c  4948              LDR      r1,|L6.368|
00004e  a057              ADR      r0,|L6.428|
000050  f7fffffe          BL       rt_assert_handler
                  |L6.84|
000054  4658              MOV      r0,r11
000056  f7fffffe          BL       rt_hw_interrupt_enable
00005a  bf00              NOP      
00005c  9800              LDR      r0,[sp,#0]
00005e  f7fffffe          BL       rt_hw_interrupt_enable
000062  bf00              NOP      
;;;1104   
;;;1105       /* parameter check */
;;;1106       RT_ASSERT(event != RT_NULL);
000064  b92d              CBNZ     r5,|L6.114|
000066  f2404252          MOV      r2,#0x452
00006a  4941              LDR      r1,|L6.368|
00006c  a059              ADR      r0,|L6.468|
00006e  f7fffffe          BL       rt_assert_handler
                  |L6.114|
;;;1107       if (set == 0)
000072  b926              CBNZ     r6,|L6.126|
;;;1108           return -RT_ERROR;
000074  f04f30ff          MOV      r0,#0xffffffff
                  |L6.120|
;;;1109   
;;;1110       /* init status */
;;;1111       status = -RT_ERROR;
;;;1112       /* get current thread */
;;;1113       thread = rt_thread_self();
;;;1114       /* reset thread error */
;;;1115       thread->error = RT_EOK;
;;;1116   
;;;1117       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
;;;1118   
;;;1119       /* disable interrupt */
;;;1120       level = rt_hw_interrupt_disable();
;;;1121   
;;;1122       /* check event set */
;;;1123       if (option & RT_EVENT_FLAG_AND)
;;;1124       {
;;;1125           if ((event->set & set) == set)
;;;1126               status = RT_EOK;
;;;1127       }
;;;1128       else if (option & RT_EVENT_FLAG_OR)
;;;1129       {
;;;1130           if (event->set & set)
;;;1131               status = RT_EOK;
;;;1132       }
;;;1133       else
;;;1134       {
;;;1135           /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
;;;1136           RT_ASSERT(0);
;;;1137       }
;;;1138   
;;;1139       if (status == RT_EOK)
;;;1140       {
;;;1141           /* set received event */
;;;1142           if (recved)
;;;1143               *recved = (event->set & set);
;;;1144   
;;;1145           /* received event */
;;;1146           if (option & RT_EVENT_FLAG_CLEAR)
;;;1147               event->set &= ~set;
;;;1148       }
;;;1149       else if (timeout == 0)
;;;1150       {
;;;1151           /* no waiting */
;;;1152           thread->error = -RT_ETIMEOUT;
;;;1153       }
;;;1154       else
;;;1155       {
;;;1156           /* fill thread event info */
;;;1157           thread->event_set  = set;
;;;1158           thread->event_info = option;
;;;1159   
;;;1160           /* put thread to suspended thread list */
;;;1161           rt_ipc_list_suspend(&(event->parent.suspend_thread),
;;;1162                               thread,
;;;1163                               event->parent.parent.flag);
;;;1164   
;;;1165           /* if there is a waiting timeout, active thread timer */
;;;1166           if (timeout > 0)
;;;1167           {
;;;1168               /* reset the timeout of thread timer and start it */
;;;1169               rt_timer_control(&(thread->thread_timer),
;;;1170                                RT_TIMER_CTRL_SET_TIME,
;;;1171                                &timeout);
;;;1172               rt_timer_start(&(thread->thread_timer));
;;;1173           }
;;;1174   
;;;1175           /* enable interrupt */
;;;1176           rt_hw_interrupt_enable(level);
;;;1177   
;;;1178           /* do a schedule */
;;;1179           rt_schedule();
;;;1180   
;;;1181           if (thread->error != RT_EOK)
;;;1182           {
;;;1183               /* return error */
;;;1184               return thread->error;
;;;1185           }
;;;1186   
;;;1187           /* received an event, disable interrupt to protect */
;;;1188           level = rt_hw_interrupt_disable();
;;;1189   
;;;1190           /* set received event */
;;;1191           if (recved)
;;;1192               *recved = thread->event_set;
;;;1193       }
;;;1194   
;;;1195       /* enable interrupt */
;;;1196       rt_hw_interrupt_enable(level);
;;;1197   
;;;1198       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
;;;1199   
;;;1200       return thread->error;
;;;1201   }
000078  b005              ADD      sp,sp,#0x14
00007a  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.126|
00007e  f04f39ff          MOV      r9,#0xffffffff        ;1111
000082  f7fffffe          BL       rt_thread_self
000086  4604              MOV      r4,r0                 ;1113
000088  2100              MOVS     r1,#0                 ;1115
00008a  6321              STR      r1,[r4,#0x30]         ;1115
00008c  bf00              NOP                            ;1117
00008e  4856              LDR      r0,|L6.488|
000090  6800              LDR      r0,[r0,#0]            ;1117  ; rt_object_trytake_hook
000092  b118              CBZ      r0,|L6.156|
000094  4628              MOV      r0,r5                 ;1117
000096  4954              LDR      r1,|L6.488|
000098  6809              LDR      r1,[r1,#0]            ;1117  ; rt_object_trytake_hook
00009a  4788              BLX      r1                    ;1117
                  |L6.156|
00009c  bf00              NOP                            ;1117
00009e  f7fffffe          BL       rt_hw_interrupt_disable
0000a2  4682              MOV      r10,r0                ;1120
0000a4  f0070001          AND      r0,r7,#1              ;1123
0000a8  b130              CBZ      r0,|L6.184|
0000aa  69e8              LDR      r0,[r5,#0x1c]         ;1125
0000ac  4030              ANDS     r0,r0,r6              ;1125
0000ae  42b0              CMP      r0,r6                 ;1125
0000b0  d111              BNE      |L6.214|
0000b2  f04f0900          MOV      r9,#0                 ;1126
0000b6  e00e              B        |L6.214|
                  |L6.184|
0000b8  f0070002          AND      r0,r7,#2              ;1128
0000bc  b128              CBZ      r0,|L6.202|
0000be  69e8              LDR      r0,[r5,#0x1c]         ;1130
0000c0  4030              ANDS     r0,r0,r6              ;1130
0000c2  b140              CBZ      r0,|L6.214|
0000c4  f04f0900          MOV      r9,#0                 ;1131
0000c8  e005              B        |L6.214|
                  |L6.202|
0000ca  f44f628e          MOV      r2,#0x470             ;1136
0000ce  4928              LDR      r1,|L6.368|
0000d0  a036              ADR      r0,|L6.428|
0000d2  f7fffffe          BL       rt_assert_handler
                  |L6.214|
0000d6  f1b90f00          CMP      r9,#0                 ;1139
0000da  d10d              BNE      |L6.248|
0000dc  f1b80f00          CMP      r8,#0                 ;1142
0000e0  d003              BEQ      |L6.234|
0000e2  69e8              LDR      r0,[r5,#0x1c]         ;1143
0000e4  4030              ANDS     r0,r0,r6              ;1143
0000e6  f8c80000          STR      r0,[r8,#0]            ;1143
                  |L6.234|
0000ea  f0070004          AND      r0,r7,#4              ;1146
0000ee  b388              CBZ      r0,|L6.340|
0000f0  69e8              LDR      r0,[r5,#0x1c]         ;1147
0000f2  43b0              BICS     r0,r0,r6              ;1147
0000f4  61e8              STR      r0,[r5,#0x1c]         ;1147
0000f6  e02d              B        |L6.340|
                  |L6.248|
0000f8  9804              LDR      r0,[sp,#0x10]         ;1149
0000fa  b918              CBNZ     r0,|L6.260|
0000fc  f06f0001          MVN      r0,#1                 ;1152
000100  6320              STR      r0,[r4,#0x30]         ;1152
000102  e027              B        |L6.340|
                  |L6.260|
000104  63e6              STR      r6,[r4,#0x3c]         ;1157
000106  f8847040          STRB     r7,[r4,#0x40]         ;1158
00010a  7a6a              LDRB     r2,[r5,#9]            ;1161
00010c  4621              MOV      r1,r4                 ;1161
00010e  f1050014          ADD      r0,r5,#0x14           ;1161
000112  f7fffffe          BL       rt_ipc_list_suspend
000116  9804              LDR      r0,[sp,#0x10]         ;1166
000118  2800              CMP      r0,#0                 ;1166
00011a  dd09              BLE      |L6.304|
00011c  aa04              ADD      r2,sp,#0x10           ;1169
00011e  2100              MOVS     r1,#0                 ;1169
000120  f104004c          ADD      r0,r4,#0x4c           ;1169
000124  f7fffffe          BL       rt_timer_control
000128  f104004c          ADD      r0,r4,#0x4c           ;1172
00012c  f7fffffe          BL       rt_timer_start
                  |L6.304|
000130  4650              MOV      r0,r10                ;1176
000132  f7fffffe          BL       rt_hw_interrupt_enable
000136  f7fffffe          BL       rt_schedule
00013a  6b20              LDR      r0,[r4,#0x30]         ;1181
00013c  b108              CBZ      r0,|L6.322|
00013e  6b20              LDR      r0,[r4,#0x30]         ;1184
000140  e79a              B        |L6.120|
                  |L6.322|
000142  f7fffffe          BL       rt_hw_interrupt_disable
000146  4682              MOV      r10,r0                ;1188
000148  f1b80f00          CMP      r8,#0                 ;1191
00014c  d002              BEQ      |L6.340|
00014e  6be0              LDR      r0,[r4,#0x3c]         ;1192
000150  f8c80000          STR      r0,[r8,#0]            ;1192
                  |L6.340|
000154  4650              MOV      r0,r10                ;1196
000156  f7fffffe          BL       rt_hw_interrupt_enable
00015a  bf00              NOP                            ;1198
00015c  4823              LDR      r0,|L6.492|
00015e  6800              LDR      r0,[r0,#0]            ;1198  ; rt_object_take_hook
000160  b118              CBZ      r0,|L6.362|
000162  4628              MOV      r0,r5                 ;1198
000164  4921              LDR      r1,|L6.492|
000166  6809              LDR      r1,[r1,#0]            ;1198  ; rt_object_take_hook
000168  4788              BLX      r1                    ;1198
                  |L6.362|
00016a  bf00              NOP                            ;1198
00016c  6b20              LDR      r0,[r4,#0x30]         ;1200
00016e  e783              B        |L6.120|
;;;1202   RTM_EXPORT(rt_event_recv);
                          ENDP

                  |L6.368|
                          DCD      |symbol_number.146|
                  |L6.372|
000174  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
000178  74696f6e
00017c  5b25735d
000180  20736861
000184  6c6c206e
000188  6f742062
00018c  65207573
000190  65642062
000194  65666f72
000198  65207363
00019c  68656475
0001a0  6c657220
0001a4  73746172
0001a8  740a    
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L6.428|
0001ac  3000              DCB      "0",0
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L6.432|
0001b0  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0001b4  74696f6e
0001b8  5b25735d
0001bc  20736861
0001c0  6c6c206e
0001c4  6f742075
0001c8  73656420
0001cc  696e2049
0001d0  53520a00
                  |L6.468|
0001d4  6576656e          DCB      "event != RT_NULL",0
0001d8  7420213d
0001dc  2052545f
0001e0  4e554c4c
0001e4  00      
0001e5  00                DCB      0
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L6.488|
                          DCD      rt_object_trytake_hook
                  |L6.492|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_event_send||, CODE, READONLY, ALIGN=2

                  rt_event_send PROC
;;;997     */
;;;998    rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;999    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1000       struct rt_list_node *n;
;;;1001       struct rt_thread *thread;
;;;1002       register rt_ubase_t level;
;;;1003       register rt_base_t status;
;;;1004       rt_bool_t need_schedule;
;;;1005   
;;;1006       /* parameter check */
;;;1007       RT_ASSERT(event != RT_NULL);
000008  b92c              CBNZ     r4,|L7.22|
00000a  f24032ef          MOV      r2,#0x3ef
00000e  4931              LDR      r1,|L7.212|
000010  a031              ADR      r0,|L7.216|
000012  f7fffffe          BL       rt_assert_handler
                  |L7.22|
;;;1008       if (set == 0)
000016  b91f              CBNZ     r7,|L7.32|
;;;1009           return -RT_ERROR;
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L7.28|
;;;1010   
;;;1011       need_schedule = RT_FALSE;
;;;1012       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
;;;1013   
;;;1014       /* disable interrupt */
;;;1015       level = rt_hw_interrupt_disable();
;;;1016   
;;;1017       /* set event */
;;;1018       event->set |= set;
;;;1019   
;;;1020       if (!rt_list_isempty(&event->parent.suspend_thread))
;;;1021       {
;;;1022           /* search thread list to resume thread */
;;;1023           n = event->parent.suspend_thread.next;
;;;1024           while (n != &(event->parent.suspend_thread))
;;;1025           {
;;;1026               /* get thread */
;;;1027               thread = rt_list_entry(n, struct rt_thread, tlist);
;;;1028   
;;;1029               status = -RT_ERROR;
;;;1030               if (thread->event_info & RT_EVENT_FLAG_AND)
;;;1031               {
;;;1032                   if ((thread->event_set & event->set) == thread->event_set)
;;;1033                   {
;;;1034                       /* received an AND event */
;;;1035                       status = RT_EOK;
;;;1036                   }
;;;1037               }
;;;1038               else if (thread->event_info & RT_EVENT_FLAG_OR)
;;;1039               {
;;;1040                   if (thread->event_set & event->set)
;;;1041                   {
;;;1042                       /* save recieved event set */
;;;1043                       thread->event_set = thread->event_set & event->set;
;;;1044   
;;;1045                       /* received an OR event */
;;;1046                       status = RT_EOK;
;;;1047                   }
;;;1048               }
;;;1049   
;;;1050               /* move node to the next */
;;;1051               n = n->next;
;;;1052   
;;;1053               /* condition is satisfied, resume thread */
;;;1054               if (status == RT_EOK)
;;;1055               {
;;;1056                   /* clear event */
;;;1057                   if (thread->event_info & RT_EVENT_FLAG_CLEAR)
;;;1058                       event->set &= ~thread->event_set;
;;;1059   
;;;1060                   /* resume thread, and thread list breaks out */
;;;1061                   rt_thread_resume(thread);
;;;1062   
;;;1063                   /* need do a scheduling */
;;;1064                   need_schedule = RT_TRUE;
;;;1065               }
;;;1066           }
;;;1067       }
;;;1068   
;;;1069       /* enable interrupt */
;;;1070       rt_hw_interrupt_enable(level);
;;;1071   
;;;1072       /* do a schedule */
;;;1073       if (need_schedule == RT_TRUE)
;;;1074           rt_schedule();
;;;1075   
;;;1076       return RT_EOK;
;;;1077   }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L7.32|
000020  f04f0800          MOV      r8,#0                 ;1011
000024  bf00              NOP                            ;1012
000026  4831              LDR      r0,|L7.236|
000028  6800              LDR      r0,[r0,#0]            ;1012  ; rt_object_put_hook
00002a  b118              CBZ      r0,|L7.52|
00002c  4620              MOV      r0,r4                 ;1012
00002e  492f              LDR      r1,|L7.236|
000030  6809              LDR      r1,[r1,#0]            ;1012  ; rt_object_put_hook
000032  4788              BLX      r1                    ;1012
                  |L7.52|
000034  bf00              NOP                            ;1012
000036  f7fffffe          BL       rt_hw_interrupt_disable
00003a  4682              MOV      r10,r0                ;1015
00003c  69e0              LDR      r0,[r4,#0x1c]         ;1018
00003e  4338              ORRS     r0,r0,r7              ;1018
000040  61e0              STR      r0,[r4,#0x1c]         ;1018
000042  f1040014          ADD      r0,r4,#0x14           ;1020
000046  f7fffffe          BL       rt_list_isempty
00004a  bbc0              CBNZ     r0,|L7.190|
00004c  6966              LDR      r6,[r4,#0x14]         ;1023
00004e  e032              B        |L7.182|
                  |L7.80|
000050  f1a60514          SUB      r5,r6,#0x14           ;1027
000054  f04f39ff          MOV      r9,#0xffffffff        ;1029
000058  f8950040          LDRB     r0,[r5,#0x40]         ;1030
00005c  f0000001          AND      r0,r0,#1              ;1030
000060  b140              CBZ      r0,|L7.116|
000062  6be8              LDR      r0,[r5,#0x3c]         ;1032
000064  69e1              LDR      r1,[r4,#0x1c]         ;1032
000066  4008              ANDS     r0,r0,r1              ;1032
000068  6be9              LDR      r1,[r5,#0x3c]         ;1032
00006a  4288              CMP      r0,r1                 ;1032
00006c  d111              BNE      |L7.146|
00006e  f04f0900          MOV      r9,#0                 ;1035
000072  e00e              B        |L7.146|
                  |L7.116|
000074  f8950040          LDRB     r0,[r5,#0x40]         ;1038
000078  f0000002          AND      r0,r0,#2              ;1038
00007c  b148              CBZ      r0,|L7.146|
00007e  6be8              LDR      r0,[r5,#0x3c]         ;1040
000080  69e1              LDR      r1,[r4,#0x1c]         ;1040
000082  4008              ANDS     r0,r0,r1              ;1040
000084  b128              CBZ      r0,|L7.146|
000086  6be8              LDR      r0,[r5,#0x3c]         ;1043
000088  69e1              LDR      r1,[r4,#0x1c]         ;1043
00008a  4008              ANDS     r0,r0,r1              ;1043
00008c  63e8              STR      r0,[r5,#0x3c]         ;1043
00008e  f04f0900          MOV      r9,#0                 ;1046
                  |L7.146|
000092  6836              LDR      r6,[r6,#0]            ;1051
000094  f1b90f00          CMP      r9,#0                 ;1054
000098  d10d              BNE      |L7.182|
00009a  f8950040          LDRB     r0,[r5,#0x40]         ;1057
00009e  f0000004          AND      r0,r0,#4              ;1057
0000a2  b118              CBZ      r0,|L7.172|
0000a4  69e0              LDR      r0,[r4,#0x1c]         ;1058
0000a6  6be9              LDR      r1,[r5,#0x3c]         ;1058
0000a8  4388              BICS     r0,r0,r1              ;1058
0000aa  61e0              STR      r0,[r4,#0x1c]         ;1058
                  |L7.172|
0000ac  4628              MOV      r0,r5                 ;1061
0000ae  f7fffffe          BL       rt_thread_resume
0000b2  f04f0801          MOV      r8,#1                 ;1064
                  |L7.182|
0000b6  f1040014          ADD      r0,r4,#0x14           ;1024
0000ba  4286              CMP      r6,r0                 ;1024
0000bc  d1c8              BNE      |L7.80|
                  |L7.190|
0000be  4650              MOV      r0,r10                ;1070
0000c0  f7fffffe          BL       rt_hw_interrupt_enable
0000c4  f1b80f01          CMP      r8,#1                 ;1073
0000c8  d101              BNE      |L7.206|
0000ca  f7fffffe          BL       rt_schedule
                  |L7.206|
0000ce  2000              MOVS     r0,#0                 ;1076
0000d0  e7a4              B        |L7.28|
;;;1078   RTM_EXPORT(rt_event_send);
                          ENDP

0000d2  0000              DCW      0x0000
                  |L7.212|
                          DCD      |symbol_number.145|
                  |L7.216|
0000d8  6576656e          DCB      "event != RT_NULL",0
0000dc  7420213d
0000e0  2052545f
0000e4  4e554c4c
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L7.236|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_ipc_list_resume||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_resume PROC
;;;145     */
;;;146    rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
000000  b570              PUSH     {r4-r6,lr}
;;;147    {
000002  4604              MOV      r4,r0
;;;148        struct rt_thread *thread;
;;;149    
;;;150        /* get thread entry */
;;;151        thread = rt_list_entry(list->next, struct rt_thread, tlist);
000004  6820              LDR      r0,[r4,#0]
000006  f1a00514          SUB      r5,r0,#0x14
;;;152    
;;;153        RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;154    
;;;155        /* resume it */
;;;156        rt_thread_resume(thread);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       rt_thread_resume
;;;157    
;;;158        return RT_EOK;
000014  2000              MOVS     r0,#0
;;;159    }
000016  bd70              POP      {r4-r6,pc}
;;;160    
                          ENDP


                          AREA ||i.rt_ipc_list_resume_all||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_resume_all PROC
;;;168     */
;;;169    rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
000000  b570              PUSH     {r4-r6,lr}
;;;170    {
000002  4605              MOV      r5,r0
;;;171        struct rt_thread *thread;
;;;172        register rt_ubase_t temp;
;;;173    
;;;174        /* wakeup all suspend threads */
;;;175        while (!rt_list_isempty(list))
000004  e00e              B        |L9.36|
                  |L9.6|
;;;176        {
;;;177            /* disable interrupt */
;;;178            temp = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
;;;179    
;;;180            /* get next suspend thread */
;;;181            thread = rt_list_entry(list->next, struct rt_thread, tlist);
00000c  6828              LDR      r0,[r5,#0]
00000e  f1a00414          SUB      r4,r0,#0x14
;;;182            /* set error code to RT_ERROR */
;;;183            thread->error = -RT_ERROR;
000012  f04f30ff          MOV      r0,#0xffffffff
000016  6320              STR      r0,[r4,#0x30]
;;;184    
;;;185            /*
;;;186             * resume thread
;;;187             * In rt_thread_resume function, it will remove current thread from
;;;188             * suspend list
;;;189             */
;;;190            rt_thread_resume(thread);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_thread_resume
;;;191    
;;;192            /* enable interrupt */
;;;193            rt_hw_interrupt_enable(temp);
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       rt_hw_interrupt_enable
                  |L9.36|
000024  4628              MOV      r0,r5                 ;175
000026  f7fffffe          BL       rt_list_isempty
00002a  2800              CMP      r0,#0                 ;175
00002c  d0eb              BEQ      |L9.6|
;;;194        }
;;;195    
;;;196        return RT_EOK;
00002e  2000              MOVS     r0,#0
;;;197    }
000030  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP


                          AREA ||i.rt_ipc_list_suspend||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_suspend PROC
;;;91      */
;;;92     rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;93                                            struct rt_thread *thread,
;;;94                                            rt_uint8_t        flag)
;;;95     {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;96         /* suspend thread */
;;;97         rt_thread_suspend(thread);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_thread_suspend
;;;98     
;;;99         switch (flag)
000010  f1b80f00          CMP      r8,#0
000014  d003              BEQ      |L10.30|
000016  f1b80f01          CMP      r8,#1
00001a  d123              BNE      |L10.100|
00001c  e005              B        |L10.42|
                  |L10.30|
;;;100        {
;;;101        case RT_IPC_FLAG_FIFO:
;;;102            rt_list_insert_before(list, &(thread->tlist));
00001e  f1040114          ADD      r1,r4,#0x14
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       rt_list_insert_before
;;;103            break;
000028  e01c              B        |L10.100|
                  |L10.42|
;;;104    
;;;105        case RT_IPC_FLAG_PRIO:
;;;106            {
;;;107                struct rt_list_node *n;
;;;108                struct rt_thread *sthread;
;;;109    
;;;110                /* find a suitable position */
;;;111                for (n = list->next; n != list; n = n->next)
00002a  682e              LDR      r6,[r5,#0]
00002c  e00f              B        |L10.78|
                  |L10.46|
;;;112                {
;;;113                    sthread = rt_list_entry(n, struct rt_thread, tlist);
00002e  f1a60714          SUB      r7,r6,#0x14
;;;114    
;;;115                    /* find out */
;;;116                    if (thread->current_priority < sthread->current_priority)
000032  f8940035          LDRB     r0,[r4,#0x35]
000036  f8971035          LDRB     r1,[r7,#0x35]
00003a  4288              CMP      r0,r1
00003c  da06              BGE      |L10.76|
;;;117                    {
;;;118                        /* insert this thread before the sthread */
;;;119                        rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
00003e  f1040114          ADD      r1,r4,#0x14
000042  f1070014          ADD      r0,r7,#0x14
000046  f7fffffe          BL       rt_list_insert_before
;;;120                        break;
00004a  e002              B        |L10.82|
                  |L10.76|
00004c  6836              LDR      r6,[r6,#0]            ;111
                  |L10.78|
00004e  42ae              CMP      r6,r5                 ;111
000050  d1ed              BNE      |L10.46|
                  |L10.82|
000052  bf00              NOP      
;;;121                    }
;;;122                }
;;;123    
;;;124                /*
;;;125                 * not found a suitable position,
;;;126                 * append to the end of suspend_thread list
;;;127                 */
;;;128                if (n == list)
000054  42ae              CMP      r6,r5
000056  d104              BNE      |L10.98|
;;;129                    rt_list_insert_before(list, &(thread->tlist));
000058  f1040114          ADD      r1,r4,#0x14
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       rt_list_insert_before
                  |L10.98|
;;;130            }
;;;131            break;
000062  bf00              NOP      
                  |L10.100|
000064  bf00              NOP                            ;103
;;;132        }
;;;133    
;;;134        return RT_EOK;
000066  2000              MOVS     r0,#0
;;;135    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;136    
                          ENDP


                          AREA ||i.rt_ipc_object_init||, CODE, READONLY, ALIGN=1

                  rt_ipc_object_init PROC
;;;72      */
;;;73     rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
000000  b510              PUSH     {r4,lr}
;;;74     {
000002  4604              MOV      r4,r0
;;;75         /* init ipc object */
;;;76         rt_list_init(&(ipc->suspend_thread));
000004  f1040014          ADD      r0,r4,#0x14
000008  f7fffffe          BL       rt_list_init
;;;77     
;;;78         return RT_EOK;
00000c  2000              MOVS     r0,#0
;;;79     }
00000e  bd10              POP      {r4,pc}
;;;80     
                          ENDP


                          AREA ||i.rt_list_init||, CODE, READONLY, ALIGN=1

                  rt_list_init PROC
;;;50      */
;;;51     rt_inline void rt_list_init(rt_list_t *l)
000000  6040              STR      r0,[r0,#4]
;;;52     {
;;;53         l->next = l->prev = l;
000002  6000              STR      r0,[r0,#0]
;;;54     }
000004  4770              BX       lr
;;;55     
                          ENDP


                          AREA ||i.rt_list_insert_before||, CODE, READONLY, ALIGN=1

                  rt_list_insert_before PROC
;;;76      */
;;;77     rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
000000  6842              LDR      r2,[r0,#4]
;;;78     {
;;;79         l->prev->next = n;
000002  6011              STR      r1,[r2,#0]
;;;80         n->prev = l->prev;
000004  6842              LDR      r2,[r0,#4]
000006  604a              STR      r2,[r1,#4]
;;;81     
;;;82         l->prev = n;
000008  6041              STR      r1,[r0,#4]
;;;83         n->next = l;
00000a  6008              STR      r0,[r1,#0]
;;;84     }
00000c  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;101     */
;;;102    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  4601              MOV      r1,r0
;;;103    {
;;;104        return l->next == l;
000002  6808              LDR      r0,[r1,#0]
000004  4288              CMP      r0,r1
000006  d101              BNE      |L14.12|
000008  2001              MOVS     r0,#1
                  |L14.10|
;;;105    }
00000a  4770              BX       lr
                  |L14.12|
00000c  2000              MOVS     r0,#0                 ;104
00000e  e7fc              B        |L14.10|
;;;106    
                          ENDP


                          AREA ||i.rt_mb_control||, CODE, READONLY, ALIGN=2

                  rt_mb_control PROC
;;;1687    */
;;;1688   rt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1689   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;1690       rt_ubase_t level;
;;;1691       RT_ASSERT(mb != RT_NULL);
00000a  b92c              CBNZ     r4,|L15.24|
00000c  f240629b          MOV      r2,#0x69b
000010  490f              LDR      r1,|L15.80|
000012  a010              ADR      r0,|L15.84|
000014  f7fffffe          BL       rt_assert_handler
                  |L15.24|
;;;1692   
;;;1693       if (cmd == RT_IPC_CMD_RESET)
000018  2d01              CMP      r5,#1
00001a  d116              BNE      |L15.74|
;;;1694       {
;;;1695           /* disable interrupt */
;;;1696           level = rt_hw_interrupt_disable();
00001c  f7fffffe          BL       rt_hw_interrupt_disable
000020  4606              MOV      r6,r0
;;;1697   
;;;1698           /* resume all waiting thread */
;;;1699           rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
000022  f1040014          ADD      r0,r4,#0x14
000026  f7fffffe          BL       rt_ipc_list_resume_all
;;;1700           /* also resume all mailbox private suspended thread */
;;;1701           rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
00002a  f1040028          ADD      r0,r4,#0x28
00002e  f7fffffe          BL       rt_ipc_list_resume_all
;;;1702   
;;;1703           /* re-init mailbox */
;;;1704           mb->entry      = 0;
000032  2000              MOVS     r0,#0
000034  8460              STRH     r0,[r4,#0x22]
;;;1705           mb->in_offset  = 0;
000036  84a0              STRH     r0,[r4,#0x24]
;;;1706           mb->out_offset = 0;
000038  84e0              STRH     r0,[r4,#0x26]
;;;1707   
;;;1708           /* enable interrupt */
;;;1709           rt_hw_interrupt_enable(level);
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       rt_hw_interrupt_enable
;;;1710   
;;;1711           rt_schedule();
000040  f7fffffe          BL       rt_schedule
;;;1712   
;;;1713           return RT_EOK;
000044  2000              MOVS     r0,#0
                  |L15.70|
;;;1714       }
;;;1715   
;;;1716       return -RT_ERROR;
;;;1717   }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L15.74|
00004a  f04f30ff          MOV      r0,#0xffffffff        ;1716
00004e  e7fa              B        |L15.70|
;;;1718   RTM_EXPORT(rt_mb_control);
                          ENDP

                  |L15.80|
                          DCD      |symbol_number.154|
                  |L15.84|
000054  6d622021          DCB      "mb != RT_NULL",0
000058  3d205254
00005c  5f4e554c
000060  4c00    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.rt_mb_create||, CODE, READONLY, ALIGN=2

                  rt_mb_create PROC
;;;1319    */
;;;1320   rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1321   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1322       rt_mailbox_t mb;
;;;1323   
;;;1324       RT_DEBUG_NOT_IN_INTERRUPT;
00000a  bf00              NOP      
00000c  f7fffffe          BL       rt_hw_interrupt_disable
000010  4680              MOV      r8,r0
000012  f7fffffe          BL       rt_interrupt_get_nest
000016  b148              CBZ      r0,|L16.44|
000018  4918              LDR      r1,|L16.124|
00001a  a019              ADR      r0,|L16.128|
00001c  f7fffffe          BL       rt_kprintf
000020  f240522c          MOV      r2,#0x52c
000024  4915              LDR      r1,|L16.124|
000026  a01f              ADR      r0,|L16.164|
000028  f7fffffe          BL       rt_assert_handler
                  |L16.44|
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       rt_hw_interrupt_enable
000032  bf00              NOP      
;;;1325   
;;;1326       /* allocate object */
;;;1327       mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
000034  4629              MOV      r1,r5
000036  2004              MOVS     r0,#4
000038  f7fffffe          BL       rt_object_allocate
00003c  4604              MOV      r4,r0
;;;1328       if (mb == RT_NULL)
00003e  b914              CBNZ     r4,|L16.70|
;;;1329           return mb;
000040  4620              MOV      r0,r4
                  |L16.66|
;;;1330   
;;;1331       /* set parent */
;;;1332       mb->parent.parent.flag = flag;
;;;1333   
;;;1334       /* init ipc object */
;;;1335       rt_ipc_object_init(&(mb->parent));
;;;1336   
;;;1337       /* init mailbox */
;;;1338       mb->size     = size;
;;;1339       mb->msg_pool = RT_KERNEL_MALLOC(mb->size * sizeof(rt_uint32_t));
;;;1340       if (mb->msg_pool == RT_NULL)
;;;1341       {
;;;1342           /* delete mailbox object */
;;;1343           rt_object_delete(&(mb->parent.parent));
;;;1344   
;;;1345           return RT_NULL;
;;;1346       }
;;;1347       mb->entry      = 0;
;;;1348       mb->in_offset  = 0;
;;;1349       mb->out_offset = 0;
;;;1350   
;;;1351       /* init an additional list of sender suspend thread */
;;;1352       rt_list_init(&(mb->suspend_sender_thread));
;;;1353   
;;;1354       return mb;
;;;1355   }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L16.70|
000046  7267              STRB     r7,[r4,#9]            ;1332
000048  4620              MOV      r0,r4                 ;1335
00004a  f7fffffe          BL       rt_ipc_object_init
00004e  8426              STRH     r6,[r4,#0x20]         ;1338
000050  8c21              LDRH     r1,[r4,#0x20]         ;1339
000052  0088              LSLS     r0,r1,#2              ;1339
000054  f7fffffe          BL       rt_malloc
000058  61e0              STR      r0,[r4,#0x1c]         ;1339
00005a  69e0              LDR      r0,[r4,#0x1c]         ;1340
00005c  b920              CBNZ     r0,|L16.104|
00005e  4620              MOV      r0,r4                 ;1343
000060  f7fffffe          BL       rt_object_delete
000064  2000              MOVS     r0,#0                 ;1345
000066  e7ec              B        |L16.66|
                  |L16.104|
000068  2000              MOVS     r0,#0                 ;1347
00006a  8460              STRH     r0,[r4,#0x22]         ;1347
00006c  84a0              STRH     r0,[r4,#0x24]         ;1348
00006e  84e0              STRH     r0,[r4,#0x26]         ;1349
000070  f1040028          ADD      r0,r4,#0x28           ;1352
000074  f7fffffe          BL       rt_list_init
000078  4620              MOV      r0,r4                 ;1354
00007a  e7e2              B        |L16.66|
;;;1356   RTM_EXPORT(rt_mb_create);
                          ENDP

                  |L16.124|
                          DCD      |symbol_number.150|
                  |L16.128|
000080  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000084  74696f6e
000088  5b25735d
00008c  20736861
000090  6c6c206e
000094  6f742075
000098  73656420
00009c  696e2049
0000a0  53520a00
                  |L16.164|
0000a4  3000              DCB      "0",0
0000a6  00                DCB      0
0000a7  00                DCB      0

                          AREA ||i.rt_mb_delete||, CODE, READONLY, ALIGN=2

                  rt_mb_delete PROC
;;;1364    */
;;;1365   rt_err_t rt_mb_delete(rt_mailbox_t mb)
000000  b570              PUSH     {r4-r6,lr}
;;;1366   {
000002  4604              MOV      r4,r0
;;;1367       RT_DEBUG_NOT_IN_INTERRUPT;
000004  bf00              NOP      
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  b148              CBZ      r0,|L17.38|
000012  4912              LDR      r1,|L17.92|
000014  a012              ADR      r0,|L17.96|
000016  f7fffffe          BL       rt_kprintf
00001a  f2405257          MOV      r2,#0x557
00001e  490f              LDR      r1,|L17.92|
000020  a018              ADR      r0,|L17.132|
000022  f7fffffe          BL       rt_assert_handler
                  |L17.38|
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       rt_hw_interrupt_enable
00002c  bf00              NOP      
;;;1368   
;;;1369       /* parameter check */
;;;1370       RT_ASSERT(mb != RT_NULL);
00002e  b92c              CBNZ     r4,|L17.60|
000030  f240525a          MOV      r2,#0x55a
000034  4909              LDR      r1,|L17.92|
000036  a014              ADR      r0,|L17.136|
000038  f7fffffe          BL       rt_assert_handler
                  |L17.60|
;;;1371   
;;;1372       /* resume all suspended thread */
;;;1373       rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
00003c  f1040014          ADD      r0,r4,#0x14
000040  f7fffffe          BL       rt_ipc_list_resume_all
;;;1374   
;;;1375       /* also resume all mailbox private suspended thread */
;;;1376       rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
000044  f1040028          ADD      r0,r4,#0x28
000048  f7fffffe          BL       rt_ipc_list_resume_all
;;;1377   
;;;1378   #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;1379       /* the mb object belongs to an application module */
;;;1380       if (mb->parent.parent.flag & RT_OBJECT_FLAG_MODULE)
;;;1381           rt_module_free(mb->parent.parent.module_id, mb->msg_pool);
;;;1382       else
;;;1383   #endif
;;;1384   
;;;1385       /* free mailbox pool */
;;;1386       RT_KERNEL_FREE(mb->msg_pool);
00004c  69e0              LDR      r0,[r4,#0x1c]
00004e  f7fffffe          BL       rt_free
;;;1387   
;;;1388       /* delete mailbox object */
;;;1389       rt_object_delete(&(mb->parent.parent));
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       rt_object_delete
;;;1390   
;;;1391       return RT_EOK;
000058  2000              MOVS     r0,#0
;;;1392   }
00005a  bd70              POP      {r4-r6,pc}
;;;1393   RTM_EXPORT(rt_mb_delete);
                          ENDP

                  |L17.92|
                          DCD      |symbol_number.151|
                  |L17.96|
000060  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000064  74696f6e
000068  5b25735d
00006c  20736861
000070  6c6c206e
000074  6f742075
000078  73656420
00007c  696e2049
000080  53520a00
                  |L17.132|
000084  3000              DCB      "0",0
000086  00                DCB      0
000087  00                DCB      0
                  |L17.136|
000088  6d622021          DCB      "mb != RT_NULL",0
00008c  3d205254
000090  5f4e554c
000094  4c00    
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.rt_mb_detach||, CODE, READONLY, ALIGN=2

                  rt_mb_detach PROC
;;;1292    */
;;;1293   rt_err_t rt_mb_detach(rt_mailbox_t mb)
000000  b510              PUSH     {r4,lr}
;;;1294   {
000002  4604              MOV      r4,r0
;;;1295       /* parameter check */
;;;1296       RT_ASSERT(mb != RT_NULL);
000004  b92c              CBNZ     r4,|L18.18|
000006  f44f62a2          MOV      r2,#0x510
00000a  4908              LDR      r1,|L18.44|
00000c  a008              ADR      r0,|L18.48|
00000e  f7fffffe          BL       rt_assert_handler
                  |L18.18|
;;;1297   
;;;1298       /* resume all suspended thread */
;;;1299       rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
000012  f1040014          ADD      r0,r4,#0x14
000016  f7fffffe          BL       rt_ipc_list_resume_all
;;;1300       /* also resume all mailbox private suspended thread */
;;;1301       rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
00001a  f1040028          ADD      r0,r4,#0x28
00001e  f7fffffe          BL       rt_ipc_list_resume_all
;;;1302   
;;;1303       /* detach mailbox object */
;;;1304       rt_object_detach(&(mb->parent.parent));
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_object_detach
;;;1305   
;;;1306       return RT_EOK;
000028  2000              MOVS     r0,#0
;;;1307   }
00002a  bd10              POP      {r4,pc}
;;;1308   RTM_EXPORT(rt_mb_detach);
                          ENDP

                  |L18.44|
                          DCD      |symbol_number.149|
                  |L18.48|
000030  6d622021          DCB      "mb != RT_NULL",0
000034  3d205254
000038  5f4e554c
00003c  4c00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.rt_mb_init||, CODE, READONLY, ALIGN=2

                  rt_mb_init PROC
;;;1254    */
;;;1255   rt_err_t rt_mb_init(rt_mailbox_t mb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1256                       const char  *name,
;;;1257                       void        *msgpool,
;;;1258                       rt_size_t    size,
;;;1259                       rt_uint8_t   flag)
;;;1260   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1261       RT_ASSERT(mb != RT_NULL);
000010  b92c              CBNZ     r4,|L19.30|
000012  f24042ed          MOV      r2,#0x4ed
000016  490d              LDR      r1,|L19.76|
000018  a00d              ADR      r0,|L19.80|
00001a  f7fffffe          BL       rt_assert_handler
                  |L19.30|
;;;1262   
;;;1263       /* init object */
;;;1264       rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
00001e  462a              MOV      r2,r5
000020  2104              MOVS     r1,#4
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_object_init
;;;1265   
;;;1266       /* set parent flag */
;;;1267       mb->parent.parent.flag = flag;
000028  f8848009          STRB     r8,[r4,#9]
;;;1268   
;;;1269       /* init ipc object */
;;;1270       rt_ipc_object_init(&(mb->parent));
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       rt_ipc_object_init
;;;1271   
;;;1272       /* init mailbox */
;;;1273       mb->msg_pool   = msgpool;
000032  61e6              STR      r6,[r4,#0x1c]
;;;1274       mb->size       = size;
000034  8427              STRH     r7,[r4,#0x20]
;;;1275       mb->entry      = 0;
000036  2000              MOVS     r0,#0
000038  8460              STRH     r0,[r4,#0x22]
;;;1276       mb->in_offset  = 0;
00003a  84a0              STRH     r0,[r4,#0x24]
;;;1277       mb->out_offset = 0;
00003c  84e0              STRH     r0,[r4,#0x26]
;;;1278   
;;;1279       /* init an additional list of sender suspend thread */
;;;1280       rt_list_init(&(mb->suspend_sender_thread));
00003e  f1040028          ADD      r0,r4,#0x28
000042  f7fffffe          BL       rt_list_init
;;;1281   
;;;1282       return RT_EOK;
000046  2000              MOVS     r0,#0
;;;1283   }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;1284   RTM_EXPORT(rt_mb_init);
                          ENDP

                  |L19.76|
                          DCD      |symbol_number.148|
                  |L19.80|
000050  6d622021          DCB      "mb != RT_NULL",0
000054  3d205254
000058  5f4e554c
00005c  4c00    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.rt_mb_recv||, CODE, READONLY, ALIGN=2

                  rt_mb_recv PROC
;;;1552    */
;;;1553   rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1554   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1555       struct rt_thread *thread;
;;;1556       register rt_ubase_t temp;
;;;1557       rt_uint32_t tick_delta;
;;;1558   
;;;1559       /* parameter check */
;;;1560       RT_ASSERT(mb != RT_NULL);
000008  b92c              CBNZ     r4,|L20.22|
00000a  f44f62c3          MOV      r2,#0x618
00000e  4961              LDR      r1,|L20.404|
000010  a061              ADR      r0,|L20.408|
000012  f7fffffe          BL       rt_assert_handler
                  |L20.22|
;;;1561   
;;;1562       /* initialize delta tick */
;;;1563       tick_delta = 0;
000016  2600              MOVS     r6,#0
;;;1564       /* get current thread */
;;;1565       thread = rt_thread_self();
000018  f7fffffe          BL       rt_thread_self
00001c  4605              MOV      r5,r0
;;;1566   
;;;1567       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
00001e  bf00              NOP      
000020  4861              LDR      r0,|L20.424|
000022  6800              LDR      r0,[r0,#0]  ; rt_object_trytake_hook
000024  b118              CBZ      r0,|L20.46|
000026  4620              MOV      r0,r4
000028  495f              LDR      r1,|L20.424|
00002a  6809              LDR      r1,[r1,#0]  ; rt_object_trytake_hook
00002c  4788              BLX      r1
                  |L20.46|
00002e  bf00              NOP      
;;;1568   
;;;1569       /* disable interrupt */
;;;1570       temp = rt_hw_interrupt_disable();
000030  f7fffffe          BL       rt_hw_interrupt_disable
000034  4680              MOV      r8,r0
;;;1571   
;;;1572       /* for non-blocking call */
;;;1573       if (mb->entry == 0 && timeout == 0)
000036  8c60              LDRH     r0,[r4,#0x22]
000038  b940              CBNZ     r0,|L20.76|
00003a  9802              LDR      r0,[sp,#8]
00003c  b930              CBNZ     r0,|L20.76|
;;;1574       {
;;;1575           rt_hw_interrupt_enable(temp);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       rt_hw_interrupt_enable
;;;1576   
;;;1577           return -RT_ETIMEOUT;
000044  f06f0001          MVN      r0,#1
                  |L20.72|
;;;1578       }
;;;1579   
;;;1580       /* mailbox is empty */
;;;1581       while (mb->entry == 0)
;;;1582       {
;;;1583           /* reset error number in thread */
;;;1584           thread->error = RT_EOK;
;;;1585   
;;;1586           /* no waiting, return timeout */
;;;1587           if (timeout == 0)
;;;1588           {
;;;1589               /* enable interrupt */
;;;1590               rt_hw_interrupt_enable(temp);
;;;1591   
;;;1592               thread->error = -RT_ETIMEOUT;
;;;1593   
;;;1594               return -RT_ETIMEOUT;
;;;1595           }
;;;1596   
;;;1597           RT_DEBUG_IN_THREAD_CONTEXT;
;;;1598           /* suspend current thread */
;;;1599           rt_ipc_list_suspend(&(mb->parent.suspend_thread),
;;;1600                               thread,
;;;1601                               mb->parent.parent.flag);
;;;1602   
;;;1603           /* has waiting time, start thread timer */
;;;1604           if (timeout > 0)
;;;1605           {
;;;1606               /* get the start tick of timer */
;;;1607               tick_delta = rt_tick_get();
;;;1608   
;;;1609               RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
;;;1610                                           thread->name));
;;;1611   
;;;1612               /* reset the timeout of thread timer and start it */
;;;1613               rt_timer_control(&(thread->thread_timer),
;;;1614                                RT_TIMER_CTRL_SET_TIME,
;;;1615                                &timeout);
;;;1616               rt_timer_start(&(thread->thread_timer));
;;;1617           }
;;;1618   
;;;1619           /* enable interrupt */
;;;1620           rt_hw_interrupt_enable(temp);
;;;1621   
;;;1622           /* re-schedule */
;;;1623           rt_schedule();
;;;1624   
;;;1625           /* resume from suspend state */
;;;1626           if (thread->error != RT_EOK)
;;;1627           {
;;;1628               /* return error */
;;;1629               return thread->error;
;;;1630           }
;;;1631   
;;;1632           /* disable interrupt */
;;;1633           temp = rt_hw_interrupt_disable();
;;;1634   
;;;1635           /* if it's not waiting forever and then re-calculate timeout tick */
;;;1636           if (timeout > 0)
;;;1637           {
;;;1638               tick_delta = rt_tick_get() - tick_delta;
;;;1639               timeout -= tick_delta;
;;;1640               if (timeout < 0)
;;;1641                   timeout = 0;
;;;1642           }
;;;1643       }
;;;1644   
;;;1645       /* fill ptr */
;;;1646       *value = mb->msg_pool[mb->out_offset];
;;;1647   
;;;1648       /* increase output offset */
;;;1649       ++ mb->out_offset;
;;;1650       if (mb->out_offset >= mb->size)
;;;1651           mb->out_offset = 0;
;;;1652       /* decrease message entry */
;;;1653       mb->entry --;
;;;1654   
;;;1655       /* resume suspended thread */
;;;1656       if (!rt_list_isempty(&(mb->suspend_sender_thread)))
;;;1657       {
;;;1658           rt_ipc_list_resume(&(mb->suspend_sender_thread));
;;;1659   
;;;1660           /* enable interrupt */
;;;1661           rt_hw_interrupt_enable(temp);
;;;1662   
;;;1663           RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
;;;1664   
;;;1665           rt_schedule();
;;;1666   
;;;1667           return RT_EOK;
;;;1668       }
;;;1669   
;;;1670       /* enable interrupt */
;;;1671       rt_hw_interrupt_enable(temp);
;;;1672   
;;;1673       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
;;;1674   
;;;1675       return RT_EOK;
;;;1676   }
000048  e8bd8ffe          POP      {r1-r11,pc}
                  |L20.76|
00004c  e066              B        |L20.284|
                  |L20.78|
00004e  2000              MOVS     r0,#0                 ;1584
000050  6328              STR      r0,[r5,#0x30]         ;1584
000052  9802              LDR      r0,[sp,#8]            ;1587
000054  b930              CBNZ     r0,|L20.100|
000056  4640              MOV      r0,r8                 ;1590
000058  f7fffffe          BL       rt_hw_interrupt_enable
00005c  f06f0001          MVN      r0,#1                 ;1592
000060  6328              STR      r0,[r5,#0x30]         ;1592
000062  e7f1              B        |L20.72|
                  |L20.100|
000064  bf00              NOP                            ;1597
000066  f7fffffe          BL       rt_hw_interrupt_disable
00006a  4681              MOV      r9,r0                 ;1597
00006c  f7fffffe          BL       rt_thread_self
000070  b948              CBNZ     r0,|L20.134|
000072  4948              LDR      r1,|L20.404|
000074  a04d              ADR      r0,|L20.428|
000076  f7fffffe          BL       rt_kprintf
00007a  f240623d          MOV      r2,#0x63d             ;1597
00007e  4945              LDR      r1,|L20.404|
000080  a058              ADR      r0,|L20.484|
000082  f7fffffe          BL       rt_assert_handler
                  |L20.134|
000086  bf00              NOP                            ;1597
000088  f7fffffe          BL       rt_hw_interrupt_disable
00008c  4682              MOV      r10,r0                ;1597
00008e  f7fffffe          BL       rt_interrupt_get_nest
000092  b148              CBZ      r0,|L20.168|
000094  493f              LDR      r1,|L20.404|
000096  a054              ADR      r0,|L20.488|
000098  f7fffffe          BL       rt_kprintf
00009c  f240623d          MOV      r2,#0x63d             ;1597
0000a0  493c              LDR      r1,|L20.404|
0000a2  a050              ADR      r0,|L20.484|
0000a4  f7fffffe          BL       rt_assert_handler
                  |L20.168|
0000a8  4650              MOV      r0,r10                ;1597
0000aa  f7fffffe          BL       rt_hw_interrupt_enable
0000ae  bf00              NOP                            ;1597
0000b0  4648              MOV      r0,r9                 ;1597
0000b2  f7fffffe          BL       rt_hw_interrupt_enable
0000b6  bf00              NOP                            ;1597
0000b8  7a62              LDRB     r2,[r4,#9]            ;1599
0000ba  4629              MOV      r1,r5                 ;1599
0000bc  f1040014          ADD      r0,r4,#0x14           ;1599
0000c0  f7fffffe          BL       rt_ipc_list_suspend
0000c4  9802              LDR      r0,[sp,#8]            ;1604
0000c6  2800              CMP      r0,#0                 ;1604
0000c8  dd0e              BLE      |L20.232|
0000ca  f7fffffe          BL       rt_tick_get
0000ce  4606              MOV      r6,r0                 ;1607
0000d0  bf00              NOP                            ;1609
0000d2  bf00              NOP                            ;1609
0000d4  aa02              ADD      r2,sp,#8              ;1613
0000d6  2100              MOVS     r1,#0                 ;1613
0000d8  f105004c          ADD      r0,r5,#0x4c           ;1613
0000dc  f7fffffe          BL       rt_timer_control
0000e0  f105004c          ADD      r0,r5,#0x4c           ;1616
0000e4  f7fffffe          BL       rt_timer_start
                  |L20.232|
0000e8  4640              MOV      r0,r8                 ;1620
0000ea  f7fffffe          BL       rt_hw_interrupt_enable
0000ee  f7fffffe          BL       rt_schedule
0000f2  6b28              LDR      r0,[r5,#0x30]         ;1626
0000f4  b108              CBZ      r0,|L20.250|
0000f6  6b28              LDR      r0,[r5,#0x30]         ;1629
0000f8  e7a6              B        |L20.72|
                  |L20.250|
0000fa  f7fffffe          BL       rt_hw_interrupt_disable
0000fe  4680              MOV      r8,r0                 ;1633
000100  9802              LDR      r0,[sp,#8]            ;1636
000102  2800              CMP      r0,#0                 ;1636
000104  dd0a              BLE      |L20.284|
000106  f7fffffe          BL       rt_tick_get
00010a  1b86              SUBS     r6,r0,r6              ;1638
00010c  9802              LDR      r0,[sp,#8]            ;1639
00010e  1b80              SUBS     r0,r0,r6              ;1639
000110  9002              STR      r0,[sp,#8]            ;1639
000112  9802              LDR      r0,[sp,#8]            ;1640
000114  2800              CMP      r0,#0                 ;1640
000116  da01              BGE      |L20.284|
000118  2000              MOVS     r0,#0                 ;1641
00011a  9002              STR      r0,[sp,#8]            ;1641
                  |L20.284|
00011c  8c60              LDRH     r0,[r4,#0x22]         ;1581
00011e  2800              CMP      r0,#0                 ;1581
000120  d095              BEQ      |L20.78|
000122  8ce1              LDRH     r1,[r4,#0x26]         ;1646
000124  69e0              LDR      r0,[r4,#0x1c]         ;1646
000126  f8500021          LDR      r0,[r0,r1,LSL #2]     ;1646
00012a  6038              STR      r0,[r7,#0]            ;1646
00012c  8ce0              LDRH     r0,[r4,#0x26]         ;1649
00012e  1c40              ADDS     r0,r0,#1              ;1649
000130  84e0              STRH     r0,[r4,#0x26]         ;1649
000132  8ce0              LDRH     r0,[r4,#0x26]         ;1650
000134  8c21              LDRH     r1,[r4,#0x20]         ;1650
000136  4288              CMP      r0,r1                 ;1650
000138  db01              BLT      |L20.318|
00013a  2000              MOVS     r0,#0                 ;1651
00013c  84e0              STRH     r0,[r4,#0x26]         ;1651
                  |L20.318|
00013e  8c60              LDRH     r0,[r4,#0x22]         ;1653
000140  1e40              SUBS     r0,r0,#1              ;1653
000142  8460              STRH     r0,[r4,#0x22]         ;1653
000144  f1040028          ADD      r0,r4,#0x28           ;1656
000148  f7fffffe          BL       rt_list_isempty
00014c  b998              CBNZ     r0,|L20.374|
00014e  f1040028          ADD      r0,r4,#0x28           ;1658
000152  f7fffffe          BL       rt_ipc_list_resume
000156  4640              MOV      r0,r8                 ;1661
000158  f7fffffe          BL       rt_hw_interrupt_enable
00015c  bf00              NOP                            ;1663
00015e  482b              LDR      r0,|L20.524|
000160  6800              LDR      r0,[r0,#0]            ;1663  ; rt_object_take_hook
000162  b118              CBZ      r0,|L20.364|
000164  4620              MOV      r0,r4                 ;1663
000166  4929              LDR      r1,|L20.524|
000168  6809              LDR      r1,[r1,#0]            ;1663  ; rt_object_take_hook
00016a  4788              BLX      r1                    ;1663
                  |L20.364|
00016c  bf00              NOP                            ;1663
00016e  f7fffffe          BL       rt_schedule
000172  2000              MOVS     r0,#0                 ;1667
000174  e768              B        |L20.72|
                  |L20.374|
000176  4640              MOV      r0,r8                 ;1671
000178  f7fffffe          BL       rt_hw_interrupt_enable
00017c  bf00              NOP                            ;1673
00017e  4823              LDR      r0,|L20.524|
000180  6800              LDR      r0,[r0,#0]            ;1673  ; rt_object_take_hook
000182  b118              CBZ      r0,|L20.396|
000184  4620              MOV      r0,r4                 ;1673
000186  4921              LDR      r1,|L20.524|
000188  6809              LDR      r1,[r1,#0]            ;1673  ; rt_object_take_hook
00018a  4788              BLX      r1                    ;1673
                  |L20.396|
00018c  bf00              NOP                            ;1673
00018e  2000              MOVS     r0,#0                 ;1675
000190  e75a              B        |L20.72|
;;;1677   RTM_EXPORT(rt_mb_recv);
                          ENDP

000192  0000              DCW      0x0000
                  |L20.404|
                          DCD      |symbol_number.153|
                  |L20.408|
000198  6d622021          DCB      "mb != RT_NULL",0
00019c  3d205254
0001a0  5f4e554c
0001a4  4c00    
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L20.424|
                          DCD      rt_object_trytake_hook
                  |L20.428|
0001ac  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
0001b0  74696f6e
0001b4  5b25735d
0001b8  20736861
0001bc  6c6c206e
0001c0  6f742062
0001c4  65207573
0001c8  65642062
0001cc  65666f72
0001d0  65207363
0001d4  68656475
0001d8  6c657220
0001dc  73746172
0001e0  740a    
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L20.484|
0001e4  3000              DCB      "0",0
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L20.488|
0001e8  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0001ec  74696f6e
0001f0  5b25735d
0001f4  20736861
0001f8  6c6c206e
0001fc  6f742075
000200  73656420
000204  696e2049
000208  53520a00
                  |L20.524|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_mb_send||, CODE, READONLY, ALIGN=1

                  rt_mb_send PROC
;;;1536    */
;;;1537   rt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value)
000000  b570              PUSH     {r4-r6,lr}
;;;1538   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1539       return rt_mb_send_wait(mb, value, 0);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_mb_send_wait
;;;1540   }
000010  bd70              POP      {r4-r6,pc}
;;;1541   RTM_EXPORT(rt_mb_send);
                          ENDP


                          AREA ||i.rt_mb_send_wait||, CODE, READONLY, ALIGN=2

                  rt_mb_send_wait PROC
;;;1405    */
;;;1406   rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1407                            rt_uint32_t  value,
;;;1408                            rt_int32_t   timeout)
;;;1409   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1410       struct rt_thread *thread;
;;;1411       register rt_ubase_t temp;
;;;1412       rt_uint32_t tick_delta;
;;;1413   
;;;1414       /* parameter check */
;;;1415       RT_ASSERT(mb != RT_NULL);
000008  b92c              CBNZ     r4,|L22.22|
00000a  f2405287          MOV      r2,#0x587
00000e  4958              LDR      r1,|L22.368|
000010  a058              ADR      r0,|L22.372|
000012  f7fffffe          BL       rt_assert_handler
                  |L22.22|
;;;1416   
;;;1417       /* initialize delta tick */
;;;1418       tick_delta = 0;
000016  2600              MOVS     r6,#0
;;;1419       /* get current thread */
;;;1420       thread = rt_thread_self();
000018  f7fffffe          BL       rt_thread_self
00001c  4605              MOV      r5,r0
;;;1421   
;;;1422       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
00001e  bf00              NOP      
000020  4858              LDR      r0,|L22.388|
000022  6800              LDR      r0,[r0,#0]  ; rt_object_put_hook
000024  b118              CBZ      r0,|L22.46|
000026  4620              MOV      r0,r4
000028  4956              LDR      r1,|L22.388|
00002a  6809              LDR      r1,[r1,#0]  ; rt_object_put_hook
00002c  4788              BLX      r1
                  |L22.46|
00002e  bf00              NOP      
;;;1423   
;;;1424       /* disable interrupt */
;;;1425       temp = rt_hw_interrupt_disable();
000030  f7fffffe          BL       rt_hw_interrupt_disable
000034  4680              MOV      r8,r0
;;;1426   
;;;1427       /* for non-blocking call */
;;;1428       if (mb->entry == mb->size && timeout == 0)
000036  8c60              LDRH     r0,[r4,#0x22]
000038  8c21              LDRH     r1,[r4,#0x20]
00003a  4288              CMP      r0,r1
00003c  d108              BNE      |L22.80|
00003e  9802              LDR      r0,[sp,#8]
000040  b930              CBNZ     r0,|L22.80|
;;;1429       {
;;;1430           rt_hw_interrupt_enable(temp);
000042  4640              MOV      r0,r8
000044  f7fffffe          BL       rt_hw_interrupt_enable
;;;1431   
;;;1432           return -RT_EFULL;
000048  f06f0002          MVN      r0,#2
                  |L22.76|
;;;1433       }
;;;1434   
;;;1435       /* mailbox is full */
;;;1436       while (mb->entry == mb->size)
;;;1437       {
;;;1438           /* reset error number in thread */
;;;1439           thread->error = RT_EOK;
;;;1440   
;;;1441           /* no waiting, return timeout */
;;;1442           if (timeout == 0)
;;;1443           {
;;;1444               /* enable interrupt */
;;;1445               rt_hw_interrupt_enable(temp);
;;;1446   
;;;1447               return -RT_EFULL;
;;;1448           }
;;;1449   
;;;1450           RT_DEBUG_IN_THREAD_CONTEXT;
;;;1451           /* suspend current thread */
;;;1452           rt_ipc_list_suspend(&(mb->suspend_sender_thread),
;;;1453                               thread,
;;;1454                               mb->parent.parent.flag);
;;;1455   
;;;1456           /* has waiting time, start thread timer */
;;;1457           if (timeout > 0)
;;;1458           {
;;;1459               /* get the start tick of timer */
;;;1460               tick_delta = rt_tick_get();
;;;1461   
;;;1462               RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
;;;1463                                           thread->name));
;;;1464   
;;;1465               /* reset the timeout of thread timer and start it */
;;;1466               rt_timer_control(&(thread->thread_timer),
;;;1467                                RT_TIMER_CTRL_SET_TIME,
;;;1468                                &timeout);
;;;1469               rt_timer_start(&(thread->thread_timer));
;;;1470           }
;;;1471   
;;;1472           /* enable interrupt */
;;;1473           rt_hw_interrupt_enable(temp);
;;;1474   
;;;1475           /* re-schedule */
;;;1476           rt_schedule();
;;;1477   
;;;1478           /* resume from suspend state */
;;;1479           if (thread->error != RT_EOK)
;;;1480           {
;;;1481               /* return error */
;;;1482               return thread->error;
;;;1483           }
;;;1484   
;;;1485           /* disable interrupt */
;;;1486           temp = rt_hw_interrupt_disable();
;;;1487   
;;;1488           /* if it's not waiting forever and then re-calculate timeout tick */
;;;1489           if (timeout > 0)
;;;1490           {
;;;1491               tick_delta = rt_tick_get() - tick_delta;
;;;1492               timeout -= tick_delta;
;;;1493               if (timeout < 0)
;;;1494                   timeout = 0;
;;;1495           }
;;;1496       }
;;;1497   
;;;1498       /* set ptr */
;;;1499       mb->msg_pool[mb->in_offset] = value;
;;;1500       /* increase input offset */
;;;1501       ++ mb->in_offset;
;;;1502       if (mb->in_offset >= mb->size)
;;;1503           mb->in_offset = 0;
;;;1504       /* increase message entry */
;;;1505       mb->entry ++;
;;;1506   
;;;1507       /* resume suspended thread */
;;;1508       if (!rt_list_isempty(&mb->parent.suspend_thread))
;;;1509       {
;;;1510           rt_ipc_list_resume(&(mb->parent.suspend_thread));
;;;1511   
;;;1512           /* enable interrupt */
;;;1513           rt_hw_interrupt_enable(temp);
;;;1514   
;;;1515           rt_schedule();
;;;1516   
;;;1517           return RT_EOK;
;;;1518       }
;;;1519   
;;;1520       /* enable interrupt */
;;;1521       rt_hw_interrupt_enable(temp);
;;;1522   
;;;1523       return RT_EOK;
;;;1524   }
00004c  e8bd8ffe          POP      {r1-r11,pc}
                  |L22.80|
000050  e065              B        |L22.286|
                  |L22.82|
000052  2000              MOVS     r0,#0                 ;1439
000054  6328              STR      r0,[r5,#0x30]         ;1439
000056  9802              LDR      r0,[sp,#8]            ;1442
000058  b928              CBNZ     r0,|L22.102|
00005a  4640              MOV      r0,r8                 ;1445
00005c  f7fffffe          BL       rt_hw_interrupt_enable
000060  f06f0002          MVN      r0,#2                 ;1447
000064  e7f2              B        |L22.76|
                  |L22.102|
000066  bf00              NOP                            ;1450
000068  f7fffffe          BL       rt_hw_interrupt_disable
00006c  4681              MOV      r9,r0                 ;1450
00006e  f7fffffe          BL       rt_thread_self
000072  b948              CBNZ     r0,|L22.136|
000074  493e              LDR      r1,|L22.368|
000076  a044              ADR      r0,|L22.392|
000078  f7fffffe          BL       rt_kprintf
00007c  f24052aa          MOV      r2,#0x5aa             ;1450
000080  493b              LDR      r1,|L22.368|
000082  a04f              ADR      r0,|L22.448|
000084  f7fffffe          BL       rt_assert_handler
                  |L22.136|
000088  bf00              NOP                            ;1450
00008a  f7fffffe          BL       rt_hw_interrupt_disable
00008e  4682              MOV      r10,r0                ;1450
000090  f7fffffe          BL       rt_interrupt_get_nest
000094  b148              CBZ      r0,|L22.170|
000096  4936              LDR      r1,|L22.368|
000098  a04a              ADR      r0,|L22.452|
00009a  f7fffffe          BL       rt_kprintf
00009e  f24052aa          MOV      r2,#0x5aa             ;1450
0000a2  4933              LDR      r1,|L22.368|
0000a4  a046              ADR      r0,|L22.448|
0000a6  f7fffffe          BL       rt_assert_handler
                  |L22.170|
0000aa  4650              MOV      r0,r10                ;1450
0000ac  f7fffffe          BL       rt_hw_interrupt_enable
0000b0  bf00              NOP                            ;1450
0000b2  4648              MOV      r0,r9                 ;1450
0000b4  f7fffffe          BL       rt_hw_interrupt_enable
0000b8  bf00              NOP                            ;1450
0000ba  7a62              LDRB     r2,[r4,#9]            ;1452
0000bc  4629              MOV      r1,r5                 ;1452
0000be  f1040028          ADD      r0,r4,#0x28           ;1452
0000c2  f7fffffe          BL       rt_ipc_list_suspend
0000c6  9802              LDR      r0,[sp,#8]            ;1457
0000c8  2800              CMP      r0,#0                 ;1457
0000ca  dd0e              BLE      |L22.234|
0000cc  f7fffffe          BL       rt_tick_get
0000d0  4606              MOV      r6,r0                 ;1460
0000d2  bf00              NOP                            ;1462
0000d4  bf00              NOP                            ;1462
0000d6  aa02              ADD      r2,sp,#8              ;1466
0000d8  2100              MOVS     r1,#0                 ;1466
0000da  f105004c          ADD      r0,r5,#0x4c           ;1466
0000de  f7fffffe          BL       rt_timer_control
0000e2  f105004c          ADD      r0,r5,#0x4c           ;1469
0000e6  f7fffffe          BL       rt_timer_start
                  |L22.234|
0000ea  4640              MOV      r0,r8                 ;1473
0000ec  f7fffffe          BL       rt_hw_interrupt_enable
0000f0  f7fffffe          BL       rt_schedule
0000f4  6b28              LDR      r0,[r5,#0x30]         ;1479
0000f6  b108              CBZ      r0,|L22.252|
0000f8  6b28              LDR      r0,[r5,#0x30]         ;1482
0000fa  e7a7              B        |L22.76|
                  |L22.252|
0000fc  f7fffffe          BL       rt_hw_interrupt_disable
000100  4680              MOV      r8,r0                 ;1486
000102  9802              LDR      r0,[sp,#8]            ;1489
000104  2800              CMP      r0,#0                 ;1489
000106  dd0a              BLE      |L22.286|
000108  f7fffffe          BL       rt_tick_get
00010c  1b86              SUBS     r6,r0,r6              ;1491
00010e  9802              LDR      r0,[sp,#8]            ;1492
000110  1b80              SUBS     r0,r0,r6              ;1492
000112  9002              STR      r0,[sp,#8]            ;1492
000114  9802              LDR      r0,[sp,#8]            ;1493
000116  2800              CMP      r0,#0                 ;1493
000118  da01              BGE      |L22.286|
00011a  2000              MOVS     r0,#0                 ;1494
00011c  9002              STR      r0,[sp,#8]            ;1494
                  |L22.286|
00011e  8c60              LDRH     r0,[r4,#0x22]         ;1436
000120  8c21              LDRH     r1,[r4,#0x20]         ;1436
000122  4288              CMP      r0,r1                 ;1436
000124  d095              BEQ      |L22.82|
000126  8ca1              LDRH     r1,[r4,#0x24]         ;1499
000128  69e0              LDR      r0,[r4,#0x1c]         ;1499
00012a  f8407021          STR      r7,[r0,r1,LSL #2]     ;1499
00012e  8ca0              LDRH     r0,[r4,#0x24]         ;1501
000130  1c40              ADDS     r0,r0,#1              ;1501
000132  84a0              STRH     r0,[r4,#0x24]         ;1501
000134  8ca0              LDRH     r0,[r4,#0x24]         ;1502
000136  8c21              LDRH     r1,[r4,#0x20]         ;1502
000138  4288              CMP      r0,r1                 ;1502
00013a  db01              BLT      |L22.320|
00013c  2000              MOVS     r0,#0                 ;1503
00013e  84a0              STRH     r0,[r4,#0x24]         ;1503
                  |L22.320|
000140  8c60              LDRH     r0,[r4,#0x22]         ;1505
000142  1c40              ADDS     r0,r0,#1              ;1505
000144  8460              STRH     r0,[r4,#0x22]         ;1505
000146  f1040014          ADD      r0,r4,#0x14           ;1508
00014a  f7fffffe          BL       rt_list_isempty
00014e  b950              CBNZ     r0,|L22.358|
000150  f1040014          ADD      r0,r4,#0x14           ;1510
000154  f7fffffe          BL       rt_ipc_list_resume
000158  4640              MOV      r0,r8                 ;1513
00015a  f7fffffe          BL       rt_hw_interrupt_enable
00015e  f7fffffe          BL       rt_schedule
000162  2000              MOVS     r0,#0                 ;1517
000164  e772              B        |L22.76|
                  |L22.358|
000166  4640              MOV      r0,r8                 ;1521
000168  f7fffffe          BL       rt_hw_interrupt_enable
00016c  2000              MOVS     r0,#0                 ;1523
00016e  e76d              B        |L22.76|
;;;1525   RTM_EXPORT(rt_mb_send_wait);
                          ENDP

                  |L22.368|
                          DCD      |symbol_number.152|
                  |L22.372|
000174  6d622021          DCB      "mb != RT_NULL",0
000178  3d205254
00017c  5f4e554c
000180  4c00    
000182  00                DCB      0
000183  00                DCB      0
                  |L22.388|
                          DCD      rt_object_put_hook
                  |L22.392|
000188  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
00018c  74696f6e
000190  5b25735d
000194  20736861
000198  6c6c206e
00019c  6f742062
0001a0  65207573
0001a4  65642062
0001a8  65666f72
0001ac  65207363
0001b0  68656475
0001b4  6c657220
0001b8  73746172
0001bc  740a    
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L22.448|
0001c0  3000              DCB      "0",0
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L22.452|
0001c4  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0001c8  74696f6e
0001cc  5b25735d
0001d0  20736861
0001d4  6c6c206e
0001d8  6f742075
0001dc  73656420
0001e0  696e2049
0001e4  53520a00

                          AREA ||i.rt_mq_control||, CODE, READONLY, ALIGN=2

                  rt_mq_control PROC
;;;2235    */
;;;2236   rt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2237   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;2238       rt_ubase_t level;
;;;2239       struct rt_mq_message *msg;
;;;2240   
;;;2241       RT_ASSERT(mq != RT_NULL);
00000a  b92c              CBNZ     r4,|L23.24|
00000c  f64002c1          MOV      r2,#0x8c1
000010  4913              LDR      r1,|L23.96|
000012  a014              ADR      r0,|L23.100|
000014  f7fffffe          BL       rt_assert_handler
                  |L23.24|
;;;2242   
;;;2243       if (cmd == RT_IPC_CMD_RESET)
000018  2e01              CMP      r6,#1
00001a  d11e              BNE      |L23.90|
;;;2244       {
;;;2245           /* disable interrupt */
;;;2246           level = rt_hw_interrupt_disable();
00001c  f7fffffe          BL       rt_hw_interrupt_disable
000020  4607              MOV      r7,r0
;;;2247   
;;;2248           /* resume all waiting thread */
;;;2249           rt_ipc_list_resume_all(&mq->parent.suspend_thread);
000022  f1040014          ADD      r0,r4,#0x14
000026  f7fffffe          BL       rt_ipc_list_resume_all
;;;2250   
;;;2251           /* release all message in the queue */
;;;2252           while (mq->msg_queue_head != RT_NULL)
00002a  e00a              B        |L23.66|
                  |L23.44|
;;;2253           {
;;;2254               /* get message from queue */
;;;2255               msg = (struct rt_mq_message *)mq->msg_queue_head;
00002c  6aa5              LDR      r5,[r4,#0x28]
;;;2256   
;;;2257               /* move message queue head */
;;;2258               mq->msg_queue_head = msg->next;
00002e  6828              LDR      r0,[r5,#0]
000030  62a0              STR      r0,[r4,#0x28]
;;;2259               /* reach queue tail, set to NULL */
;;;2260               if (mq->msg_queue_tail == msg)
000032  6ae0              LDR      r0,[r4,#0x2c]
000034  42a8              CMP      r0,r5
000036  d101              BNE      |L23.60|
;;;2261                   mq->msg_queue_tail = RT_NULL;
000038  2000              MOVS     r0,#0
00003a  62e0              STR      r0,[r4,#0x2c]
                  |L23.60|
;;;2262   
;;;2263               /* put message to free list */
;;;2264               msg->next = (struct rt_mq_message *)mq->msg_queue_free;
00003c  6b20              LDR      r0,[r4,#0x30]
00003e  6028              STR      r0,[r5,#0]
;;;2265               mq->msg_queue_free = msg;
000040  6325              STR      r5,[r4,#0x30]
                  |L23.66|
000042  6aa0              LDR      r0,[r4,#0x28]         ;2252
000044  2800              CMP      r0,#0                 ;2252
000046  d1f1              BNE      |L23.44|
;;;2266           }
;;;2267   
;;;2268           /* clean entry */
;;;2269           mq->entry = 0;
000048  84a0              STRH     r0,[r4,#0x24]
;;;2270   
;;;2271           /* enable interrupt */
;;;2272           rt_hw_interrupt_enable(level);
00004a  4638              MOV      r0,r7
00004c  f7fffffe          BL       rt_hw_interrupt_enable
;;;2273   
;;;2274           rt_schedule();
000050  f7fffffe          BL       rt_schedule
;;;2275   
;;;2276           return RT_EOK;
000054  2000              MOVS     r0,#0
                  |L23.86|
;;;2277       }
;;;2278   
;;;2279       return -RT_ERROR;
;;;2280   }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L23.90|
00005a  f04f30ff          MOV      r0,#0xffffffff        ;2279
00005e  e7fa              B        |L23.86|
;;;2281   RTM_EXPORT(rt_mq_control);
                          ENDP

                  |L23.96|
                          DCD      |symbol_number.162|
                  |L23.100|
000064  6d712021          DCB      "mq != RT_NULL",0
000068  3d205254
00006c  5f4e554c
000070  4c00    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.rt_mq_create||, CODE, READONLY, ALIGN=2

                  rt_mq_create PROC
;;;1822    */
;;;1823   rt_mq_t rt_mq_create(const char *name,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1824                        rt_size_t   msg_size,
;;;1825                        rt_size_t   max_msgs,
;;;1826                        rt_uint8_t  flag)
;;;1827   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
;;;1828       struct rt_messagequeue *mq;
;;;1829       struct rt_mq_message *head;
;;;1830       register rt_base_t temp;
;;;1831   
;;;1832       RT_DEBUG_NOT_IN_INTERRUPT;
00000c  bf00              NOP      
00000e  f7fffffe          BL       rt_hw_interrupt_disable
000012  4683              MOV      r11,r0
000014  f7fffffe          BL       rt_interrupt_get_nest
000018  b148              CBZ      r0,|L24.46|
00001a  4924              LDR      r1,|L24.172|
00001c  a024              ADR      r0,|L24.176|
00001e  f7fffffe          BL       rt_kprintf
000022  f44f62e5          MOV      r2,#0x728
000026  4921              LDR      r1,|L24.172|
000028  a02a              ADR      r0,|L24.212|
00002a  f7fffffe          BL       rt_assert_handler
                  |L24.46|
00002e  4658              MOV      r0,r11
000030  f7fffffe          BL       rt_hw_interrupt_enable
000034  bf00              NOP      
;;;1833   
;;;1834       /* allocate object */
;;;1835       mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
000036  4639              MOV      r1,r7
000038  2005              MOVS     r0,#5
00003a  f7fffffe          BL       rt_object_allocate
00003e  4604              MOV      r4,r0
;;;1836       if (mq == RT_NULL)
000040  b914              CBNZ     r4,|L24.72|
;;;1837           return mq;
000042  4620              MOV      r0,r4
                  |L24.68|
;;;1838   
;;;1839       /* set parent */
;;;1840       mq->parent.parent.flag = flag;
;;;1841   
;;;1842       /* init ipc object */
;;;1843       rt_ipc_object_init(&(mq->parent));
;;;1844   
;;;1845       /* init message queue */
;;;1846   
;;;1847       /* get correct message size */
;;;1848       mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
;;;1849       mq->max_msgs = max_msgs;
;;;1850   
;;;1851       /* allocate message pool */
;;;1852       mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message))* mq->max_msgs);
;;;1853       if (mq->msg_pool == RT_NULL)
;;;1854       {
;;;1855           rt_mq_delete(mq);
;;;1856   
;;;1857           return RT_NULL;
;;;1858       }
;;;1859   
;;;1860       /* init message list */
;;;1861       mq->msg_queue_head = RT_NULL;
;;;1862       mq->msg_queue_tail = RT_NULL;
;;;1863   
;;;1864       /* init message empty list */
;;;1865       mq->msg_queue_free = RT_NULL;
;;;1866       for (temp = 0; temp < mq->max_msgs; temp ++)
;;;1867       {
;;;1868           head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
;;;1869                  temp * (mq->msg_size + sizeof(struct rt_mq_message)));
;;;1870           head->next = mq->msg_queue_free;
;;;1871           mq->msg_queue_free = head;
;;;1872       }
;;;1873   
;;;1874       /* the initial entry is zero */
;;;1875       mq->entry = 0;
;;;1876   
;;;1877       return mq;
;;;1878   }
000044  e8bd9ff0          POP      {r4-r12,pc}
                  |L24.72|
000048  f884a009          STRB     r10,[r4,#9]           ;1840
00004c  4620              MOV      r0,r4                 ;1843
00004e  f7fffffe          BL       rt_ipc_object_init
000052  f1080003          ADD      r0,r8,#3              ;1848
000056  f0200003          BIC      r0,r0,#3              ;1848
00005a  8420              STRH     r0,[r4,#0x20]         ;1848
00005c  f8a49022          STRH     r9,[r4,#0x22]         ;1849
000060  8c21              LDRH     r1,[r4,#0x20]         ;1852
000062  1d09              ADDS     r1,r1,#4              ;1852
000064  8c62              LDRH     r2,[r4,#0x22]         ;1852
000066  fb01f002          MUL      r0,r1,r2              ;1852
00006a  f7fffffe          BL       rt_malloc
00006e  61e0              STR      r0,[r4,#0x1c]         ;1852
000070  69e0              LDR      r0,[r4,#0x1c]         ;1853
000072  b920              CBNZ     r0,|L24.126|
000074  4620              MOV      r0,r4                 ;1855
000076  f7fffffe          BL       rt_mq_delete
00007a  2000              MOVS     r0,#0                 ;1857
00007c  e7e2              B        |L24.68|
                  |L24.126|
00007e  2000              MOVS     r0,#0                 ;1861
000080  62a0              STR      r0,[r4,#0x28]         ;1861
000082  62e0              STR      r0,[r4,#0x2c]         ;1862
000084  6320              STR      r0,[r4,#0x30]         ;1865
000086  2500              MOVS     r5,#0                 ;1866
000088  e008              B        |L24.156|
                  |L24.138|
00008a  8c20              LDRH     r0,[r4,#0x20]         ;1868
00008c  1d00              ADDS     r0,r0,#4              ;1868
00008e  69e1              LDR      r1,[r4,#0x1c]         ;1868
000090  fb051600          MLA      r6,r5,r0,r1           ;1868
000094  6b20              LDR      r0,[r4,#0x30]         ;1870
000096  6030              STR      r0,[r6,#0]            ;1870
000098  6326              STR      r6,[r4,#0x30]         ;1871
00009a  1c6d              ADDS     r5,r5,#1              ;1866
                  |L24.156|
00009c  8c60              LDRH     r0,[r4,#0x22]         ;1866
00009e  42a8              CMP      r0,r5                 ;1866
0000a0  dcf3              BGT      |L24.138|
0000a2  2000              MOVS     r0,#0                 ;1875
0000a4  84a0              STRH     r0,[r4,#0x24]         ;1875
0000a6  4620              MOV      r0,r4                 ;1877
0000a8  e7cc              B        |L24.68|
;;;1879   RTM_EXPORT(rt_mq_create);
                          ENDP

0000aa  0000              DCW      0x0000
                  |L24.172|
                          DCD      |symbol_number.157|
                  |L24.176|
0000b0  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0000b4  74696f6e
0000b8  5b25735d
0000bc  20736861
0000c0  6c6c206e
0000c4  6f742075
0000c8  73656420
0000cc  696e2049
0000d0  53520a00
                  |L24.212|
0000d4  3000              DCB      "0",0
0000d6  00                DCB      0
0000d7  00                DCB      0

                          AREA ||i.rt_mq_delete||, CODE, READONLY, ALIGN=2

                  rt_mq_delete PROC
;;;1887    */
;;;1888   rt_err_t rt_mq_delete(rt_mq_t mq)
000000  b570              PUSH     {r4-r6,lr}
;;;1889   {
000002  4604              MOV      r4,r0
;;;1890       RT_DEBUG_NOT_IN_INTERRUPT;
000004  bf00              NOP      
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  b148              CBZ      r0,|L25.38|
000012  4910              LDR      r1,|L25.84|
000014  a010              ADR      r0,|L25.88|
000016  f7fffffe          BL       rt_kprintf
00001a  f2407262          MOV      r2,#0x762
00001e  490d              LDR      r1,|L25.84|
000020  a016              ADR      r0,|L25.124|
000022  f7fffffe          BL       rt_assert_handler
                  |L25.38|
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       rt_hw_interrupt_enable
00002c  bf00              NOP      
;;;1891   
;;;1892       /* parameter check */
;;;1893       RT_ASSERT(mq != RT_NULL);
00002e  b92c              CBNZ     r4,|L25.60|
000030  f2407265          MOV      r2,#0x765
000034  4907              LDR      r1,|L25.84|
000036  a012              ADR      r0,|L25.128|
000038  f7fffffe          BL       rt_assert_handler
                  |L25.60|
;;;1894   
;;;1895       /* resume all suspended thread */
;;;1896       rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
00003c  f1040014          ADD      r0,r4,#0x14
000040  f7fffffe          BL       rt_ipc_list_resume_all
;;;1897   
;;;1898   #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;1899       /* the mq object belongs to an application module */
;;;1900       if (mq->parent.parent.flag & RT_OBJECT_FLAG_MODULE)
;;;1901           rt_module_free(mq->parent.parent.module_id, mq->msg_pool);
;;;1902       else
;;;1903   #endif
;;;1904   
;;;1905       /* free message queue pool */
;;;1906       RT_KERNEL_FREE(mq->msg_pool);
000044  69e0              LDR      r0,[r4,#0x1c]
000046  f7fffffe          BL       rt_free
;;;1907   
;;;1908       /* delete message queue object */
;;;1909       rt_object_delete(&(mq->parent.parent));
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       rt_object_delete
;;;1910   
;;;1911       return RT_EOK;
000050  2000              MOVS     r0,#0
;;;1912   }
000052  bd70              POP      {r4-r6,pc}
;;;1913   RTM_EXPORT(rt_mq_delete);
                          ENDP

                  |L25.84|
                          DCD      |symbol_number.158|
                  |L25.88|
000058  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00005c  74696f6e
000060  5b25735d
000064  20736861
000068  6c6c206e
00006c  6f742075
000070  73656420
000074  696e2049
000078  53520a00
                  |L25.124|
00007c  3000              DCB      "0",0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L25.128|
000080  6d712021          DCB      "mq != RT_NULL",0
000084  3d205254
000088  5f4e554c
00008c  4c00    
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.rt_mq_detach||, CODE, READONLY, ALIGN=2

                  rt_mq_detach PROC
;;;1796    */
;;;1797   rt_err_t rt_mq_detach(rt_mq_t mq)
000000  b510              PUSH     {r4,lr}
;;;1798   {
000002  4604              MOV      r4,r0
;;;1799       /* parameter check */
;;;1800       RT_ASSERT(mq != RT_NULL);
000004  b92c              CBNZ     r4,|L26.18|
000006  f44f62e1          MOV      r2,#0x708
00000a  4906              LDR      r1,|L26.36|
00000c  a006              ADR      r0,|L26.40|
00000e  f7fffffe          BL       rt_assert_handler
                  |L26.18|
;;;1801   
;;;1802       /* resume all suspended thread */
;;;1803       rt_ipc_list_resume_all(&mq->parent.suspend_thread);
000012  f1040014          ADD      r0,r4,#0x14
000016  f7fffffe          BL       rt_ipc_list_resume_all
;;;1804   
;;;1805       /* detach message queue object */
;;;1806       rt_object_detach(&(mq->parent.parent));
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_object_detach
;;;1807   
;;;1808       return RT_EOK;
000020  2000              MOVS     r0,#0
;;;1809   }
000022  bd10              POP      {r4,pc}
;;;1810   RTM_EXPORT(rt_mq_detach);
                          ENDP

                  |L26.36|
                          DCD      |symbol_number.156|
                  |L26.40|
000028  6d712021          DCB      "mq != RT_NULL",0
00002c  3d205254
000030  5f4e554c
000034  4c00    
000036  00                DCB      0
000037  00                DCB      0

                          AREA ||i.rt_mq_init||, CODE, READONLY, ALIGN=2

                  rt_mq_init PROC
;;;1739    */
;;;1740   rt_err_t rt_mq_init(rt_mq_t     mq,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1741                       const char *name,
;;;1742                       void       *msgpool,
;;;1743                       rt_size_t   msg_size,
;;;1744                       rt_size_t   pool_size,
;;;1745                       rt_uint8_t  flag)
;;;1746   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;1747       struct rt_mq_message *head;
;;;1748       register rt_base_t temp;
;;;1749   
;;;1750       /* parameter check */
;;;1751       RT_ASSERT(mq != RT_NULL);
000010  b92c              CBNZ     r4,|L27.30|
000012  f24062d7          MOV      r2,#0x6d7
000016  4918              LDR      r1,|L27.120|
000018  a018              ADR      r0,|L27.124|
00001a  f7fffffe          BL       rt_assert_handler
                  |L27.30|
;;;1752   
;;;1753       /* init object */
;;;1754       rt_object_init(&(mq->parent.parent), RT_Object_Class_MessageQueue, name);
00001e  463a              MOV      r2,r7
000020  2105              MOVS     r1,#5
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_object_init
;;;1755   
;;;1756       /* set parent flag */
;;;1757       mq->parent.parent.flag = flag;
000028  f884b009          STRB     r11,[r4,#9]
;;;1758   
;;;1759       /* init ipc object */
;;;1760       rt_ipc_object_init(&(mq->parent));
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       rt_ipc_object_init
;;;1761   
;;;1762       /* set messasge pool */
;;;1763       mq->msg_pool = msgpool;
000032  f8c4801c          STR      r8,[r4,#0x1c]
;;;1764   
;;;1765       /* get correct message size */
;;;1766       mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
000036  f1090003          ADD      r0,r9,#3
00003a  f0200003          BIC      r0,r0,#3
00003e  8420              STRH     r0,[r4,#0x20]
;;;1767       mq->max_msgs = pool_size / (mq->msg_size + sizeof(struct rt_mq_message));
000040  8c20              LDRH     r0,[r4,#0x20]
000042  1d00              ADDS     r0,r0,#4
000044  fbbaf0f0          UDIV     r0,r10,r0
000048  8460              STRH     r0,[r4,#0x22]
;;;1768   
;;;1769       /* init message list */
;;;1770       mq->msg_queue_head = RT_NULL;
00004a  2000              MOVS     r0,#0
00004c  62a0              STR      r0,[r4,#0x28]
;;;1771       mq->msg_queue_tail = RT_NULL;
00004e  62e0              STR      r0,[r4,#0x2c]
;;;1772   
;;;1773       /* init message empty list */
;;;1774       mq->msg_queue_free = RT_NULL;
000050  6320              STR      r0,[r4,#0x30]
;;;1775       for (temp = 0; temp < mq->max_msgs; temp ++)
000052  2500              MOVS     r5,#0
000054  e008              B        |L27.104|
                  |L27.86|
;;;1776       {
;;;1777           head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
000056  8c20              LDRH     r0,[r4,#0x20]
000058  1d00              ADDS     r0,r0,#4
00005a  69e1              LDR      r1,[r4,#0x1c]
00005c  fb051600          MLA      r6,r5,r0,r1
;;;1778               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
;;;1779           head->next = mq->msg_queue_free;
000060  6b20              LDR      r0,[r4,#0x30]
000062  6030              STR      r0,[r6,#0]
;;;1780           mq->msg_queue_free = head;
000064  6326              STR      r6,[r4,#0x30]
000066  1c6d              ADDS     r5,r5,#1              ;1775
                  |L27.104|
000068  8c60              LDRH     r0,[r4,#0x22]         ;1775
00006a  42a8              CMP      r0,r5                 ;1775
00006c  dcf3              BGT      |L27.86|
;;;1781       }
;;;1782   
;;;1783       /* the initial entry is zero */
;;;1784       mq->entry = 0;
00006e  2000              MOVS     r0,#0
000070  84a0              STRH     r0,[r4,#0x24]
;;;1785   
;;;1786       return RT_EOK;
;;;1787   }
000072  e8bd9ff0          POP      {r4-r12,pc}
;;;1788   RTM_EXPORT(rt_mq_init);
                          ENDP

000076  0000              DCW      0x0000
                  |L27.120|
                          DCD      |symbol_number.155|
                  |L27.124|
00007c  6d712021          DCB      "mq != RT_NULL",0
000080  3d205254
000084  5f4e554c
000088  4c00    
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.rt_mq_recv||, CODE, READONLY, ALIGN=2

                  rt_mq_recv PROC
;;;2096    */
;;;2097   rt_err_t rt_mq_recv(rt_mq_t    mq,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2098                       void      *buffer,
;;;2099                       rt_size_t  size,
;;;2100                       rt_int32_t timeout)
;;;2101   {
000004  b081              SUB      sp,sp,#4
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
00000a  4690              MOV      r8,r2
;;;2102       struct rt_thread *thread;
;;;2103       register rt_ubase_t temp;
;;;2104       struct rt_mq_message *msg;
;;;2105       rt_uint32_t tick_delta;
;;;2106   
;;;2107       RT_ASSERT(mq != RT_NULL);
00000c  b92c              CBNZ     r4,|L28.26|
00000e  f640023b          MOV      r2,#0x83b
000012  4965              LDR      r1,|L28.424|
000014  a065              ADR      r0,|L28.428|
000016  f7fffffe          BL       rt_assert_handler
                  |L28.26|
;;;2108       RT_ASSERT(buffer != RT_NULL);
00001a  b92f              CBNZ     r7,|L28.40|
00001c  f640023c          MOV      r2,#0x83c
000020  4961              LDR      r1,|L28.424|
000022  a066              ADR      r0,|L28.444|
000024  f7fffffe          BL       rt_assert_handler
                  |L28.40|
;;;2109       RT_ASSERT(size != 0);
000028  f1b80f00          CMP      r8,#0
00002c  d105              BNE      |L28.58|
00002e  f640023d          MOV      r2,#0x83d
000032  495d              LDR      r1,|L28.424|
000034  a066              ADR      r0,|L28.464|
000036  f7fffffe          BL       rt_assert_handler
                  |L28.58|
;;;2110   
;;;2111       /* initialize delta tick */
;;;2112       tick_delta = 0;
00003a  f04f0900          MOV      r9,#0
;;;2113       /* get current thread */
;;;2114       thread = rt_thread_self();
00003e  f7fffffe          BL       rt_thread_self
000042  4605              MOV      r5,r0
;;;2115       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
000044  bf00              NOP      
000046  4865              LDR      r0,|L28.476|
000048  6800              LDR      r0,[r0,#0]  ; rt_object_trytake_hook
00004a  b118              CBZ      r0,|L28.84|
00004c  4620              MOV      r0,r4
00004e  4963              LDR      r1,|L28.476|
000050  6809              LDR      r1,[r1,#0]  ; rt_object_trytake_hook
000052  4788              BLX      r1
                  |L28.84|
000054  bf00              NOP      
;;;2116   
;;;2117       /* disable interrupt */
;;;2118       temp = rt_hw_interrupt_disable();
000056  f7fffffe          BL       rt_hw_interrupt_disable
00005a  4682              MOV      r10,r0
;;;2119   
;;;2120       /* for non-blocking call */
;;;2121       if (mq->entry == 0 && timeout == 0)
00005c  8ca0              LDRH     r0,[r4,#0x24]
00005e  b948              CBNZ     r0,|L28.116|
000060  9804              LDR      r0,[sp,#0x10]
000062  b938              CBNZ     r0,|L28.116|
;;;2122       {
;;;2123           rt_hw_interrupt_enable(temp);
000064  4650              MOV      r0,r10
000066  f7fffffe          BL       rt_hw_interrupt_enable
;;;2124   
;;;2125           return -RT_ETIMEOUT;
00006a  f06f0001          MVN      r0,#1
                  |L28.110|
;;;2126       }
;;;2127   
;;;2128       /* message queue is empty */
;;;2129       while (mq->entry == 0)
;;;2130       {
;;;2131           RT_DEBUG_IN_THREAD_CONTEXT;
;;;2132   
;;;2133           /* reset error number in thread */
;;;2134           thread->error = RT_EOK;
;;;2135   
;;;2136           /* no waiting, return timeout */
;;;2137           if (timeout == 0)
;;;2138           {
;;;2139               /* enable interrupt */
;;;2140               rt_hw_interrupt_enable(temp);
;;;2141   
;;;2142               thread->error = -RT_ETIMEOUT;
;;;2143   
;;;2144               return -RT_ETIMEOUT;
;;;2145           }
;;;2146   
;;;2147           /* suspend current thread */
;;;2148           rt_ipc_list_suspend(&(mq->parent.suspend_thread),
;;;2149                               thread,
;;;2150                               mq->parent.parent.flag);
;;;2151   
;;;2152           /* has waiting time, start thread timer */
;;;2153           if (timeout > 0)
;;;2154           {
;;;2155               /* get the start tick of timer */
;;;2156               tick_delta = rt_tick_get();
;;;2157   
;;;2158               RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
;;;2159                                           thread->name));
;;;2160   
;;;2161               /* reset the timeout of thread timer and start it */
;;;2162               rt_timer_control(&(thread->thread_timer),
;;;2163                                RT_TIMER_CTRL_SET_TIME,
;;;2164                                &timeout);
;;;2165               rt_timer_start(&(thread->thread_timer));
;;;2166           }
;;;2167   
;;;2168           /* enable interrupt */
;;;2169           rt_hw_interrupt_enable(temp);
;;;2170   
;;;2171           /* re-schedule */
;;;2172           rt_schedule();
;;;2173   
;;;2174           /* recv message */
;;;2175           if (thread->error != RT_EOK)
;;;2176           {
;;;2177               /* return error */
;;;2178               return thread->error;
;;;2179           }
;;;2180   
;;;2181           /* disable interrupt */
;;;2182           temp = rt_hw_interrupt_disable();
;;;2183   
;;;2184           /* if it's not waiting forever and then re-calculate timeout tick */
;;;2185           if (timeout > 0)
;;;2186           {
;;;2187               tick_delta = rt_tick_get() - tick_delta;
;;;2188               timeout -= tick_delta;
;;;2189               if (timeout < 0)
;;;2190                   timeout = 0;
;;;2191           }
;;;2192       }
;;;2193   
;;;2194       /* get message from queue */
;;;2195       msg = (struct rt_mq_message *)mq->msg_queue_head;
;;;2196   
;;;2197       /* move message queue head */
;;;2198       mq->msg_queue_head = msg->next;
;;;2199       /* reach queue tail, set to NULL */
;;;2200       if (mq->msg_queue_tail == msg)
;;;2201           mq->msg_queue_tail = RT_NULL;
;;;2202   
;;;2203       /* decrease message entry */
;;;2204       mq->entry --;
;;;2205   
;;;2206       /* enable interrupt */
;;;2207       rt_hw_interrupt_enable(temp);
;;;2208   
;;;2209       /* copy message */
;;;2210       rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
;;;2211   
;;;2212       /* disable interrupt */
;;;2213       temp = rt_hw_interrupt_disable();
;;;2214       /* put message to free list */
;;;2215       msg->next = (struct rt_mq_message *)mq->msg_queue_free;
;;;2216       mq->msg_queue_free = msg;
;;;2217       /* enable interrupt */
;;;2218       rt_hw_interrupt_enable(temp);
;;;2219   
;;;2220       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
;;;2221   
;;;2222       return RT_EOK;
;;;2223   }
00006e  b005              ADD      sp,sp,#0x14
000070  e8bd8ff0          POP      {r4-r11,pc}
                  |L28.116|
000074  e068              B        |L28.328|
                  |L28.118|
000076  bf00              NOP                            ;2131
000078  f7fffffe          BL       rt_hw_interrupt_disable
00007c  9000              STR      r0,[sp,#0]            ;2131
00007e  f7fffffe          BL       rt_thread_self
000082  b948              CBNZ     r0,|L28.152|
000084  4948              LDR      r1,|L28.424|
000086  a056              ADR      r0,|L28.480|
000088  f7fffffe          BL       rt_kprintf
00008c  f6400253          MOV      r2,#0x853             ;2131
000090  4945              LDR      r1,|L28.424|
000092  a051              ADR      r0,|L28.472|
000094  f7fffffe          BL       rt_assert_handler
                  |L28.152|
000098  bf00              NOP                            ;2131
00009a  f7fffffe          BL       rt_hw_interrupt_disable
00009e  4683              MOV      r11,r0                ;2131
0000a0  f7fffffe          BL       rt_interrupt_get_nest
0000a4  b148              CBZ      r0,|L28.186|
0000a6  4940              LDR      r1,|L28.424|
0000a8  a05b              ADR      r0,|L28.536|
0000aa  f7fffffe          BL       rt_kprintf
0000ae  f6400253          MOV      r2,#0x853             ;2131
0000b2  493d              LDR      r1,|L28.424|
0000b4  a048              ADR      r0,|L28.472|
0000b6  f7fffffe          BL       rt_assert_handler
                  |L28.186|
0000ba  4658              MOV      r0,r11                ;2131
0000bc  f7fffffe          BL       rt_hw_interrupt_enable
0000c0  bf00              NOP                            ;2131
0000c2  9800              LDR      r0,[sp,#0]            ;2131
0000c4  f7fffffe          BL       rt_hw_interrupt_enable
0000c8  bf00              NOP                            ;2131
0000ca  2000              MOVS     r0,#0                 ;2134
0000cc  6328              STR      r0,[r5,#0x30]         ;2134
0000ce  9804              LDR      r0,[sp,#0x10]         ;2137
0000d0  b930              CBNZ     r0,|L28.224|
0000d2  4650              MOV      r0,r10                ;2140
0000d4  f7fffffe          BL       rt_hw_interrupt_enable
0000d8  f06f0001          MVN      r0,#1                 ;2142
0000dc  6328              STR      r0,[r5,#0x30]         ;2142
0000de  e7c6              B        |L28.110|
                  |L28.224|
0000e0  7a62              LDRB     r2,[r4,#9]            ;2148
0000e2  4629              MOV      r1,r5                 ;2148
0000e4  f1040014          ADD      r0,r4,#0x14           ;2148
0000e8  f7fffffe          BL       rt_ipc_list_suspend
0000ec  9804              LDR      r0,[sp,#0x10]         ;2153
0000ee  2800              CMP      r0,#0                 ;2153
0000f0  dd0e              BLE      |L28.272|
0000f2  f7fffffe          BL       rt_tick_get
0000f6  4681              MOV      r9,r0                 ;2156
0000f8  bf00              NOP                            ;2158
0000fa  bf00              NOP                            ;2158
0000fc  aa04              ADD      r2,sp,#0x10           ;2162
0000fe  2100              MOVS     r1,#0                 ;2162
000100  f105004c          ADD      r0,r5,#0x4c           ;2162
000104  f7fffffe          BL       rt_timer_control
000108  f105004c          ADD      r0,r5,#0x4c           ;2165
00010c  f7fffffe          BL       rt_timer_start
                  |L28.272|
000110  4650              MOV      r0,r10                ;2169
000112  f7fffffe          BL       rt_hw_interrupt_enable
000116  f7fffffe          BL       rt_schedule
00011a  6b28              LDR      r0,[r5,#0x30]         ;2175
00011c  b108              CBZ      r0,|L28.290|
00011e  6b28              LDR      r0,[r5,#0x30]         ;2178
000120  e7a5              B        |L28.110|
                  |L28.290|
000122  f7fffffe          BL       rt_hw_interrupt_disable
000126  4682              MOV      r10,r0                ;2182
000128  9804              LDR      r0,[sp,#0x10]         ;2185
00012a  2800              CMP      r0,#0                 ;2185
00012c  dd0c              BLE      |L28.328|
00012e  f7fffffe          BL       rt_tick_get
000132  eba00909          SUB      r9,r0,r9              ;2187
000136  9804              LDR      r0,[sp,#0x10]         ;2188
000138  eba00009          SUB      r0,r0,r9              ;2188
00013c  9004              STR      r0,[sp,#0x10]         ;2188
00013e  9804              LDR      r0,[sp,#0x10]         ;2189
000140  2800              CMP      r0,#0                 ;2189
000142  da01              BGE      |L28.328|
000144  2000              MOVS     r0,#0                 ;2190
000146  9004              STR      r0,[sp,#0x10]         ;2190
                  |L28.328|
000148  8ca0              LDRH     r0,[r4,#0x24]         ;2129
00014a  2800              CMP      r0,#0                 ;2129
00014c  d093              BEQ      |L28.118|
00014e  6aa6              LDR      r6,[r4,#0x28]         ;2195
000150  6830              LDR      r0,[r6,#0]            ;2198
000152  62a0              STR      r0,[r4,#0x28]         ;2198
000154  6ae0              LDR      r0,[r4,#0x2c]         ;2200
000156  42b0              CMP      r0,r6                 ;2200
000158  d101              BNE      |L28.350|
00015a  2000              MOVS     r0,#0                 ;2201
00015c  62e0              STR      r0,[r4,#0x2c]         ;2201
                  |L28.350|
00015e  8ca0              LDRH     r0,[r4,#0x24]         ;2204
000160  1e40              SUBS     r0,r0,#1              ;2204
000162  84a0              STRH     r0,[r4,#0x24]         ;2204
000164  4650              MOV      r0,r10                ;2207
000166  f7fffffe          BL       rt_hw_interrupt_enable
00016a  8c20              LDRH     r0,[r4,#0x20]         ;2210
00016c  4540              CMP      r0,r8                 ;2210
00016e  d201              BCS      |L28.372|
000170  8c20              LDRH     r0,[r4,#0x20]         ;2210
000172  e000              B        |L28.374|
                  |L28.372|
000174  4640              MOV      r0,r8                 ;2210
                  |L28.374|
000176  4602              MOV      r2,r0                 ;2210
000178  1d31              ADDS     r1,r6,#4              ;2210
00017a  4638              MOV      r0,r7                 ;2210
00017c  f7fffffe          BL       rt_memcpy
000180  f7fffffe          BL       rt_hw_interrupt_disable
000184  4682              MOV      r10,r0                ;2213
000186  6b20              LDR      r0,[r4,#0x30]         ;2215
000188  6030              STR      r0,[r6,#0]            ;2215
00018a  6326              STR      r6,[r4,#0x30]         ;2216
00018c  4650              MOV      r0,r10                ;2218
00018e  f7fffffe          BL       rt_hw_interrupt_enable
000192  bf00              NOP                            ;2220
000194  4829              LDR      r0,|L28.572|
000196  6800              LDR      r0,[r0,#0]            ;2220  ; rt_object_take_hook
000198  b118              CBZ      r0,|L28.418|
00019a  4620              MOV      r0,r4                 ;2220
00019c  4927              LDR      r1,|L28.572|
00019e  6809              LDR      r1,[r1,#0]            ;2220  ; rt_object_take_hook
0001a0  4788              BLX      r1                    ;2220
                  |L28.418|
0001a2  bf00              NOP                            ;2220
0001a4  2000              MOVS     r0,#0                 ;2222
0001a6  e762              B        |L28.110|
;;;2224   RTM_EXPORT(rt_mq_recv);
                          ENDP

                  |L28.424|
                          DCD      |symbol_number.161|
                  |L28.428|
0001ac  6d712021          DCB      "mq != RT_NULL",0
0001b0  3d205254
0001b4  5f4e554c
0001b8  4c00    
0001ba  00                DCB      0
0001bb  00                DCB      0
                  |L28.444|
0001bc  62756666          DCB      "buffer != RT_NULL",0
0001c0  65722021
0001c4  3d205254
0001c8  5f4e554c
0001cc  4c00    
0001ce  00                DCB      0
0001cf  00                DCB      0
                  |L28.464|
0001d0  73697a65          DCB      "size != "
0001d4  20213d20
                  |L28.472|
0001d8  3000              DCB      "0",0
0001da  00                DCB      0
0001db  00                DCB      0
                  |L28.476|
                          DCD      rt_object_trytake_hook
                  |L28.480|
0001e0  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
0001e4  74696f6e
0001e8  5b25735d
0001ec  20736861
0001f0  6c6c206e
0001f4  6f742062
0001f8  65207573
0001fc  65642062
000200  65666f72
000204  65207363
000208  68656475
00020c  6c657220
000210  73746172
000214  740a    
000216  00                DCB      0
000217  00                DCB      0
                  |L28.536|
000218  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00021c  74696f6e
000220  5b25735d
000224  20736861
000228  6c6c206e
00022c  6f742075
000230  73656420
000234  696e2049
000238  53520a00
                  |L28.572|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_mq_send||, CODE, READONLY, ALIGN=2

                  rt_mq_send PROC
;;;1925    */
;;;1926   rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1927   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;1928       register rt_ubase_t temp;
;;;1929       struct rt_mq_message *msg;
;;;1930   
;;;1931       RT_ASSERT(mq != RT_NULL);
00000a  b92c              CBNZ     r4,|L29.24|
00000c  f240728b          MOV      r2,#0x78b
000010  492d              LDR      r1,|L29.200|
000012  a02e              ADR      r0,|L29.204|
000014  f7fffffe          BL       rt_assert_handler
                  |L29.24|
;;;1932       RT_ASSERT(buffer != RT_NULL);
000018  b92f              CBNZ     r7,|L29.38|
00001a  f240728c          MOV      r2,#0x78c
00001e  492a              LDR      r1,|L29.200|
000020  a02e              ADR      r0,|L29.220|
000022  f7fffffe          BL       rt_assert_handler
                  |L29.38|
;;;1933       RT_ASSERT(size != 0);
000026  b92e              CBNZ     r6,|L29.52|
000028  f240728d          MOV      r2,#0x78d
00002c  4926              LDR      r1,|L29.200|
00002e  a030              ADR      r0,|L29.240|
000030  f7fffffe          BL       rt_assert_handler
                  |L29.52|
;;;1934   
;;;1935       /* greater than one message size */
;;;1936       if (size > mq->msg_size)
000034  8c20              LDRH     r0,[r4,#0x20]
000036  42b0              CMP      r0,r6
000038  d203              BCS      |L29.66|
;;;1937           return -RT_ERROR;
00003a  f04f30ff          MOV      r0,#0xffffffff
                  |L29.62|
;;;1938   
;;;1939       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
;;;1940   
;;;1941       /* disable interrupt */
;;;1942       temp = rt_hw_interrupt_disable();
;;;1943   
;;;1944       /* get a free list, there must be an empty item */
;;;1945       msg = (struct rt_mq_message*)mq->msg_queue_free;
;;;1946       /* message queue is full */
;;;1947       if (msg == RT_NULL)
;;;1948       {
;;;1949           /* enable interrupt */
;;;1950           rt_hw_interrupt_enable(temp);
;;;1951   
;;;1952           return -RT_EFULL;
;;;1953       }
;;;1954       /* move free list pointer */
;;;1955       mq->msg_queue_free = msg->next;
;;;1956   
;;;1957       /* enable interrupt */
;;;1958       rt_hw_interrupt_enable(temp);
;;;1959   
;;;1960       /* the msg is the new tailer of list, the next shall be NULL */
;;;1961       msg->next = RT_NULL;
;;;1962       /* copy buffer */
;;;1963       rt_memcpy(msg + 1, buffer, size);
;;;1964   
;;;1965       /* disable interrupt */
;;;1966       temp = rt_hw_interrupt_disable();
;;;1967       /* link msg to message queue */
;;;1968       if (mq->msg_queue_tail != RT_NULL)
;;;1969       {
;;;1970           /* if the tail exists, */
;;;1971           ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
;;;1972       }
;;;1973   
;;;1974       /* set new tail */
;;;1975       mq->msg_queue_tail = msg;
;;;1976       /* if the head is empty, set head */
;;;1977       if (mq->msg_queue_head == RT_NULL)
;;;1978           mq->msg_queue_head = msg;
;;;1979   
;;;1980       /* increase message entry */
;;;1981       mq->entry ++;
;;;1982   
;;;1983       /* resume suspended thread */
;;;1984       if (!rt_list_isempty(&mq->parent.suspend_thread))
;;;1985       {
;;;1986           rt_ipc_list_resume(&(mq->parent.suspend_thread));
;;;1987   
;;;1988           /* enable interrupt */
;;;1989           rt_hw_interrupt_enable(temp);
;;;1990   
;;;1991           rt_schedule();
;;;1992   
;;;1993           return RT_EOK;
;;;1994       }
;;;1995   
;;;1996       /* enable interrupt */
;;;1997       rt_hw_interrupt_enable(temp);
;;;1998   
;;;1999       return RT_EOK;
;;;2000   }
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L29.66|
000042  bf00              NOP                            ;1939
000044  482d              LDR      r0,|L29.252|
000046  6800              LDR      r0,[r0,#0]            ;1939  ; rt_object_put_hook
000048  b118              CBZ      r0,|L29.82|
00004a  4620              MOV      r0,r4                 ;1939
00004c  492b              LDR      r1,|L29.252|
00004e  6809              LDR      r1,[r1,#0]            ;1939  ; rt_object_put_hook
000050  4788              BLX      r1                    ;1939
                  |L29.82|
000052  bf00              NOP                            ;1939
000054  f7fffffe          BL       rt_hw_interrupt_disable
000058  4680              MOV      r8,r0                 ;1942
00005a  6b25              LDR      r5,[r4,#0x30]         ;1945
00005c  b92d              CBNZ     r5,|L29.106|
00005e  4640              MOV      r0,r8                 ;1950
000060  f7fffffe          BL       rt_hw_interrupt_enable
000064  f06f0002          MVN      r0,#2                 ;1952
000068  e7e9              B        |L29.62|
                  |L29.106|
00006a  6828              LDR      r0,[r5,#0]            ;1955
00006c  6320              STR      r0,[r4,#0x30]         ;1955
00006e  4640              MOV      r0,r8                 ;1958
000070  f7fffffe          BL       rt_hw_interrupt_enable
000074  2000              MOVS     r0,#0                 ;1961
000076  6028              STR      r0,[r5,#0]            ;1961
000078  4632              MOV      r2,r6                 ;1963
00007a  4639              MOV      r1,r7                 ;1963
00007c  1d28              ADDS     r0,r5,#4              ;1963
00007e  f7fffffe          BL       rt_memcpy
000082  f7fffffe          BL       rt_hw_interrupt_disable
000086  4680              MOV      r8,r0                 ;1966
000088  6ae0              LDR      r0,[r4,#0x2c]         ;1968
00008a  b108              CBZ      r0,|L29.144|
00008c  6ae0              LDR      r0,[r4,#0x2c]         ;1971
00008e  6005              STR      r5,[r0,#0]            ;1971
                  |L29.144|
000090  62e5              STR      r5,[r4,#0x2c]         ;1975
000092  6aa0              LDR      r0,[r4,#0x28]         ;1977
000094  b900              CBNZ     r0,|L29.152|
000096  62a5              STR      r5,[r4,#0x28]         ;1978
                  |L29.152|
000098  8ca0              LDRH     r0,[r4,#0x24]         ;1981
00009a  1c40              ADDS     r0,r0,#1              ;1981
00009c  84a0              STRH     r0,[r4,#0x24]         ;1981
00009e  f1040014          ADD      r0,r4,#0x14           ;1984
0000a2  f7fffffe          BL       rt_list_isempty
0000a6  b950              CBNZ     r0,|L29.190|
0000a8  f1040014          ADD      r0,r4,#0x14           ;1986
0000ac  f7fffffe          BL       rt_ipc_list_resume
0000b0  4640              MOV      r0,r8                 ;1989
0000b2  f7fffffe          BL       rt_hw_interrupt_enable
0000b6  f7fffffe          BL       rt_schedule
0000ba  2000              MOVS     r0,#0                 ;1993
0000bc  e7bf              B        |L29.62|
                  |L29.190|
0000be  4640              MOV      r0,r8                 ;1997
0000c0  f7fffffe          BL       rt_hw_interrupt_enable
0000c4  2000              MOVS     r0,#0                 ;1999
0000c6  e7ba              B        |L29.62|
;;;2001   RTM_EXPORT(rt_mq_send);
                          ENDP

                  |L29.200|
                          DCD      |symbol_number.159|
                  |L29.204|
0000cc  6d712021          DCB      "mq != RT_NULL",0
0000d0  3d205254
0000d4  5f4e554c
0000d8  4c00    
0000da  00                DCB      0
0000db  00                DCB      0
                  |L29.220|
0000dc  62756666          DCB      "buffer != RT_NULL",0
0000e0  65722021
0000e4  3d205254
0000e8  5f4e554c
0000ec  4c00    
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L29.240|
0000f0  73697a65          DCB      "size != 0",0
0000f4  20213d20
0000f8  3000    
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L29.252|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_mq_urgent||, CODE, READONLY, ALIGN=2

                  rt_mq_urgent PROC
;;;2013    */
;;;2014   rt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2015   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;2016       register rt_ubase_t temp;
;;;2017       struct rt_mq_message *msg;
;;;2018   
;;;2019       RT_ASSERT(mq != RT_NULL);
00000a  b92c              CBNZ     r4,|L30.24|
00000c  f24072e3          MOV      r2,#0x7e3
000010  492b              LDR      r1,|L30.192|
000012  a02c              ADR      r0,|L30.196|
000014  f7fffffe          BL       rt_assert_handler
                  |L30.24|
;;;2020       RT_ASSERT(buffer != RT_NULL);
000018  b92f              CBNZ     r7,|L30.38|
00001a  f24072e4          MOV      r2,#0x7e4
00001e  4928              LDR      r1,|L30.192|
000020  a02c              ADR      r0,|L30.212|
000022  f7fffffe          BL       rt_assert_handler
                  |L30.38|
;;;2021       RT_ASSERT(size != 0);
000026  b92e              CBNZ     r6,|L30.52|
000028  f24072e5          MOV      r2,#0x7e5
00002c  4924              LDR      r1,|L30.192|
00002e  a02e              ADR      r0,|L30.232|
000030  f7fffffe          BL       rt_assert_handler
                  |L30.52|
;;;2022   
;;;2023       /* greater than one message size */
;;;2024       if (size > mq->msg_size)
000034  8c20              LDRH     r0,[r4,#0x20]
000036  42b0              CMP      r0,r6
000038  d203              BCS      |L30.66|
;;;2025           return -RT_ERROR;
00003a  f04f30ff          MOV      r0,#0xffffffff
                  |L30.62|
;;;2026   
;;;2027       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
;;;2028   
;;;2029       /* disable interrupt */
;;;2030       temp = rt_hw_interrupt_disable();
;;;2031   
;;;2032       /* get a free list, there must be an empty item */
;;;2033       msg = (struct rt_mq_message *)mq->msg_queue_free;
;;;2034       /* message queue is full */
;;;2035       if (msg == RT_NULL)
;;;2036       {
;;;2037           /* enable interrupt */
;;;2038           rt_hw_interrupt_enable(temp);
;;;2039   
;;;2040           return -RT_EFULL;
;;;2041       }
;;;2042       /* move free list pointer */
;;;2043       mq->msg_queue_free = msg->next;
;;;2044   
;;;2045       /* enable interrupt */
;;;2046       rt_hw_interrupt_enable(temp);
;;;2047   
;;;2048       /* copy buffer */
;;;2049       rt_memcpy(msg + 1, buffer, size);
;;;2050   
;;;2051       /* disable interrupt */
;;;2052       temp = rt_hw_interrupt_disable();
;;;2053   
;;;2054       /* link msg to the beginning of message queue */
;;;2055       msg->next = mq->msg_queue_head;
;;;2056       mq->msg_queue_head = msg;
;;;2057   
;;;2058       /* if there is no tail */
;;;2059       if (mq->msg_queue_tail == RT_NULL)
;;;2060           mq->msg_queue_tail = msg;
;;;2061   
;;;2062       /* increase message entry */
;;;2063       mq->entry ++;
;;;2064   
;;;2065       /* resume suspended thread */
;;;2066       if (!rt_list_isempty(&mq->parent.suspend_thread))
;;;2067       {
;;;2068           rt_ipc_list_resume(&(mq->parent.suspend_thread));
;;;2069   
;;;2070           /* enable interrupt */
;;;2071           rt_hw_interrupt_enable(temp);
;;;2072   
;;;2073           rt_schedule();
;;;2074   
;;;2075           return RT_EOK;
;;;2076       }
;;;2077   
;;;2078       /* enable interrupt */
;;;2079       rt_hw_interrupt_enable(temp);
;;;2080   
;;;2081       return RT_EOK;
;;;2082   }
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L30.66|
000042  bf00              NOP                            ;2027
000044  482b              LDR      r0,|L30.244|
000046  6800              LDR      r0,[r0,#0]            ;2027  ; rt_object_put_hook
000048  b118              CBZ      r0,|L30.82|
00004a  4620              MOV      r0,r4                 ;2027
00004c  4929              LDR      r1,|L30.244|
00004e  6809              LDR      r1,[r1,#0]            ;2027  ; rt_object_put_hook
000050  4788              BLX      r1                    ;2027
                  |L30.82|
000052  bf00              NOP                            ;2027
000054  f7fffffe          BL       rt_hw_interrupt_disable
000058  4680              MOV      r8,r0                 ;2030
00005a  6b25              LDR      r5,[r4,#0x30]         ;2033
00005c  b92d              CBNZ     r5,|L30.106|
00005e  4640              MOV      r0,r8                 ;2038
000060  f7fffffe          BL       rt_hw_interrupt_enable
000064  f06f0002          MVN      r0,#2                 ;2040
000068  e7e9              B        |L30.62|
                  |L30.106|
00006a  6828              LDR      r0,[r5,#0]            ;2043
00006c  6320              STR      r0,[r4,#0x30]         ;2043
00006e  4640              MOV      r0,r8                 ;2046
000070  f7fffffe          BL       rt_hw_interrupt_enable
000074  4632              MOV      r2,r6                 ;2049
000076  4639              MOV      r1,r7                 ;2049
000078  1d28              ADDS     r0,r5,#4              ;2049
00007a  f7fffffe          BL       rt_memcpy
00007e  f7fffffe          BL       rt_hw_interrupt_disable
000082  4680              MOV      r8,r0                 ;2052
000084  6aa0              LDR      r0,[r4,#0x28]         ;2055
000086  6028              STR      r0,[r5,#0]            ;2055
000088  62a5              STR      r5,[r4,#0x28]         ;2056
00008a  6ae0              LDR      r0,[r4,#0x2c]         ;2059
00008c  b900              CBNZ     r0,|L30.144|
00008e  62e5              STR      r5,[r4,#0x2c]         ;2060
                  |L30.144|
000090  8ca0              LDRH     r0,[r4,#0x24]         ;2063
000092  1c40              ADDS     r0,r0,#1              ;2063
000094  84a0              STRH     r0,[r4,#0x24]         ;2063
000096  f1040014          ADD      r0,r4,#0x14           ;2066
00009a  f7fffffe          BL       rt_list_isempty
00009e  b950              CBNZ     r0,|L30.182|
0000a0  f1040014          ADD      r0,r4,#0x14           ;2068
0000a4  f7fffffe          BL       rt_ipc_list_resume
0000a8  4640              MOV      r0,r8                 ;2071
0000aa  f7fffffe          BL       rt_hw_interrupt_enable
0000ae  f7fffffe          BL       rt_schedule
0000b2  2000              MOVS     r0,#0                 ;2075
0000b4  e7c3              B        |L30.62|
                  |L30.182|
0000b6  4640              MOV      r0,r8                 ;2079
0000b8  f7fffffe          BL       rt_hw_interrupt_enable
0000bc  2000              MOVS     r0,#0                 ;2081
0000be  e7be              B        |L30.62|
;;;2083   RTM_EXPORT(rt_mq_urgent);
                          ENDP

                  |L30.192|
                          DCD      |symbol_number.160|
                  |L30.196|
0000c4  6d712021          DCB      "mq != RT_NULL",0
0000c8  3d205254
0000cc  5f4e554c
0000d0  4c00    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L30.212|
0000d4  62756666          DCB      "buffer != RT_NULL",0
0000d8  65722021
0000dc  3d205254
0000e0  5f4e554c
0000e4  4c00    
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L30.232|
0000e8  73697a65          DCB      "size != 0",0
0000ec  20213d20
0000f0  3000    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L30.244|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_mutex_control||, CODE, READONLY, ALIGN=1

                  rt_mutex_control PROC
;;;870     */
;;;871    rt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg)
000000  4603              MOV      r3,r0
;;;872    {
;;;873        return -RT_ERROR;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;874    }
000006  4770              BX       lr
;;;875    RTM_EXPORT(rt_mutex_control);
                          ENDP


                          AREA ||i.rt_mutex_create||, CODE, READONLY, ALIGN=2

                  rt_mutex_create PROC
;;;580     */
;;;581    rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;582    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;583        struct rt_mutex *mutex;
;;;584    
;;;585        RT_DEBUG_NOT_IN_INTERRUPT;
000008  bf00              NOP      
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4607              MOV      r7,r0
000010  f7fffffe          BL       rt_interrupt_get_nest
000014  b148              CBZ      r0,|L32.42|
000016  4912              LDR      r1,|L32.96|
000018  a012              ADR      r0,|L32.100|
00001a  f7fffffe          BL       rt_kprintf
00001e  f2402249          MOV      r2,#0x249
000022  490f              LDR      r1,|L32.96|
000024  a018              ADR      r0,|L32.136|
000026  f7fffffe          BL       rt_assert_handler
                  |L32.42|
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       rt_hw_interrupt_enable
000030  bf00              NOP      
;;;586    
;;;587        /* allocate object */
;;;588        mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
000032  4629              MOV      r1,r5
000034  2002              MOVS     r0,#2
000036  f7fffffe          BL       rt_object_allocate
00003a  4604              MOV      r4,r0
;;;589        if (mutex == RT_NULL)
00003c  b914              CBNZ     r4,|L32.68|
;;;590            return mutex;
00003e  4620              MOV      r0,r4
                  |L32.64|
;;;591    
;;;592        /* init ipc object */
;;;593        rt_ipc_object_init(&(mutex->parent));
;;;594    
;;;595        mutex->value              = 1;
;;;596        mutex->owner              = RT_NULL;
;;;597        mutex->original_priority  = 0xFF;
;;;598        mutex->hold               = 0;
;;;599    
;;;600        /* set flag */
;;;601        mutex->parent.parent.flag = flag;
;;;602    
;;;603        return mutex;
;;;604    }
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L32.68|
000044  4620              MOV      r0,r4                 ;593
000046  f7fffffe          BL       rt_ipc_object_init
00004a  2001              MOVS     r0,#1                 ;595
00004c  83a0              STRH     r0,[r4,#0x1c]         ;595
00004e  2000              MOVS     r0,#0                 ;596
000050  6220              STR      r0,[r4,#0x20]         ;596
000052  20ff              MOVS     r0,#0xff              ;597
000054  77a0              STRB     r0,[r4,#0x1e]         ;597
000056  2000              MOVS     r0,#0                 ;598
000058  77e0              STRB     r0,[r4,#0x1f]         ;598
00005a  7266              STRB     r6,[r4,#9]            ;601
00005c  4620              MOV      r0,r4                 ;603
00005e  e7ef              B        |L32.64|
;;;605    RTM_EXPORT(rt_mutex_create);
                          ENDP

                  |L32.96|
                          DCD      |symbol_number.137|
                  |L32.100|
000064  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000068  74696f6e
00006c  5b25735d
000070  20736861
000074  6c6c206e
000078  6f742075
00007c  73656420
000080  696e2049
000084  53520a00
                  |L32.136|
000088  3000              DCB      "0",0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.rt_mutex_delete||, CODE, READONLY, ALIGN=2

                  rt_mutex_delete PROC
;;;615     */
;;;616    rt_err_t rt_mutex_delete(rt_mutex_t mutex)
000000  b570              PUSH     {r4-r6,lr}
;;;617    {
000002  4604              MOV      r4,r0
;;;618        RT_DEBUG_NOT_IN_INTERRUPT;
000004  bf00              NOP      
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  b148              CBZ      r0,|L33.38|
000012  490f              LDR      r1,|L33.80|
000014  a00f              ADR      r0,|L33.84|
000016  f7fffffe          BL       rt_kprintf
00001a  f240226a          MOV      r2,#0x26a
00001e  490c              LDR      r1,|L33.80|
000020  a015              ADR      r0,|L33.120|
000022  f7fffffe          BL       rt_assert_handler
                  |L33.38|
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       rt_hw_interrupt_enable
00002c  bf00              NOP      
;;;619    
;;;620        RT_ASSERT(mutex != RT_NULL);
00002e  b92c              CBNZ     r4,|L33.60|
000030  f44f721b          MOV      r2,#0x26c
000034  4906              LDR      r1,|L33.80|
000036  a011              ADR      r0,|L33.124|
000038  f7fffffe          BL       rt_assert_handler
                  |L33.60|
;;;621    
;;;622        /* wakeup all suspend threads */
;;;623        rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
00003c  f1040014          ADD      r0,r4,#0x14
000040  f7fffffe          BL       rt_ipc_list_resume_all
;;;624    
;;;625        /* delete semaphore object */
;;;626        rt_object_delete(&(mutex->parent.parent));
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       rt_object_delete
;;;627    
;;;628        return RT_EOK;
00004a  2000              MOVS     r0,#0
;;;629    }
00004c  bd70              POP      {r4-r6,pc}
;;;630    RTM_EXPORT(rt_mutex_delete);
                          ENDP

00004e  0000              DCW      0x0000
                  |L33.80|
                          DCD      |symbol_number.138|
                  |L33.84|
000054  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000058  74696f6e
00005c  5b25735d
000060  20736861
000064  6c6c206e
000068  6f742075
00006c  73656420
000070  696e2049
000074  53520a00
                  |L33.120|
000078  3000              DCB      "0",0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L33.124|
00007c  6d757465          DCB      "mutex != RT_NULL",0
000080  7820213d
000084  2052545f
000088  4e554c4c
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.rt_mutex_detach||, CODE, READONLY, ALIGN=2

                  rt_mutex_detach PROC
;;;555     */
;;;556    rt_err_t rt_mutex_detach(rt_mutex_t mutex)
000000  b510              PUSH     {r4,lr}
;;;557    {
000002  4604              MOV      r4,r0
;;;558        RT_ASSERT(mutex != RT_NULL);
000004  b92c              CBNZ     r4,|L34.18|
000006  f240222e          MOV      r2,#0x22e
00000a  4906              LDR      r1,|L34.36|
00000c  a006              ADR      r0,|L34.40|
00000e  f7fffffe          BL       rt_assert_handler
                  |L34.18|
;;;559    
;;;560        /* wakeup all suspend threads */
;;;561        rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
000012  f1040014          ADD      r0,r4,#0x14
000016  f7fffffe          BL       rt_ipc_list_resume_all
;;;562    
;;;563        /* detach semaphore object */
;;;564        rt_object_detach(&(mutex->parent.parent));
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_object_detach
;;;565    
;;;566        return RT_EOK;
000020  2000              MOVS     r0,#0
;;;567    }
000022  bd10              POP      {r4,pc}
;;;568    RTM_EXPORT(rt_mutex_detach);
                          ENDP

                  |L34.36|
                          DCD      |symbol_number.136|
                  |L34.40|
000028  6d757465          DCB      "mutex != RT_NULL",0
00002c  7820213d
000030  2052545f
000034  4e554c4c
000038  00      
000039  00                DCB      0
00003a  00                DCB      0
00003b  00                DCB      0

                          AREA ||i.rt_mutex_init||, CODE, READONLY, ALIGN=2

                  rt_mutex_init PROC
;;;524     */
;;;525    rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;526    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;527        RT_ASSERT(mutex != RT_NULL);
000008  b92c              CBNZ     r4,|L35.22|
00000a  f240220f          MOV      r2,#0x20f
00000e  490b              LDR      r1,|L35.60|
000010  a00b              ADR      r0,|L35.64|
000012  f7fffffe          BL       rt_assert_handler
                  |L35.22|
;;;528    
;;;529        /* init object */
;;;530        rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
000016  462a              MOV      r2,r5
000018  2102              MOVS     r1,#2
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_object_init
;;;531    
;;;532        /* init ipc object */
;;;533        rt_ipc_object_init(&(mutex->parent));
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       rt_ipc_object_init
;;;534    
;;;535        mutex->value = 1;
000026  2001              MOVS     r0,#1
000028  83a0              STRH     r0,[r4,#0x1c]
;;;536        mutex->owner = RT_NULL;
00002a  2000              MOVS     r0,#0
00002c  6220              STR      r0,[r4,#0x20]
;;;537        mutex->original_priority = 0xFF;
00002e  20ff              MOVS     r0,#0xff
000030  77a0              STRB     r0,[r4,#0x1e]
;;;538        mutex->hold  = 0;
000032  2000              MOVS     r0,#0
000034  77e0              STRB     r0,[r4,#0x1f]
;;;539    
;;;540        /* set flag */
;;;541        mutex->parent.parent.flag = flag;
000036  7266              STRB     r6,[r4,#9]
;;;542    
;;;543        return RT_EOK;
;;;544    }
000038  bd70              POP      {r4-r6,pc}
;;;545    RTM_EXPORT(rt_mutex_init);
                          ENDP

00003a  0000              DCW      0x0000
                  |L35.60|
                          DCD      |symbol_number.135|
                  |L35.64|
000040  6d757465          DCB      "mutex != RT_NULL",0
000044  7820213d
000048  2052545f
00004c  4e554c4c
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.rt_mutex_release||, CODE, READONLY, ALIGN=2

                  rt_mutex_release PROC
;;;771     */
;;;772    rt_err_t rt_mutex_release(rt_mutex_t mutex)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;773    {
000004  4604              MOV      r4,r0
;;;774        register rt_base_t temp;
;;;775        struct rt_thread *thread;
;;;776        rt_bool_t need_schedule;
;;;777    
;;;778        need_schedule = RT_FALSE;
000006  2600              MOVS     r6,#0
;;;779    
;;;780        /* only thread could release mutex because we need test the ownership */
;;;781        RT_DEBUG_IN_THREAD_CONTEXT;
000008  bf00              NOP      
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4680              MOV      r8,r0
000010  f7fffffe          BL       rt_thread_self
000014  b948              CBNZ     r0,|L36.42|
000016  493c              LDR      r1,|L36.264|
000018  a03c              ADR      r0,|L36.268|
00001a  f7fffffe          BL       rt_kprintf
00001e  f240320d          MOV      r2,#0x30d
000022  4939              LDR      r1,|L36.264|
000024  a047              ADR      r0,|L36.324|
000026  f7fffffe          BL       rt_assert_handler
                  |L36.42|
00002a  bf00              NOP      
00002c  f7fffffe          BL       rt_hw_interrupt_disable
000030  4681              MOV      r9,r0
000032  f7fffffe          BL       rt_interrupt_get_nest
000036  b148              CBZ      r0,|L36.76|
000038  4933              LDR      r1,|L36.264|
00003a  a043              ADR      r0,|L36.328|
00003c  f7fffffe          BL       rt_kprintf
000040  f240320d          MOV      r2,#0x30d
000044  4930              LDR      r1,|L36.264|
000046  a03f              ADR      r0,|L36.324|
000048  f7fffffe          BL       rt_assert_handler
                  |L36.76|
00004c  4648              MOV      r0,r9
00004e  f7fffffe          BL       rt_hw_interrupt_enable
000052  bf00              NOP      
000054  4640              MOV      r0,r8
000056  f7fffffe          BL       rt_hw_interrupt_enable
00005a  bf00              NOP      
;;;782    
;;;783        /* get current thread */
;;;784        thread = rt_thread_self();
00005c  f7fffffe          BL       rt_thread_self
000060  4605              MOV      r5,r0
;;;785    
;;;786        /* disable interrupt */
;;;787        temp = rt_hw_interrupt_disable();
000062  f7fffffe          BL       rt_hw_interrupt_disable
000066  4607              MOV      r7,r0
;;;788    
;;;789        RT_DEBUG_LOG(RT_DEBUG_IPC,
000068  bf00              NOP      
00006a  bf00              NOP      
;;;790                     ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
;;;791                      thread->name, mutex->value, mutex->hold));
;;;792    
;;;793        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
00006c  bf00              NOP      
00006e  483f              LDR      r0,|L36.364|
000070  6800              LDR      r0,[r0,#0]  ; rt_object_put_hook
000072  b118              CBZ      r0,|L36.124|
000074  4620              MOV      r0,r4
000076  493d              LDR      r1,|L36.364|
000078  6809              LDR      r1,[r1,#0]  ; rt_object_put_hook
00007a  4788              BLX      r1
                  |L36.124|
00007c  bf00              NOP      
;;;794    
;;;795        /* mutex only can be released by owner */
;;;796        if (thread != mutex->owner)
00007e  6a20              LDR      r0,[r4,#0x20]
000080  42a8              CMP      r0,r5
000082  d009              BEQ      |L36.152|
;;;797        {
;;;798            thread->error = -RT_ERROR;
000084  f04f30ff          MOV      r0,#0xffffffff
000088  6328              STR      r0,[r5,#0x30]
;;;799    
;;;800            /* enable interrupt */
;;;801            rt_hw_interrupt_enable(temp);
00008a  4638              MOV      r0,r7
00008c  f7fffffe          BL       rt_hw_interrupt_enable
;;;802    
;;;803            return -RT_ERROR;
000090  f04f30ff          MOV      r0,#0xffffffff
                  |L36.148|
;;;804        }
;;;805    
;;;806        /* decrease hold */
;;;807        mutex->hold --;
;;;808        /* if no hold */
;;;809        if (mutex->hold == 0)
;;;810        {
;;;811            /* change the owner thread to original priority */
;;;812            if (mutex->original_priority != mutex->owner->current_priority)
;;;813            {
;;;814                rt_thread_control(mutex->owner,
;;;815                                  RT_THREAD_CTRL_CHANGE_PRIORITY,
;;;816                                  &(mutex->original_priority));
;;;817            }
;;;818    
;;;819            /* wakeup suspended thread */
;;;820            if (!rt_list_isempty(&mutex->parent.suspend_thread))
;;;821            {
;;;822                /* get suspended thread */
;;;823                thread = rt_list_entry(mutex->parent.suspend_thread.next,
;;;824                                       struct rt_thread,
;;;825                                       tlist);
;;;826    
;;;827                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
;;;828                                            thread->name));
;;;829    
;;;830                /* set new owner and priority */
;;;831                mutex->owner             = thread;
;;;832                mutex->original_priority = thread->current_priority;
;;;833                mutex->hold ++;
;;;834    
;;;835                /* resume thread */
;;;836                rt_ipc_list_resume(&(mutex->parent.suspend_thread));
;;;837    
;;;838                need_schedule = RT_TRUE;
;;;839            }
;;;840            else
;;;841            {
;;;842                /* increase value */
;;;843                mutex->value ++;
;;;844    
;;;845                /* clear owner */
;;;846                mutex->owner             = RT_NULL;
;;;847                mutex->original_priority = 0xff;
;;;848            }
;;;849        }
;;;850    
;;;851        /* enable interrupt */
;;;852        rt_hw_interrupt_enable(temp);
;;;853    
;;;854        /* perform a schedule */
;;;855        if (need_schedule == RT_TRUE)
;;;856            rt_schedule();
;;;857    
;;;858        return RT_EOK;
;;;859    }
000094  e8bd87f0          POP      {r4-r10,pc}
                  |L36.152|
000098  7fe0              LDRB     r0,[r4,#0x1f]         ;807
00009a  1e40              SUBS     r0,r0,#1              ;807
00009c  77e0              STRB     r0,[r4,#0x1f]         ;807
00009e  7fe0              LDRB     r0,[r4,#0x1f]         ;809
0000a0  bb08              CBNZ     r0,|L36.230|
0000a2  7fa0              LDRB     r0,[r4,#0x1e]         ;812
0000a4  6a21              LDR      r1,[r4,#0x20]         ;812
0000a6  f8911035          LDRB     r1,[r1,#0x35]         ;812
0000aa  4288              CMP      r0,r1                 ;812
0000ac  d005              BEQ      |L36.186|
0000ae  f104021e          ADD      r2,r4,#0x1e           ;814
0000b2  2102              MOVS     r1,#2                 ;814
0000b4  6a20              LDR      r0,[r4,#0x20]         ;814
0000b6  f7fffffe          BL       rt_thread_control
                  |L36.186|
0000ba  f1040014          ADD      r0,r4,#0x14           ;820
0000be  f7fffffe          BL       rt_list_isempty
0000c2  b988              CBNZ     r0,|L36.232|
0000c4  6960              LDR      r0,[r4,#0x14]         ;823
0000c6  f1a00514          SUB      r5,r0,#0x14           ;823
0000ca  bf00              NOP                            ;827
0000cc  bf00              NOP                            ;827
0000ce  6225              STR      r5,[r4,#0x20]         ;831
0000d0  f8950035          LDRB     r0,[r5,#0x35]         ;832
0000d4  77a0              STRB     r0,[r4,#0x1e]         ;832
0000d6  7fe0              LDRB     r0,[r4,#0x1f]         ;833
0000d8  1c40              ADDS     r0,r0,#1              ;833
0000da  77e0              STRB     r0,[r4,#0x1f]         ;833
0000dc  f1040014          ADD      r0,r4,#0x14           ;836
0000e0  f7fffffe          BL       rt_ipc_list_resume
0000e4  2601              MOVS     r6,#1                 ;838
                  |L36.230|
0000e6  e006              B        |L36.246|
                  |L36.232|
0000e8  8ba0              LDRH     r0,[r4,#0x1c]         ;843
0000ea  1c40              ADDS     r0,r0,#1              ;843
0000ec  83a0              STRH     r0,[r4,#0x1c]         ;843
0000ee  2000              MOVS     r0,#0                 ;846
0000f0  6220              STR      r0,[r4,#0x20]         ;846
0000f2  20ff              MOVS     r0,#0xff              ;847
0000f4  77a0              STRB     r0,[r4,#0x1e]         ;847
                  |L36.246|
0000f6  4638              MOV      r0,r7                 ;852
0000f8  f7fffffe          BL       rt_hw_interrupt_enable
0000fc  2e01              CMP      r6,#1                 ;855
0000fe  d101              BNE      |L36.260|
000100  f7fffffe          BL       rt_schedule
                  |L36.260|
000104  2000              MOVS     r0,#0                 ;858
000106  e7c5              B        |L36.148|
;;;860    RTM_EXPORT(rt_mutex_release);
                          ENDP

                  |L36.264|
                          DCD      |symbol_number.140|
                  |L36.268|
00010c  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
000110  74696f6e
000114  5b25735d
000118  20736861
00011c  6c6c206e
000120  6f742062
000124  65207573
000128  65642062
00012c  65666f72
000130  65207363
000134  68656475
000138  6c657220
00013c  73746172
000140  740a    
000142  00                DCB      0
000143  00                DCB      0
                  |L36.324|
000144  3000              DCB      "0",0
000146  00                DCB      0
000147  00                DCB      0
                  |L36.328|
000148  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00014c  74696f6e
000150  5b25735d
000154  20736861
000158  6c6c206e
00015c  6f742075
000160  73656420
000164  696e2049
000168  53520a00
                  |L36.364|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_mutex_take||, CODE, READONLY, ALIGN=2

                  rt_mutex_take PROC
;;;641     */
;;;642    rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;643    {
000004  4604              MOV      r4,r0
;;;644        register rt_base_t temp;
;;;645        struct rt_thread *thread;
;;;646    
;;;647        /* this function must not be used in interrupt even if time = 0 */
;;;648        RT_DEBUG_IN_THREAD_CONTEXT;
000006  bf00              NOP      
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4607              MOV      r7,r0
00000e  f7fffffe          BL       rt_thread_self
000012  b948              CBNZ     r0,|L37.40|
000014  494d              LDR      r1,|L37.332|
000016  a04e              ADR      r0,|L37.336|
000018  f7fffffe          BL       rt_kprintf
00001c  f44f7222          MOV      r2,#0x288
000020  494a              LDR      r1,|L37.332|
000022  a059              ADR      r0,|L37.392|
000024  f7fffffe          BL       rt_assert_handler
                  |L37.40|
000028  bf00              NOP      
00002a  f7fffffe          BL       rt_hw_interrupt_disable
00002e  4680              MOV      r8,r0
000030  f7fffffe          BL       rt_interrupt_get_nest
000034  b148              CBZ      r0,|L37.74|
000036  4945              LDR      r1,|L37.332|
000038  a054              ADR      r0,|L37.396|
00003a  f7fffffe          BL       rt_kprintf
00003e  f44f7222          MOV      r2,#0x288
000042  4942              LDR      r1,|L37.332|
000044  a050              ADR      r0,|L37.392|
000046  f7fffffe          BL       rt_assert_handler
                  |L37.74|
00004a  4640              MOV      r0,r8
00004c  f7fffffe          BL       rt_hw_interrupt_enable
000050  bf00              NOP      
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       rt_hw_interrupt_enable
000058  bf00              NOP      
;;;649    
;;;650        RT_ASSERT(mutex != RT_NULL);
00005a  b92c              CBNZ     r4,|L37.104|
00005c  f240228a          MOV      r2,#0x28a
000060  493a              LDR      r1,|L37.332|
000062  a053              ADR      r0,|L37.432|
000064  f7fffffe          BL       rt_assert_handler
                  |L37.104|
;;;651    
;;;652        /* disable interrupt */
;;;653        temp = rt_hw_interrupt_disable();
000068  f7fffffe          BL       rt_hw_interrupt_disable
00006c  4606              MOV      r6,r0
;;;654    
;;;655        /* get current thread */
;;;656        thread = rt_thread_self();
00006e  f7fffffe          BL       rt_thread_self
000072  4605              MOV      r5,r0
;;;657    
;;;658        RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
000074  bf00              NOP      
000076  4853              LDR      r0,|L37.452|
000078  6800              LDR      r0,[r0,#0]  ; rt_object_trytake_hook
00007a  b118              CBZ      r0,|L37.132|
00007c  4620              MOV      r0,r4
00007e  4951              LDR      r1,|L37.452|
000080  6809              LDR      r1,[r1,#0]  ; rt_object_trytake_hook
000082  4788              BLX      r1
                  |L37.132|
000084  bf00              NOP      
;;;659    
;;;660        RT_DEBUG_LOG(RT_DEBUG_IPC,
000086  bf00              NOP      
000088  bf00              NOP      
;;;661                     ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
;;;662                      thread->name, mutex->value, mutex->hold));
;;;663    
;;;664        /* reset thread error */
;;;665        thread->error = RT_EOK;
00008a  2000              MOVS     r0,#0
00008c  6328              STR      r0,[r5,#0x30]
;;;666    
;;;667        if (mutex->owner == thread)
00008e  6a20              LDR      r0,[r4,#0x20]
000090  42a8              CMP      r0,r5
000092  d103              BNE      |L37.156|
;;;668        {
;;;669            /* it's the same thread */
;;;670            mutex->hold ++;
000094  7fe0              LDRB     r0,[r4,#0x1f]
000096  1c40              ADDS     r0,r0,#1
000098  77e0              STRB     r0,[r4,#0x1f]
00009a  e049              B        |L37.304|
                  |L37.156|
;;;671        }
;;;672        else
;;;673        {
;;;674            /* The value of mutex is 1 in initial status. Therefore, if the
;;;675             * value is great than 0, it indicates the mutex is avaible.
;;;676             */
;;;677            if (mutex->value > 0)
00009c  8ba0              LDRH     r0,[r4,#0x1c]
00009e  2800              CMP      r0,#0
0000a0  dd0a              BLE      |L37.184|
;;;678            {
;;;679                /* mutex is available */
;;;680                mutex->value --;
0000a2  8ba0              LDRH     r0,[r4,#0x1c]
0000a4  1e40              SUBS     r0,r0,#1
0000a6  83a0              STRH     r0,[r4,#0x1c]
;;;681    
;;;682                /* set mutex owner and original priority */
;;;683                mutex->owner             = thread;
0000a8  6225              STR      r5,[r4,#0x20]
;;;684                mutex->original_priority = thread->current_priority;
0000aa  f8950035          LDRB     r0,[r5,#0x35]
0000ae  77a0              STRB     r0,[r4,#0x1e]
;;;685                mutex->hold ++;
0000b0  7fe0              LDRB     r0,[r4,#0x1f]
0000b2  1c40              ADDS     r0,r0,#1
0000b4  77e0              STRB     r0,[r4,#0x1f]
0000b6  e03b              B        |L37.304|
                  |L37.184|
;;;686            }
;;;687            else
;;;688            {
;;;689                /* no waiting, return with timeout */
;;;690                if (time == 0)
0000b8  9801              LDR      r0,[sp,#4]
0000ba  b948              CBNZ     r0,|L37.208|
;;;691                {
;;;692                    /* set error as timeout */
;;;693                    thread->error = -RT_ETIMEOUT;
0000bc  f06f0001          MVN      r0,#1
0000c0  6328              STR      r0,[r5,#0x30]
;;;694    
;;;695                    /* enable interrupt */
;;;696                    rt_hw_interrupt_enable(temp);
0000c2  4630              MOV      r0,r6
0000c4  f7fffffe          BL       rt_hw_interrupt_enable
;;;697    
;;;698                    return -RT_ETIMEOUT;
0000c8  f06f0001          MVN      r0,#1
                  |L37.204|
;;;699                }
;;;700                else
;;;701                {
;;;702                    /* mutex is unavailable, push to suspend list */
;;;703                    RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
;;;704                                                thread->name));
;;;705    
;;;706                    /* change the owner thread priority of mutex */
;;;707                    if (thread->current_priority < mutex->owner->current_priority)
;;;708                    {
;;;709                        /* change the owner thread priority */
;;;710                        rt_thread_control(mutex->owner,
;;;711                                          RT_THREAD_CTRL_CHANGE_PRIORITY,
;;;712                                          &thread->current_priority);
;;;713                    }
;;;714    
;;;715                    /* suspend current thread */
;;;716                    rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
;;;717                                        thread,
;;;718                                        mutex->parent.parent.flag);
;;;719    
;;;720                    /* has waiting time, start thread timer */
;;;721                    if (time > 0)
;;;722                    {
;;;723                        RT_DEBUG_LOG(RT_DEBUG_IPC,
;;;724                                     ("mutex_take: start the timer of thread:%s\n",
;;;725                                      thread->name));
;;;726    
;;;727                        /* reset the timeout of thread timer and start it */
;;;728                        rt_timer_control(&(thread->thread_timer),
;;;729                                         RT_TIMER_CTRL_SET_TIME,
;;;730                                         &time);
;;;731                        rt_timer_start(&(thread->thread_timer));
;;;732                    }
;;;733    
;;;734                    /* enable interrupt */
;;;735                    rt_hw_interrupt_enable(temp);
;;;736    
;;;737                    /* do schedule */
;;;738                    rt_schedule();
;;;739    
;;;740                    if (thread->error != RT_EOK)
;;;741                    {
;;;742                        /* return error */
;;;743                        return thread->error;
;;;744                    }
;;;745                    else
;;;746                    {
;;;747                        /* the mutex is taken successfully. */
;;;748                        /* disable interrupt */
;;;749                        temp = rt_hw_interrupt_disable();
;;;750                    }
;;;751                }
;;;752            }
;;;753        }
;;;754    
;;;755        /* enable interrupt */
;;;756        rt_hw_interrupt_enable(temp);
;;;757    
;;;758        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
;;;759    
;;;760        return RT_EOK;
;;;761    }
0000cc  e8bd81fc          POP      {r2-r8,pc}
                  |L37.208|
0000d0  bf00              NOP                            ;703
0000d2  bf00              NOP                            ;703
0000d4  f8950035          LDRB     r0,[r5,#0x35]         ;707
0000d8  6a21              LDR      r1,[r4,#0x20]         ;707
0000da  f8911035          LDRB     r1,[r1,#0x35]         ;707
0000de  4288              CMP      r0,r1                 ;707
0000e0  da05              BGE      |L37.238|
0000e2  f1050235          ADD      r2,r5,#0x35           ;710
0000e6  2102              MOVS     r1,#2                 ;710
0000e8  6a20              LDR      r0,[r4,#0x20]         ;710
0000ea  f7fffffe          BL       rt_thread_control
                  |L37.238|
0000ee  7a62              LDRB     r2,[r4,#9]            ;716
0000f0  4629              MOV      r1,r5                 ;716
0000f2  f1040014          ADD      r0,r4,#0x14           ;716
0000f6  f7fffffe          BL       rt_ipc_list_suspend
0000fa  9801              LDR      r0,[sp,#4]            ;721
0000fc  2800              CMP      r0,#0                 ;721
0000fe  dd0b              BLE      |L37.280|
000100  bf00              NOP                            ;723
000102  bf00              NOP                            ;723
000104  aa01              ADD      r2,sp,#4              ;728
000106  2100              MOVS     r1,#0                 ;728
000108  f105004c          ADD      r0,r5,#0x4c           ;728
00010c  f7fffffe          BL       rt_timer_control
000110  f105004c          ADD      r0,r5,#0x4c           ;731
000114  f7fffffe          BL       rt_timer_start
                  |L37.280|
000118  4630              MOV      r0,r6                 ;735
00011a  f7fffffe          BL       rt_hw_interrupt_enable
00011e  f7fffffe          BL       rt_schedule
000122  6b28              LDR      r0,[r5,#0x30]         ;740
000124  b108              CBZ      r0,|L37.298|
000126  6b28              LDR      r0,[r5,#0x30]         ;743
000128  e7d0              B        |L37.204|
                  |L37.298|
00012a  f7fffffe          BL       rt_hw_interrupt_disable
00012e  4606              MOV      r6,r0                 ;749
                  |L37.304|
000130  4630              MOV      r0,r6                 ;756
000132  f7fffffe          BL       rt_hw_interrupt_enable
000136  bf00              NOP                            ;758
000138  4823              LDR      r0,|L37.456|
00013a  6800              LDR      r0,[r0,#0]            ;758  ; rt_object_take_hook
00013c  b118              CBZ      r0,|L37.326|
00013e  4620              MOV      r0,r4                 ;758
000140  4921              LDR      r1,|L37.456|
000142  6809              LDR      r1,[r1,#0]            ;758  ; rt_object_take_hook
000144  4788              BLX      r1                    ;758
                  |L37.326|
000146  bf00              NOP                            ;758
000148  2000              MOVS     r0,#0                 ;760
00014a  e7bf              B        |L37.204|
;;;762    RTM_EXPORT(rt_mutex_take);
                          ENDP

                  |L37.332|
                          DCD      |symbol_number.139|
                  |L37.336|
000150  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
000154  74696f6e
000158  5b25735d
00015c  20736861
000160  6c6c206e
000164  6f742062
000168  65207573
00016c  65642062
000170  65666f72
000174  65207363
000178  68656475
00017c  6c657220
000180  73746172
000184  740a    
000186  00                DCB      0
000187  00                DCB      0
                  |L37.392|
000188  3000              DCB      "0",0
00018a  00                DCB      0
00018b  00                DCB      0
                  |L37.396|
00018c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000190  74696f6e
000194  5b25735d
000198  20736861
00019c  6c6c206e
0001a0  6f742075
0001a4  73656420
0001a8  696e2049
0001ac  53520a00
                  |L37.432|
0001b0  6d757465          DCB      "mutex != RT_NULL",0
0001b4  7820213d
0001b8  2052545f
0001bc  4e554c4c
0001c0  00      
0001c1  00                DCB      0
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L37.452|
                          DCD      rt_object_trytake_hook
                  |L37.456|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_sem_control||, CODE, READONLY, ALIGN=2

                  rt_sem_control PROC
;;;480     */
;;;481    rt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;482    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;483        rt_ubase_t level;
;;;484        RT_ASSERT(sem != RT_NULL);
00000a  b92c              CBNZ     r4,|L38.24|
00000c  f44f72f2          MOV      r2,#0x1e4
000010  490c              LDR      r1,|L38.68|
000012  a00d              ADR      r0,|L38.72|
000014  f7fffffe          BL       rt_assert_handler
                  |L38.24|
;;;485    
;;;486        if (cmd == RT_IPC_CMD_RESET)
000018  2e01              CMP      r6,#1
00001a  d110              BNE      |L38.62|
;;;487        {
;;;488            rt_uint32_t value;
;;;489    
;;;490            /* get value */
;;;491            value = (rt_uint32_t)arg;
00001c  462f              MOV      r7,r5
;;;492            /* disable interrupt */
;;;493            level = rt_hw_interrupt_disable();
00001e  f7fffffe          BL       rt_hw_interrupt_disable
000022  4680              MOV      r8,r0
;;;494    
;;;495            /* resume all waiting thread */
;;;496            rt_ipc_list_resume_all(&sem->parent.suspend_thread);
000024  f1040014          ADD      r0,r4,#0x14
000028  f7fffffe          BL       rt_ipc_list_resume_all
;;;497    
;;;498            /* set new value */
;;;499            sem->value = (rt_uint16_t)value;
00002c  83a7              STRH     r7,[r4,#0x1c]
;;;500    
;;;501            /* enable interrupt */
;;;502            rt_hw_interrupt_enable(level);
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       rt_hw_interrupt_enable
;;;503    
;;;504            rt_schedule();
000034  f7fffffe          BL       rt_schedule
;;;505    
;;;506            return RT_EOK;
000038  2000              MOVS     r0,#0
                  |L38.58|
;;;507        }
;;;508    
;;;509        return -RT_ERROR;
;;;510    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L38.62|
00003e  f04f30ff          MOV      r0,#0xffffffff        ;509
000042  e7fa              B        |L38.58|
;;;511    RTM_EXPORT(rt_sem_control);
                          ENDP

                  |L38.68|
                          DCD      |symbol_number.134|
                  |L38.72|
000048  73656d20          DCB      "sem != RT_NULL",0
00004c  213d2052
000050  545f4e55
000054  4c4c00  
000057  00                DCB      0

                          AREA ||i.rt_sem_create||, CODE, READONLY, ALIGN=2

                  rt_sem_create PROC
;;;268     */
;;;269    rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;270    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;271        rt_sem_t sem;
;;;272    
;;;273        RT_DEBUG_NOT_IN_INTERRUPT;
00000a  bf00              NOP      
00000c  f7fffffe          BL       rt_hw_interrupt_disable
000010  4680              MOV      r8,r0
000012  f7fffffe          BL       rt_interrupt_get_nest
000016  b148              CBZ      r0,|L39.44|
000018  490e              LDR      r1,|L39.84|
00001a  a00f              ADR      r0,|L39.88|
00001c  f7fffffe          BL       rt_kprintf
000020  f2401211          MOV      r2,#0x111
000024  490b              LDR      r1,|L39.84|
000026  a015              ADR      r0,|L39.124|
000028  f7fffffe          BL       rt_assert_handler
                  |L39.44|
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       rt_hw_interrupt_enable
000032  bf00              NOP      
;;;274    
;;;275        /* allocate object */
;;;276        sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
000034  4629              MOV      r1,r5
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       rt_object_allocate
00003c  4604              MOV      r4,r0
;;;277        if (sem == RT_NULL)
00003e  b914              CBNZ     r4,|L39.70|
;;;278            return sem;
000040  4620              MOV      r0,r4
                  |L39.66|
;;;279    
;;;280        /* init ipc object */
;;;281        rt_ipc_object_init(&(sem->parent));
;;;282    
;;;283        /* set init value */
;;;284        sem->value = value;
;;;285    
;;;286        /* set parent */
;;;287        sem->parent.parent.flag = flag;
;;;288    
;;;289        return sem;
;;;290    }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L39.70|
000046  4620              MOV      r0,r4                 ;281
000048  f7fffffe          BL       rt_ipc_object_init
00004c  83a6              STRH     r6,[r4,#0x1c]         ;284
00004e  7267              STRB     r7,[r4,#9]            ;287
000050  4620              MOV      r0,r4                 ;289
000052  e7f6              B        |L39.66|
;;;291    RTM_EXPORT(rt_sem_create);
                          ENDP

                  |L39.84|
                          DCD      |symbol_number.131|
                  |L39.88|
000058  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00005c  74696f6e
000060  5b25735d
000064  20736861
000068  6c6c206e
00006c  6f742075
000070  73656420
000074  696e2049
000078  53520a00
                  |L39.124|
00007c  3000              DCB      "0",0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.rt_sem_delete||, CODE, READONLY, ALIGN=2

                  rt_sem_delete PROC
;;;301     */
;;;302    rt_err_t rt_sem_delete(rt_sem_t sem)
000000  b570              PUSH     {r4-r6,lr}
;;;303    {
000002  4604              MOV      r4,r0
;;;304        RT_DEBUG_NOT_IN_INTERRUPT;
000004  bf00              NOP      
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  b148              CBZ      r0,|L40.38|
000012  490f              LDR      r1,|L40.80|
000014  a00f              ADR      r0,|L40.84|
000016  f7fffffe          BL       rt_kprintf
00001a  f44f7298          MOV      r2,#0x130
00001e  490c              LDR      r1,|L40.80|
000020  a015              ADR      r0,|L40.120|
000022  f7fffffe          BL       rt_assert_handler
                  |L40.38|
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       rt_hw_interrupt_enable
00002c  bf00              NOP      
;;;305    
;;;306        RT_ASSERT(sem != RT_NULL);
00002e  b92c              CBNZ     r4,|L40.60|
000030  f44f7299          MOV      r2,#0x132
000034  4906              LDR      r1,|L40.80|
000036  a011              ADR      r0,|L40.124|
000038  f7fffffe          BL       rt_assert_handler
                  |L40.60|
;;;307    
;;;308        /* wakeup all suspend threads */
;;;309        rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
00003c  f1040014          ADD      r0,r4,#0x14
000040  f7fffffe          BL       rt_ipc_list_resume_all
;;;310    
;;;311        /* delete semaphore object */
;;;312        rt_object_delete(&(sem->parent.parent));
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       rt_object_delete
;;;313    
;;;314        return RT_EOK;
00004a  2000              MOVS     r0,#0
;;;315    }
00004c  bd70              POP      {r4-r6,pc}
;;;316    RTM_EXPORT(rt_sem_delete);
                          ENDP

00004e  0000              DCW      0x0000
                  |L40.80|
                          DCD      |symbol_number.132|
                  |L40.84|
000054  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000058  74696f6e
00005c  5b25735d
000060  20736861
000064  6c6c206e
000068  6f742075
00006c  73656420
000070  696e2049
000074  53520a00
                  |L40.120|
000078  3000              DCB      "0",0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L40.124|
00007c  73656d20          DCB      "sem != RT_NULL",0
000080  213d2052
000084  545f4e55
000088  4c4c00  
00008b  00                DCB      0

                          AREA ||i.rt_sem_detach||, CODE, READONLY, ALIGN=2

                  rt_sem_detach PROC
;;;242     */
;;;243    rt_err_t rt_sem_detach(rt_sem_t sem)
000000  b510              PUSH     {r4,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245        RT_ASSERT(sem != RT_NULL);
000004  b924              CBNZ     r4,|L41.16|
000006  22f5              MOVS     r2,#0xf5
000008  4906              LDR      r1,|L41.36|
00000a  a007              ADR      r0,|L41.40|
00000c  f7fffffe          BL       rt_assert_handler
                  |L41.16|
;;;246    
;;;247        /* wakeup all suspend threads */
;;;248        rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
000010  f1040014          ADD      r0,r4,#0x14
000014  f7fffffe          BL       rt_ipc_list_resume_all
;;;249    
;;;250        /* detach semaphore object */
;;;251        rt_object_detach(&(sem->parent.parent));
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_object_detach
;;;252    
;;;253        return RT_EOK;
00001e  2000              MOVS     r0,#0
;;;254    }
000020  bd10              POP      {r4,pc}
;;;255    RTM_EXPORT(rt_sem_detach);
                          ENDP

000022  0000              DCW      0x0000
                  |L41.36|
                          DCD      |symbol_number.130|
                  |L41.40|
000028  73656d20          DCB      "sem != RT_NULL",0
00002c  213d2052
000030  545f4e55
000034  4c4c00  
000037  00                DCB      0

                          AREA ||i.rt_sem_init||, CODE, READONLY, ALIGN=2

                  rt_sem_init PROC
;;;210     */
;;;211    rt_err_t rt_sem_init(rt_sem_t    sem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;212                         const char *name,
;;;213                         rt_uint32_t value,
;;;214                         rt_uint8_t  flag)
;;;215    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;216        RT_ASSERT(sem != RT_NULL);
00000c  b924              CBNZ     r4,|L42.24|
00000e  22d8              MOVS     r2,#0xd8
000010  4908              LDR      r1,|L42.52|
000012  a009              ADR      r0,|L42.56|
000014  f7fffffe          BL       rt_assert_handler
                  |L42.24|
;;;217    
;;;218        /* init object */
;;;219        rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
000018  462a              MOV      r2,r5
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       rt_object_init
;;;220    
;;;221        /* init ipc object */
;;;222        rt_ipc_object_init(&(sem->parent));
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_ipc_object_init
;;;223    
;;;224        /* set init value */
;;;225        sem->value = value;
000028  83a6              STRH     r6,[r4,#0x1c]
;;;226    
;;;227        /* set parent */
;;;228        sem->parent.parent.flag = flag;
00002a  7267              STRB     r7,[r4,#9]
;;;229    
;;;230        return RT_EOK;
00002c  2000              MOVS     r0,#0
;;;231    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;232    RTM_EXPORT(rt_sem_init);
                          ENDP

000032  0000              DCW      0x0000
                  |L42.52|
                          DCD      __FUNCTION__
                  |L42.56|
000038  73656d20          DCB      "sem != RT_NULL",0
00003c  213d2052
000040  545f4e55
000044  4c4c00  
000047  00                DCB      0

                          AREA ||i.rt_sem_release||, CODE, READONLY, ALIGN=2

                  rt_sem_release PROC
;;;434     */
;;;435    rt_err_t rt_sem_release(rt_sem_t sem)
000000  b570              PUSH     {r4-r6,lr}
;;;436    {
000002  4604              MOV      r4,r0
;;;437        register rt_base_t temp;
;;;438        register rt_bool_t need_schedule;
;;;439    
;;;440        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
000004  bf00              NOP      
000006  4812              LDR      r0,|L43.80|
000008  6800              LDR      r0,[r0,#0]  ; rt_object_put_hook
00000a  b118              CBZ      r0,|L43.20|
00000c  4620              MOV      r0,r4
00000e  4910              LDR      r1,|L43.80|
000010  6809              LDR      r1,[r1,#0]  ; rt_object_put_hook
000012  4788              BLX      r1
                  |L43.20|
000014  bf00              NOP      
;;;441    
;;;442        need_schedule = RT_FALSE;
000016  2500              MOVS     r5,#0
;;;443    
;;;444        /* disable interrupt */
;;;445        temp = rt_hw_interrupt_disable();
000018  f7fffffe          BL       rt_hw_interrupt_disable
00001c  4606              MOV      r6,r0
;;;446    
;;;447        RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
00001e  bf00              NOP      
000020  bf00              NOP      
;;;448                                    rt_thread_self()->name,
;;;449                                    ((struct rt_object *)sem)->name,
;;;450                                    sem->value));
;;;451    
;;;452        if (!rt_list_isempty(&sem->parent.suspend_thread))
000022  f1040014          ADD      r0,r4,#0x14
000026  f7fffffe          BL       rt_list_isempty
00002a  b928              CBNZ     r0,|L43.56|
;;;453        {
;;;454            /* resume the suspended thread */
;;;455            rt_ipc_list_resume(&(sem->parent.suspend_thread));
00002c  f1040014          ADD      r0,r4,#0x14
000030  f7fffffe          BL       rt_ipc_list_resume
;;;456            need_schedule = RT_TRUE;
000034  2501              MOVS     r5,#1
000036  e002              B        |L43.62|
                  |L43.56|
;;;457        }
;;;458        else
;;;459            sem->value ++; /* increase value */
000038  8ba0              LDRH     r0,[r4,#0x1c]
00003a  1c40              ADDS     r0,r0,#1
00003c  83a0              STRH     r0,[r4,#0x1c]
                  |L43.62|
;;;460    
;;;461        /* enable interrupt */
;;;462        rt_hw_interrupt_enable(temp);
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       rt_hw_interrupt_enable
;;;463    
;;;464        /* resume a thread, re-schedule */
;;;465        if (need_schedule == RT_TRUE)
000044  2d01              CMP      r5,#1
000046  d101              BNE      |L43.76|
;;;466            rt_schedule();
000048  f7fffffe          BL       rt_schedule
                  |L43.76|
;;;467    
;;;468        return RT_EOK;
00004c  2000              MOVS     r0,#0
;;;469    }
00004e  bd70              POP      {r4-r6,pc}
;;;470    RTM_EXPORT(rt_sem_release);
                          ENDP

                  |L43.80|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_sem_take||, CODE, READONLY, ALIGN=2

                  rt_sem_take PROC
;;;327     */
;;;328    rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;329    {
000004  4605              MOV      r5,r0
;;;330        register rt_base_t temp;
;;;331        struct rt_thread *thread;
;;;332    
;;;333        RT_ASSERT(sem != RT_NULL);
000006  b92d              CBNZ     r5,|L44.20|
000008  f240124d          MOV      r2,#0x14d
00000c  493f              LDR      r1,|L44.268|
00000e  a040              ADR      r0,|L44.272|
000010  f7fffffe          BL       rt_assert_handler
                  |L44.20|
;;;334    
;;;335        RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
000014  bf00              NOP      
000016  4842              LDR      r0,|L44.288|
000018  6800              LDR      r0,[r0,#0]  ; rt_object_trytake_hook
00001a  b118              CBZ      r0,|L44.36|
00001c  4628              MOV      r0,r5
00001e  4940              LDR      r1,|L44.288|
000020  6809              LDR      r1,[r1,#0]  ; rt_object_trytake_hook
000022  4788              BLX      r1
                  |L44.36|
000024  bf00              NOP      
;;;336    
;;;337        /* disable interrupt */
;;;338        temp = rt_hw_interrupt_disable();
000026  f7fffffe          BL       rt_hw_interrupt_disable
00002a  4606              MOV      r6,r0
;;;339    
;;;340        RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;341                                    rt_thread_self()->name,
;;;342                                    ((struct rt_object *)sem)->name,
;;;343                                    sem->value));
;;;344    
;;;345        if (sem->value > 0)
000030  8ba8              LDRH     r0,[r5,#0x1c]
000032  2800              CMP      r0,#0
000034  dd06              BLE      |L44.68|
;;;346        {
;;;347            /* semaphore is available */
;;;348            sem->value --;
000036  8ba8              LDRH     r0,[r5,#0x1c]
000038  1e40              SUBS     r0,r0,#1
00003a  83a8              STRH     r0,[r5,#0x1c]
;;;349    
;;;350            /* enable interrupt */
;;;351            rt_hw_interrupt_enable(temp);
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       rt_hw_interrupt_enable
000042  e057              B        |L44.244|
                  |L44.68|
;;;352        }
;;;353        else
;;;354        {
;;;355            /* no waiting, return with timeout */
;;;356            if (time == 0)
000044  9801              LDR      r0,[sp,#4]
000046  b930              CBNZ     r0,|L44.86|
;;;357            {
;;;358                rt_hw_interrupt_enable(temp);
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       rt_hw_interrupt_enable
;;;359    
;;;360                return -RT_ETIMEOUT;
00004e  f06f0001          MVN      r0,#1
                  |L44.82|
;;;361            }
;;;362            else
;;;363            {
;;;364                /* current context checking */
;;;365                RT_DEBUG_IN_THREAD_CONTEXT;
;;;366    
;;;367                /* semaphore is unavailable, push to suspend list */
;;;368                /* get current thread */
;;;369                thread = rt_thread_self();
;;;370    
;;;371                /* reset thread error number */
;;;372                thread->error = RT_EOK;
;;;373    
;;;374                RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
;;;375                                            thread->name));
;;;376    
;;;377                /* suspend thread */
;;;378                rt_ipc_list_suspend(&(sem->parent.suspend_thread),
;;;379                                    thread,
;;;380                                    sem->parent.parent.flag);
;;;381    
;;;382                /* has waiting time, start thread timer */
;;;383                if (time > 0)
;;;384                {
;;;385                    RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
;;;386                                                thread->name));
;;;387    
;;;388                    /* reset the timeout of thread timer and start it */
;;;389                    rt_timer_control(&(thread->thread_timer),
;;;390                                     RT_TIMER_CTRL_SET_TIME,
;;;391                                     &time);
;;;392                    rt_timer_start(&(thread->thread_timer));
;;;393                }
;;;394    
;;;395                /* enable interrupt */
;;;396                rt_hw_interrupt_enable(temp);
;;;397    
;;;398                /* do schedule */
;;;399                rt_schedule();
;;;400    
;;;401                if (thread->error != RT_EOK)
;;;402                {
;;;403                    return thread->error;
;;;404                }
;;;405            }
;;;406        }
;;;407    
;;;408        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
;;;409    
;;;410        return RT_EOK;
;;;411    }
000052  e8bd81fc          POP      {r2-r8,pc}
                  |L44.86|
000056  bf00              NOP                            ;365
000058  f7fffffe          BL       rt_hw_interrupt_disable
00005c  4607              MOV      r7,r0                 ;365
00005e  f7fffffe          BL       rt_thread_self
000062  b948              CBNZ     r0,|L44.120|
000064  4929              LDR      r1,|L44.268|
000066  a02f              ADR      r0,|L44.292|
000068  f7fffffe          BL       rt_kprintf
00006c  f240126d          MOV      r2,#0x16d             ;365
000070  4926              LDR      r1,|L44.268|
000072  a03a              ADR      r0,|L44.348|
000074  f7fffffe          BL       rt_assert_handler
                  |L44.120|
000078  bf00              NOP                            ;365
00007a  f7fffffe          BL       rt_hw_interrupt_disable
00007e  4680              MOV      r8,r0                 ;365
000080  f7fffffe          BL       rt_interrupt_get_nest
000084  b148              CBZ      r0,|L44.154|
000086  4921              LDR      r1,|L44.268|
000088  a035              ADR      r0,|L44.352|
00008a  f7fffffe          BL       rt_kprintf
00008e  f240126d          MOV      r2,#0x16d             ;365
000092  491e              LDR      r1,|L44.268|
000094  a031              ADR      r0,|L44.348|
000096  f7fffffe          BL       rt_assert_handler
                  |L44.154|
00009a  4640              MOV      r0,r8                 ;365
00009c  f7fffffe          BL       rt_hw_interrupt_enable
0000a0  bf00              NOP                            ;365
0000a2  4638              MOV      r0,r7                 ;365
0000a4  f7fffffe          BL       rt_hw_interrupt_enable
0000a8  bf00              NOP                            ;365
0000aa  f7fffffe          BL       rt_thread_self
0000ae  4604              MOV      r4,r0                 ;369
0000b0  2000              MOVS     r0,#0                 ;372
0000b2  6320              STR      r0,[r4,#0x30]         ;372
0000b4  bf00              NOP                            ;374
0000b6  bf00              NOP                            ;374
0000b8  7a6a              LDRB     r2,[r5,#9]            ;378
0000ba  4621              MOV      r1,r4                 ;378
0000bc  f1050014          ADD      r0,r5,#0x14           ;378
0000c0  f7fffffe          BL       rt_ipc_list_suspend
0000c4  9801              LDR      r0,[sp,#4]            ;383
0000c6  2800              CMP      r0,#0                 ;383
0000c8  dd0b              BLE      |L44.226|
0000ca  bf00              NOP                            ;385
0000cc  bf00              NOP                            ;385
0000ce  aa01              ADD      r2,sp,#4              ;389
0000d0  2100              MOVS     r1,#0                 ;389
0000d2  f104004c          ADD      r0,r4,#0x4c           ;389
0000d6  f7fffffe          BL       rt_timer_control
0000da  f104004c          ADD      r0,r4,#0x4c           ;392
0000de  f7fffffe          BL       rt_timer_start
                  |L44.226|
0000e2  4630              MOV      r0,r6                 ;396
0000e4  f7fffffe          BL       rt_hw_interrupt_enable
0000e8  f7fffffe          BL       rt_schedule
0000ec  6b20              LDR      r0,[r4,#0x30]         ;401
0000ee  b108              CBZ      r0,|L44.244|
0000f0  6b20              LDR      r0,[r4,#0x30]         ;403
0000f2  e7ae              B        |L44.82|
                  |L44.244|
0000f4  bf00              NOP                            ;408
0000f6  4823              LDR      r0,|L44.388|
0000f8  6800              LDR      r0,[r0,#0]            ;408  ; rt_object_take_hook
0000fa  b118              CBZ      r0,|L44.260|
0000fc  4628              MOV      r0,r5                 ;408
0000fe  4921              LDR      r1,|L44.388|
000100  6809              LDR      r1,[r1,#0]            ;408  ; rt_object_take_hook
000102  4788              BLX      r1                    ;408
                  |L44.260|
000104  bf00              NOP                            ;408
000106  2000              MOVS     r0,#0                 ;410
000108  e7a3              B        |L44.82|
;;;412    RTM_EXPORT(rt_sem_take);
                          ENDP

00010a  0000              DCW      0x0000
                  |L44.268|
                          DCD      |symbol_number.133|
                  |L44.272|
000110  73656d20          DCB      "sem != RT_NULL",0
000114  213d2052
000118  545f4e55
00011c  4c4c00  
00011f  00                DCB      0
                  |L44.288|
                          DCD      rt_object_trytake_hook
                  |L44.292|
000124  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
000128  74696f6e
00012c  5b25735d
000130  20736861
000134  6c6c206e
000138  6f742062
00013c  65207573
000140  65642062
000144  65666f72
000148  65207363
00014c  68656475
000150  6c657220
000154  73746172
000158  740a    
00015a  00                DCB      0
00015b  00                DCB      0
                  |L44.348|
00015c  3000              DCB      "0",0
00015e  00                DCB      0
00015f  00                DCB      0
                  |L44.352|
000160  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000164  74696f6e
000168  5b25735d
00016c  20736861
000170  6c6c206e
000174  6f742075
000178  73656420
00017c  696e2049
000180  53520a00
                  |L44.388|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_sem_trytake||, CODE, READONLY, ALIGN=1

                  rt_sem_trytake PROC
;;;420     */
;;;421    rt_err_t rt_sem_trytake(rt_sem_t sem)
000000  b510              PUSH     {r4,lr}
;;;422    {
000002  4604              MOV      r4,r0
;;;423        return rt_sem_take(sem, 0);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       rt_sem_take
;;;424    }
00000c  bd10              POP      {r4,pc}
;;;425    RTM_EXPORT(rt_sem_trytake);
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f73          DCB      0x72,0x74,0x5f,0x73
000004  656d5f69          DCB      0x65,0x6d,0x5f,0x69
000008  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.130|
00000c  72745f73          DCB      0x72,0x74,0x5f,0x73
000010  656d5f64          DCB      0x65,0x6d,0x5f,0x64
000014  65746163          DCB      0x65,0x74,0x61,0x63
000018  6800              DCB      0x68,0x00
                  |symbol_number.131|
00001a  7274              DCB      0x72,0x74
00001c  5f73656d          DCB      0x5f,0x73,0x65,0x6d
000020  5f637265          DCB      0x5f,0x63,0x72,0x65
000024  61746500          DCB      0x61,0x74,0x65,0x00
                  |symbol_number.132|
000028  72745f73          DCB      0x72,0x74,0x5f,0x73
00002c  656d5f64          DCB      0x65,0x6d,0x5f,0x64
000030  656c6574          DCB      0x65,0x6c,0x65,0x74
000034  6500              DCB      0x65,0x00
                  |symbol_number.133|
000036  7274              DCB      0x72,0x74
000038  5f73656d          DCB      0x5f,0x73,0x65,0x6d
00003c  5f74616b          DCB      0x5f,0x74,0x61,0x6b
000040  6500              DCB      0x65,0x00
                  |symbol_number.134|
000042  7274              DCB      0x72,0x74
000044  5f73656d          DCB      0x5f,0x73,0x65,0x6d
000048  5f636f6e          DCB      0x5f,0x63,0x6f,0x6e
00004c  74726f6c          DCB      0x74,0x72,0x6f,0x6c
000050  00                DCB      0x00
                  |symbol_number.135|
000051  72745f            DCB      0x72,0x74,0x5f
000054  6d757465          DCB      0x6d,0x75,0x74,0x65
000058  785f696e          DCB      0x78,0x5f,0x69,0x6e
00005c  697400            DCB      0x69,0x74,0x00
                  |symbol_number.136|
00005f  72                DCB      0x72
000060  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000064  7465785f          DCB      0x74,0x65,0x78,0x5f
000068  64657461          DCB      0x64,0x65,0x74,0x61
00006c  636800            DCB      0x63,0x68,0x00
                  |symbol_number.137|
00006f  72                DCB      0x72
000070  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000074  7465785f          DCB      0x74,0x65,0x78,0x5f
000078  63726561          DCB      0x63,0x72,0x65,0x61
00007c  746500            DCB      0x74,0x65,0x00
                  |symbol_number.138|
00007f  72                DCB      0x72
000080  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000084  7465785f          DCB      0x74,0x65,0x78,0x5f
000088  64656c65          DCB      0x64,0x65,0x6c,0x65
00008c  746500            DCB      0x74,0x65,0x00
                  |symbol_number.139|
00008f  72                DCB      0x72
000090  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000094  7465785f          DCB      0x74,0x65,0x78,0x5f
000098  74616b65          DCB      0x74,0x61,0x6b,0x65
00009c  00                DCB      0x00
                  |symbol_number.140|
00009d  72745f            DCB      0x72,0x74,0x5f
0000a0  6d757465          DCB      0x6d,0x75,0x74,0x65
0000a4  785f7265          DCB      0x78,0x5f,0x72,0x65
0000a8  6c656173          DCB      0x6c,0x65,0x61,0x73
0000ac  6500              DCB      0x65,0x00
                  |symbol_number.141|
0000ae  7274              DCB      0x72,0x74
0000b0  5f657665          DCB      0x5f,0x65,0x76,0x65
0000b4  6e745f69          DCB      0x6e,0x74,0x5f,0x69
0000b8  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.142|
0000bc  72745f65          DCB      0x72,0x74,0x5f,0x65
0000c0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000c4  5f646574          DCB      0x5f,0x64,0x65,0x74
0000c8  61636800          DCB      0x61,0x63,0x68,0x00
                  |symbol_number.143|
0000cc  72745f65          DCB      0x72,0x74,0x5f,0x65
0000d0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000d4  5f637265          DCB      0x5f,0x63,0x72,0x65
0000d8  61746500          DCB      0x61,0x74,0x65,0x00
                  |symbol_number.144|
0000dc  72745f65          DCB      0x72,0x74,0x5f,0x65
0000e0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000e4  5f64656c          DCB      0x5f,0x64,0x65,0x6c
0000e8  65746500          DCB      0x65,0x74,0x65,0x00
                  |symbol_number.145|
0000ec  72745f65          DCB      0x72,0x74,0x5f,0x65
0000f0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000f4  5f73656e          DCB      0x5f,0x73,0x65,0x6e
0000f8  6400              DCB      0x64,0x00
                  |symbol_number.146|
0000fa  7274              DCB      0x72,0x74
0000fc  5f657665          DCB      0x5f,0x65,0x76,0x65
000100  6e745f72          DCB      0x6e,0x74,0x5f,0x72
000104  65637600          DCB      0x65,0x63,0x76,0x00
                  |symbol_number.147|
000108  72745f65          DCB      0x72,0x74,0x5f,0x65
00010c  76656e74          DCB      0x76,0x65,0x6e,0x74
000110  5f636f6e          DCB      0x5f,0x63,0x6f,0x6e
000114  74726f6c          DCB      0x74,0x72,0x6f,0x6c
000118  00                DCB      0x00
                  |symbol_number.148|
000119  72745f            DCB      0x72,0x74,0x5f
00011c  6d625f69          DCB      0x6d,0x62,0x5f,0x69
000120  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.149|
000124  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000128  625f6465          DCB      0x62,0x5f,0x64,0x65
00012c  74616368          DCB      0x74,0x61,0x63,0x68
000130  00                DCB      0x00
                  |symbol_number.150|
000131  72745f            DCB      0x72,0x74,0x5f
000134  6d625f63          DCB      0x6d,0x62,0x5f,0x63
000138  72656174          DCB      0x72,0x65,0x61,0x74
00013c  6500              DCB      0x65,0x00
                  |symbol_number.151|
00013e  7274              DCB      0x72,0x74
000140  5f6d625f          DCB      0x5f,0x6d,0x62,0x5f
000144  64656c65          DCB      0x64,0x65,0x6c,0x65
000148  746500            DCB      0x74,0x65,0x00
                  |symbol_number.152|
00014b  72                DCB      0x72
00014c  745f6d62          DCB      0x74,0x5f,0x6d,0x62
000150  5f73656e          DCB      0x5f,0x73,0x65,0x6e
000154  645f7761          DCB      0x64,0x5f,0x77,0x61
000158  697400            DCB      0x69,0x74,0x00
                  |symbol_number.153|
00015b  72                DCB      0x72
00015c  745f6d62          DCB      0x74,0x5f,0x6d,0x62
000160  5f726563          DCB      0x5f,0x72,0x65,0x63
000164  7600              DCB      0x76,0x00
                  |symbol_number.154|
000166  7274              DCB      0x72,0x74
000168  5f6d625f          DCB      0x5f,0x6d,0x62,0x5f
00016c  636f6e74          DCB      0x63,0x6f,0x6e,0x74
000170  726f6c00          DCB      0x72,0x6f,0x6c,0x00
                  |symbol_number.155|
000174  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000178  715f696e          DCB      0x71,0x5f,0x69,0x6e
00017c  697400            DCB      0x69,0x74,0x00
                  |symbol_number.156|
00017f  72                DCB      0x72
000180  745f6d71          DCB      0x74,0x5f,0x6d,0x71
000184  5f646574          DCB      0x5f,0x64,0x65,0x74
000188  61636800          DCB      0x61,0x63,0x68,0x00
                  |symbol_number.157|
00018c  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000190  715f6372          DCB      0x71,0x5f,0x63,0x72
000194  65617465          DCB      0x65,0x61,0x74,0x65
000198  00                DCB      0x00
                  |symbol_number.158|
000199  72745f            DCB      0x72,0x74,0x5f
00019c  6d715f64          DCB      0x6d,0x71,0x5f,0x64
0001a0  656c6574          DCB      0x65,0x6c,0x65,0x74
0001a4  6500              DCB      0x65,0x00
                  |symbol_number.159|
0001a6  7274              DCB      0x72,0x74
0001a8  5f6d715f          DCB      0x5f,0x6d,0x71,0x5f
0001ac  73656e64          DCB      0x73,0x65,0x6e,0x64
0001b0  00                DCB      0x00
                  |symbol_number.160|
0001b1  72745f            DCB      0x72,0x74,0x5f
0001b4  6d715f75          DCB      0x6d,0x71,0x5f,0x75
0001b8  7267656e          DCB      0x72,0x67,0x65,0x6e
0001bc  7400              DCB      0x74,0x00
                  |symbol_number.161|
0001be  7274              DCB      0x72,0x74
0001c0  5f6d715f          DCB      0x5f,0x6d,0x71,0x5f
0001c4  72656376          DCB      0x72,0x65,0x63,0x76
0001c8  00                DCB      0x00
                  |symbol_number.162|
0001c9  72745f            DCB      0x72,0x74,0x5f
0001cc  6d715f63          DCB      0x6d,0x71,0x5f,0x63
0001d0  6f6e7472          DCB      0x6f,0x6e,0x74,0x72
0001d4  6f6c00            DCB      0x6f,0x6c,0x00
