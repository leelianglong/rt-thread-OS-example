; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\kservice.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kservice.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\kservice.crf ..\rt_thread\kernel\kservice.c]
                          THUMB

                          AREA ||i.__rt_ffs||, CODE, READONLY, ALIGN=2

                  __rt_ffs PROC
;;;1223    */
;;;1224   int __rt_ffs(int value)
000000  4601              MOV      r1,r0
;;;1225   {
;;;1226       if (value == 0) return 0;
000002  b909              CBNZ     r1,|L1.8|
000004  2000              MOVS     r0,#0
                  |L1.6|
;;;1227   
;;;1228       if (value & 0xff)
;;;1229           return __lowest_bit_bitmap[value & 0xff] + 1;
;;;1230   
;;;1231       if (value & 0xff00)
;;;1232           return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
;;;1233   
;;;1234       if (value & 0xff0000)
;;;1235           return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
;;;1236   
;;;1237       return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
;;;1238   }
000006  4770              BX       lr
                  |L1.8|
000008  b2c8              UXTB     r0,r1                 ;1228
00000a  b120              CBZ      r0,|L1.22|
00000c  b2c8              UXTB     r0,r1                 ;1229
00000e  4a0e              LDR      r2,|L1.72|
000010  5c10              LDRB     r0,[r2,r0]            ;1229
000012  1c40              ADDS     r0,r0,#1              ;1229
000014  e7f7              B        |L1.6|
                  |L1.22|
000016  f401407f          AND      r0,r1,#0xff00         ;1231
00001a  b128              CBZ      r0,|L1.40|
00001c  480a              LDR      r0,|L1.72|
00001e  f3c12207          UBFX     r2,r1,#8,#8           ;1232
000022  5c80              LDRB     r0,[r0,r2]            ;1232
000024  3009              ADDS     r0,r0,#9              ;1232
000026  e7ee              B        |L1.6|
                  |L1.40|
000028  f401007f          AND      r0,r1,#0xff0000       ;1234
00002c  b128              CBZ      r0,|L1.58|
00002e  4806              LDR      r0,|L1.72|
000030  f3c14207          UBFX     r2,r1,#16,#8          ;1235
000034  5c80              LDRB     r0,[r0,r2]            ;1235
000036  3011              ADDS     r0,r0,#0x11           ;1235
000038  e7e5              B        |L1.6|
                  |L1.58|
00003a  4803              LDR      r0,|L1.72|
00003c  eb006011          ADD      r0,r0,r1,LSR #24      ;1237
000040  7800              LDRB     r0,[r0,#0]            ;1237
000042  3019              ADDS     r0,r0,#0x19           ;1237
000044  e7df              B        |L1.6|
;;;1239   #endif
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
                          DCD      __lowest_bit_bitmap

                          AREA ||i._rt_errno||, CODE, READONLY, ALIGN=2

                  _rt_errno PROC
;;;111     */
;;;112    int *_rt_errno(void)
000000  b510              PUSH     {r4,lr}
;;;113    {
;;;114        rt_thread_t tid;
;;;115    
;;;116        if (rt_interrupt_get_nest() != 0)
000002  f7fffffe          BL       rt_interrupt_get_nest
000006  b108              CBZ      r0,|L2.12|
;;;117            return (int *)&_errno;
000008  4805              LDR      r0,|L2.32|
                  |L2.10|
;;;118    
;;;119        tid = rt_thread_self();
;;;120        if (tid != RT_NULL)
;;;121            return (int *)&(tid->error);
;;;122    
;;;123        return (int *)&_errno;
;;;124    }
00000a  bd10              POP      {r4,pc}
                  |L2.12|
00000c  f7fffffe          BL       rt_thread_self
000010  4604              MOV      r4,r0                 ;119
000012  b114              CBZ      r4,|L2.26|
000014  f1040030          ADD      r0,r4,#0x30           ;121
000018  e7f7              B        |L2.10|
                  |L2.26|
00001a  4801              LDR      r0,|L2.32|
00001c  e7f5              B        |L2.10|
;;;125    RTM_EXPORT(_rt_errno);
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      _errno

                          AREA ||i.print_number||, CODE, READONLY, ALIGN=2

                  print_number PROC
;;;560    #ifdef RT_PRINTF_PRECISION
;;;561    static char *print_number(char *buf,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;562                              char *end,
;;;563                              long  num,
;;;564                              int   base,
;;;565                              int   s,
;;;566                              int   precision,
;;;567                              int   type)
;;;568    #else
;;;569    static char *print_number(char *buf,
;;;570                              char *end,
;;;571                              long  num,
;;;572                              int   base,
;;;573                              int   s,
;;;574                              int   type)
;;;575    #endif
;;;576    {
000004  b085              SUB      sp,sp,#0x14
000006  460d              MOV      r5,r1
000008  469c              MOV      r12,r3
00000a  e9dd740f          LDRD     r7,r4,[sp,#0x3c]
;;;577        char c, sign;
;;;578    #ifdef RT_PRINTF_LONGLONG
;;;579        char tmp[32];
;;;580    #else
;;;581        char tmp[16];
;;;582    #endif
;;;583        const char *digits;
;;;584        static const char small_digits[] = "0123456789abcdef";
;;;585        static const char large_digits[] = "0123456789ABCDEF";
;;;586        register int i;
;;;587        register int size;
;;;588    
;;;589        size = s;
00000e  9b0e              LDR      r3,[sp,#0x38]
;;;590    
;;;591        digits = (type & LARGE) ? large_digits : small_digits;
000010  f0040840          AND      r8,r4,#0x40
000014  f1b80f00          CMP      r8,#0
000018  d002              BEQ      |L3.32|
00001a  f8df8168          LDR      r8,|L3.388|
00001e  e001              B        |L3.36|
                  |L3.32|
000020  f8df8164          LDR      r8,|L3.392|
                  |L3.36|
000024  f8cd8000          STR      r8,[sp,#0]
;;;592        if (type & LEFT)
000028  f0040810          AND      r8,r4,#0x10
00002c  f1b80f00          CMP      r8,#0
000030  d001              BEQ      |L3.54|
;;;593            type &= ~ZEROPAD;
000032  f0240401          BIC      r4,r4,#1
                  |L3.54|
;;;594    
;;;595        c = (type & ZEROPAD) ? '0' : ' ';
000036  f0040801          AND      r8,r4,#1
00003a  f1b80f00          CMP      r8,#0
00003e  d002              BEQ      |L3.70|
000040  f04f0830          MOV      r8,#0x30
000044  e001              B        |L3.74|
                  |L3.70|
000046  f04f0820          MOV      r8,#0x20
                  |L3.74|
00004a  46c2              MOV      r10,r8
;;;596    
;;;597        /* get sign */
;;;598        sign = 0;
00004c  2600              MOVS     r6,#0
;;;599        if (type & SIGN)
00004e  f0040802          AND      r8,r4,#2
000052  f1b80f00          CMP      r8,#0
000056  d011              BEQ      |L3.124|
;;;600        {
;;;601            if (num < 0)
000058  2a00              CMP      r2,#0
00005a  da02              BGE      |L3.98|
;;;602            {
;;;603                sign = '-';
00005c  262d              MOVS     r6,#0x2d
;;;604                num = -num;
00005e  4252              RSBS     r2,r2,#0
000060  e00c              B        |L3.124|
                  |L3.98|
;;;605            }
;;;606            else if (type & PLUS)
000062  f0040804          AND      r8,r4,#4
000066  f1b80f00          CMP      r8,#0
00006a  d001              BEQ      |L3.112|
;;;607                sign = '+';
00006c  262b              MOVS     r6,#0x2b
00006e  e005              B        |L3.124|
                  |L3.112|
;;;608            else if (type & SPACE)
000070  f0040808          AND      r8,r4,#8
000074  f1b80f00          CMP      r8,#0
000078  d000              BEQ      |L3.124|
;;;609                sign = ' ';
00007a  2620              MOVS     r6,#0x20
                  |L3.124|
;;;610        }
;;;611    
;;;612    #ifdef RT_PRINTF_SPECIAL
;;;613        if (type & SPECIAL)
;;;614        {
;;;615            if (base == 16)
;;;616                size -= 2;
;;;617            else if (base == 8)
;;;618                size--;
;;;619        }
;;;620    #endif
;;;621    
;;;622        i = 0;
00007c  2100              MOVS     r1,#0
;;;623        if (num == 0)
00007e  b942              CBNZ     r2,|L3.146|
;;;624            tmp[i++]='0';
000080  f04f0b30          MOV      r11,#0x30
000084  4688              MOV      r8,r1
000086  1c49              ADDS     r1,r1,#1
000088  f10d0904          ADD      r9,sp,#4
00008c  f809b008          STRB     r11,[r9,r8]
000090  e01d              B        |L3.206|
                  |L3.146|
;;;625        else
;;;626        {
;;;627            while (num != 0)
000092  e01a              B        |L3.202|
                  |L3.148|
;;;628                tmp[i++] = digits[divide(&num, base)];
000094  46e1              MOV      r9,r12
000096  f1b90f0a          CMP      r9,#0xa
00009a  d108              BNE      |L3.174|
00009c  f04f0b0a          MOV      r11,#0xa
0000a0  fbb2fefb          UDIV     lr,r2,r11
0000a4  fb0b281e          MLS      r8,r11,lr,r2
0000a8  fbb2f2fb          UDIV     r2,r2,r11
0000ac  e002              B        |L3.180|
                  |L3.174|
0000ae  f002080f          AND      r8,r2,#0xf
0000b2  0912              LSRS     r2,r2,#4
                  |L3.180|
0000b4  bf00              NOP      
0000b6  f8dd9000          LDR      r9,[sp,#0]
0000ba  f819b008          LDRB     r11,[r9,r8]
0000be  4688              MOV      r8,r1
0000c0  1c49              ADDS     r1,r1,#1
0000c2  f10d0904          ADD      r9,sp,#4
0000c6  f809b008          STRB     r11,[r9,r8]
                  |L3.202|
0000ca  2a00              CMP      r2,#0                 ;627
0000cc  d1e2              BNE      |L3.148|
                  |L3.206|
;;;629        }
;;;630    
;;;631    #ifdef RT_PRINTF_PRECISION
;;;632        if (i > precision)
0000ce  42b9              CMP      r1,r7
0000d0  dd00              BLE      |L3.212|
;;;633            precision = i;
0000d2  460f              MOV      r7,r1
                  |L3.212|
;;;634        size -= precision;
0000d4  1bdb              SUBS     r3,r3,r7
;;;635    #else
;;;636        size -= i;
;;;637    #endif
;;;638    
;;;639        if (!(type&(ZEROPAD | LEFT)))
0000d6  f0040811          AND      r8,r4,#0x11
0000da  f1b80f00          CMP      r8,#0
0000de  d110              BNE      |L3.258|
;;;640        {
;;;641            if ((sign)&&(size>0))
0000e0  b116              CBZ      r6,|L3.232|
0000e2  2b00              CMP      r3,#0
0000e4  dd00              BLE      |L3.232|
;;;642                size--;
0000e6  1e5b              SUBS     r3,r3,#1
                  |L3.232|
;;;643    
;;;644            while (size-->0)
0000e8  e006              B        |L3.248|
                  |L3.234|
;;;645            {
;;;646                if (buf <= end)
0000ea  42a8              CMP      r0,r5
0000ec  d803              BHI      |L3.246|
;;;647                    *buf = ' ';
0000ee  f04f0820          MOV      r8,#0x20
0000f2  f8808000          STRB     r8,[r0,#0]
                  |L3.246|
;;;648                ++ buf;
0000f6  1c40              ADDS     r0,r0,#1
                  |L3.248|
0000f8  f1b30800          SUBS     r8,r3,#0              ;644
0000fc  f1a30301          SUB      r3,r3,#1              ;644
000100  dcf3              BGT      |L3.234|
                  |L3.258|
;;;649            }
;;;650        }
;;;651    
;;;652        if (sign)
000102  b126              CBZ      r6,|L3.270|
;;;653        {
;;;654            if (buf <= end)
000104  42a8              CMP      r0,r5
000106  d801              BHI      |L3.268|
;;;655            {
;;;656                *buf = sign;
000108  7006              STRB     r6,[r0,#0]
;;;657                -- size;
00010a  1e5b              SUBS     r3,r3,#1
                  |L3.268|
;;;658            }
;;;659            ++ buf;
00010c  1c40              ADDS     r0,r0,#1
                  |L3.270|
;;;660        }
;;;661    
;;;662    #ifdef RT_PRINTF_SPECIAL
;;;663        if (type & SPECIAL)
;;;664        {
;;;665            if (base==8)
;;;666            {
;;;667                if (buf <= end)
;;;668                    *buf = '0';
;;;669                ++ buf;
;;;670            }
;;;671            else if (base == 16)
;;;672            {
;;;673                if (buf <= end)
;;;674                    *buf = '0';
;;;675                ++ buf;
;;;676                if (buf <= end)
;;;677                {
;;;678                    *buf = type & LARGE? 'X' : 'x';
;;;679                }
;;;680                ++ buf;
;;;681            }
;;;682        }
;;;683    #endif
;;;684    
;;;685        /* no align to the left */
;;;686        if (!(type & LEFT))
00010e  f0040810          AND      r8,r4,#0x10
000112  f1b80f00          CMP      r8,#0
000116  d10a              BNE      |L3.302|
;;;687        {
;;;688            while (size-- > 0)
000118  e004              B        |L3.292|
                  |L3.282|
;;;689            {
;;;690                if (buf <= end)
00011a  42a8              CMP      r0,r5
00011c  d801              BHI      |L3.290|
;;;691                    *buf = c;
00011e  f880a000          STRB     r10,[r0,#0]
                  |L3.290|
;;;692                ++ buf;
000122  1c40              ADDS     r0,r0,#1
                  |L3.292|
000124  f1b30800          SUBS     r8,r3,#0              ;688
000128  f1a30301          SUB      r3,r3,#1              ;688
00012c  dcf5              BGT      |L3.282|
                  |L3.302|
;;;693            }
;;;694        }
;;;695    
;;;696    #ifdef RT_PRINTF_PRECISION
;;;697        while (i < precision--)
00012e  e006              B        |L3.318|
                  |L3.304|
;;;698        {
;;;699            if (buf <= end)
000130  42a8              CMP      r0,r5
000132  d803              BHI      |L3.316|
;;;700                *buf = '0';
000134  f04f0830          MOV      r8,#0x30
000138  f8808000          STRB     r8,[r0,#0]
                  |L3.316|
;;;701            ++ buf;
00013c  1c40              ADDS     r0,r0,#1
                  |L3.318|
00013e  46b8              MOV      r8,r7                 ;697
000140  1e7f              SUBS     r7,r7,#1              ;697
000142  4588              CMP      r8,r1                 ;697
000144  dcf4              BGT      |L3.304|
;;;702        }
;;;703    #endif
;;;704    
;;;705        /* put number in the temporary buffer */
;;;706        while (i-- > 0)
000146  e008              B        |L3.346|
                  |L3.328|
;;;707        {
;;;708            if (buf <= end)
000148  42a8              CMP      r0,r5
00014a  d805              BHI      |L3.344|
;;;709                *buf = tmp[i];
00014c  f10d0804          ADD      r8,sp,#4
000150  f8188001          LDRB     r8,[r8,r1]
000154  f8808000          STRB     r8,[r0,#0]
                  |L3.344|
;;;710            ++ buf;
000158  1c40              ADDS     r0,r0,#1
                  |L3.346|
00015a  f1b10800          SUBS     r8,r1,#0              ;706
00015e  f1a10101          SUB      r1,r1,#1              ;706
000162  dcf1              BGT      |L3.328|
;;;711        }
;;;712    
;;;713        while (size-- > 0)
000164  e006              B        |L3.372|
                  |L3.358|
;;;714        {
;;;715            if (buf <= end)
000166  42a8              CMP      r0,r5
000168  d803              BHI      |L3.370|
;;;716                *buf = ' ';
00016a  f04f0820          MOV      r8,#0x20
00016e  f8808000          STRB     r8,[r0,#0]
                  |L3.370|
;;;717            ++ buf;
000172  1c40              ADDS     r0,r0,#1
                  |L3.372|
000174  f1b30800          SUBS     r8,r3,#0              ;713
000178  f1a30301          SUB      r3,r3,#1              ;713
00017c  dcf3              BGT      |L3.358|
;;;718        }
;;;719    
;;;720        return buf;
;;;721    }
00017e  b005              ADD      sp,sp,#0x14
000180  e8bd8ff0          POP      {r4-r11,pc}
;;;722    
                          ENDP

                  |L3.388|
                          DCD      large_digits
                  |L3.392|
                          DCD      small_digits

                          AREA ||i.rt_assert_handler||, CODE, READONLY, ALIGN=2

                  rt_assert_handler PROC
;;;1259    */
;;;1260   void rt_assert_handler(const char* ex_string, const char* func, rt_size_t line)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1261   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1262       volatile char dummy = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1263   
;;;1264       if (rt_assert_hook == RT_NULL)
00000c  480a              LDR      r0,|L4.56|
00000e  6800              LDR      r0,[r0,#0]  ; rt_assert_hook
000010  b958              CBNZ     r0,|L4.42|
;;;1265       {
;;;1266   #ifdef RT_USING_MODULE
;;;1267   		if (rt_module_self() != RT_NULL)
;;;1268   		{
;;;1269   			/* unload assertion module */
;;;1270   			rt_module_unload(rt_module_self());
;;;1271   
;;;1272   			/* re-schedule */
;;;1273   			rt_schedule();
;;;1274   		}
;;;1275   		else
;;;1276   #endif
;;;1277   		{
;;;1278   	        rt_kprintf("(%s) assertion failed at function:%s, line number:%d \n", ex_string, func, line);
000012  4633              MOV      r3,r6
000014  462a              MOV      r2,r5
000016  4621              MOV      r1,r4
000018  a008              ADR      r0,|L4.60|
00001a  f7fffffe          BL       rt_kprintf
;;;1279   	        while (dummy == 0);
00001e  bf00              NOP      
                  |L4.32|
000020  f89d0000          LDRB     r0,[sp,#0]
000024  2800              CMP      r0,#0
000026  d0fb              BEQ      |L4.32|
000028  e005              B        |L4.54|
                  |L4.42|
;;;1280   		}
;;;1281       }
;;;1282   	else
;;;1283   	{
;;;1284           rt_assert_hook(ex_string, func, line);
00002a  4632              MOV      r2,r6
00002c  4629              MOV      r1,r5
00002e  4620              MOV      r0,r4
000030  4b01              LDR      r3,|L4.56|
000032  681b              LDR      r3,[r3,#0]  ; rt_assert_hook
000034  4798              BLX      r3
                  |L4.54|
;;;1285       }                                                                     
;;;1286   }
000036  bdf8              POP      {r3-r7,pc}
;;;1287   RTM_EXPORT(rt_assert_handler);
                          ENDP

                  |L4.56|
                          DCD      rt_assert_hook
                  |L4.60|
00003c  28257329          DCB      "(%s) assertion failed at function:%s, line number:%d \n"
000040  20617373
000044  65727469
000048  6f6e2066
00004c  61696c65
000050  64206174
000054  2066756e
000058  6374696f
00005c  6e3a2573
000060  2c206c69
000064  6e65206e
000068  756d6265
00006c  723a2564
000070  200a    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.rt_assert_set_hook||, CODE, READONLY, ALIGN=2

                  rt_assert_set_hook PROC
;;;1248    */
;;;1249   void rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line)) {
000000  4901              LDR      r1,|L5.8|
;;;1250       rt_assert_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_assert_hook
;;;1251   }
000004  4770              BX       lr
;;;1252   
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      rt_assert_hook

                          AREA ||i.rt_console_get_device||, CODE, READONLY, ALIGN=2

                  rt_console_get_device PROC
;;;1042    */
;;;1043   rt_device_t rt_console_get_device(void)
000000  4801              LDR      r0,|L6.8|
;;;1044   {
;;;1045       return _console_device;
000002  6800              LDR      r0,[r0,#0]  ; _console_device
;;;1046   }
000004  4770              BX       lr
;;;1047   RTM_EXPORT(rt_console_get_device);
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      _console_device

                          AREA ||i.rt_console_set_device||, CODE, READONLY, ALIGN=2

                  rt_console_set_device PROC
;;;1057    */
;;;1058   rt_device_t rt_console_set_device(const char *name)
000000  b570              PUSH     {r4-r6,lr}
;;;1059   {
000002  4605              MOV      r5,r0
;;;1060       rt_device_t new, old;
;;;1061   
;;;1062       /* save old device */
;;;1063       old = _console_device;
000004  480a              LDR      r0,|L7.48|
000006  6806              LDR      r6,[r0,#0]  ; _console_device
;;;1064   
;;;1065       /* find new console device */
;;;1066       new = rt_device_find(name);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       rt_device_find
00000e  4604              MOV      r4,r0
;;;1067       if (new != RT_NULL)
000010  b164              CBZ      r4,|L7.44|
;;;1068       {
;;;1069           if (_console_device != RT_NULL)
000012  4807              LDR      r0,|L7.48|
000014  6800              LDR      r0,[r0,#0]  ; _console_device
000016  b118              CBZ      r0,|L7.32|
;;;1070           {
;;;1071               /* close old console device */
;;;1072               rt_device_close(_console_device);
000018  4805              LDR      r0,|L7.48|
00001a  6800              LDR      r0,[r0,#0]  ; _console_device
00001c  f7fffffe          BL       rt_device_close
                  |L7.32|
;;;1073           }
;;;1074   
;;;1075           /* set new console device */
;;;1076           rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
000020  2143              MOVS     r1,#0x43
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_device_open
;;;1077           _console_device = new;
000028  4801              LDR      r0,|L7.48|
00002a  6004              STR      r4,[r0,#0]  ; _console_device
                  |L7.44|
;;;1078       }
;;;1079   
;;;1080       return old;
00002c  4630              MOV      r0,r6
;;;1081   }
00002e  bd70              POP      {r4-r6,pc}
;;;1082   RTM_EXPORT(rt_console_set_device);
                          ENDP

                  |L7.48|
                          DCD      _console_device

                          AREA ||i.rt_free_align||, CODE, READONLY, ALIGN=1

                  rt_free_align PROC
;;;1182    */
;;;1183   void rt_free_align(void *ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;1184   {
000002  4604              MOV      r4,r0
;;;1185       void *real_ptr;
;;;1186   
;;;1187       real_ptr = (void *)*(rt_uint32_t *)((rt_uint32_t)ptr - sizeof(void *));
000004  f8545c04          LDR      r5,[r4,#-4]
;;;1188       rt_free(real_ptr);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       rt_free
;;;1189   }
00000e  bd70              POP      {r4-r6,pc}
;;;1190   RTM_EXPORT(rt_free_align);
                          ENDP


                          AREA ||i.rt_get_errno||, CODE, READONLY, ALIGN=2

                  rt_get_errno PROC
;;;59      */
;;;60     rt_err_t rt_get_errno(void)
000000  b510              PUSH     {r4,lr}
;;;61     {
;;;62         rt_thread_t tid;
;;;63     
;;;64         if (rt_interrupt_get_nest() != 0)
000002  f7fffffe          BL       rt_interrupt_get_nest
000006  b110              CBZ      r0,|L9.14|
;;;65         {
;;;66             /* it's in interrupt context */
;;;67             return _errno;
000008  4805              LDR      r0,|L9.32|
00000a  6800              LDR      r0,[r0,#0]  ; _errno
                  |L9.12|
;;;68         }
;;;69     
;;;70         tid = rt_thread_self();
;;;71         if (tid == RT_NULL)
;;;72             return _errno;
;;;73     
;;;74         return tid->error;
;;;75     }
00000c  bd10              POP      {r4,pc}
                  |L9.14|
00000e  f7fffffe          BL       rt_thread_self
000012  4604              MOV      r4,r0                 ;70
000014  b914              CBNZ     r4,|L9.28|
000016  4802              LDR      r0,|L9.32|
000018  6800              LDR      r0,[r0,#0]            ;72  ; _errno
00001a  e7f7              B        |L9.12|
                  |L9.28|
00001c  6b20              LDR      r0,[r4,#0x30]         ;74
00001e  e7f5              B        |L9.12|
;;;76     RTM_EXPORT(rt_get_errno);
                          ENDP

                  |L9.32|
                          DCD      _errno

                          AREA ||i.rt_hw_console_output||, CODE, READONLY, ALIGN=1

                  rt_hw_console_output PROC
;;;1084   
;;;1085   WEAK void rt_hw_console_output(const char *str)
000000  4770              BX       lr
;;;1086   {
;;;1087       /* empty console output */
;;;1088   }
;;;1089   RTM_EXPORT(rt_hw_console_output);
                          ENDP


                          AREA ||i.rt_kprintf||, CODE, READONLY, ALIGN=2

                  rt_kprintf PROC
;;;1095    */
;;;1096   void rt_kprintf(const char *fmt, ...)
000000  b40f              PUSH     {r0-r3}
;;;1097   {
000002  b538              PUSH     {r3-r5,lr}
;;;1098       va_list args;
;;;1099       rt_size_t length;
;;;1100       static char rt_log_buf[RT_CONSOLEBUF_SIZE];
;;;1101   
;;;1102       va_start(args, fmt);
000004  a805              ADD      r0,sp,#0x14
000006  9000              STR      r0,[sp,#0]
;;;1103       /* the return value of vsnprintf is the number of bytes that would be
;;;1104        * written to buffer had if the size of the buffer been sufficiently
;;;1105        * large excluding the terminating null byte. If the output string
;;;1106        * would be larger than the rt_log_buf, we have to adjust the output
;;;1107        * length. */
;;;1108       length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
000008  217f              MOVS     r1,#0x7f
00000a  4815              LDR      r0,|L11.96|
00000c  9b00              LDR      r3,[sp,#0]
00000e  9a04              LDR      r2,[sp,#0x10]
000010  f7fffffe          BL       rt_vsnprintf
000014  4604              MOV      r4,r0
;;;1109       if (length > RT_CONSOLEBUF_SIZE - 1)
000016  2c7f              CMP      r4,#0x7f
000018  d900              BLS      |L11.28|
;;;1110           length = RT_CONSOLEBUF_SIZE - 1;
00001a  247f              MOVS     r4,#0x7f
                  |L11.28|
;;;1111   #ifdef RT_USING_DEVICE
;;;1112       if (_console_device == RT_NULL)
00001c  4811              LDR      r0,|L11.100|
00001e  6800              LDR      r0,[r0,#0]  ; _console_device
000020  b918              CBNZ     r0,|L11.42|
;;;1113       {
;;;1114           rt_hw_console_output(rt_log_buf);
000022  480f              LDR      r0,|L11.96|
000024  f7fffffe          BL       rt_hw_console_output
000028  e015              B        |L11.86|
                  |L11.42|
;;;1115       }
;;;1116       else
;;;1117       {
;;;1118           rt_uint16_t old_flag = _console_device->open_flag;
00002a  480e              LDR      r0,|L11.100|
00002c  6800              LDR      r0,[r0,#0]  ; _console_device
00002e  8b05              LDRH     r5,[r0,#0x18]
;;;1119   
;;;1120           _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
000030  480c              LDR      r0,|L11.100|
000032  6800              LDR      r0,[r0,#0]  ; _console_device
000034  8b00              LDRH     r0,[r0,#0x18]
000036  f0400040          ORR      r0,r0,#0x40
00003a  490a              LDR      r1,|L11.100|
00003c  6809              LDR      r1,[r1,#0]  ; _console_device
00003e  8308              STRH     r0,[r1,#0x18]
;;;1121           rt_device_write(_console_device, 0, rt_log_buf, length);
000040  4623              MOV      r3,r4
000042  4a07              LDR      r2,|L11.96|
000044  2100              MOVS     r1,#0
000046  4807              LDR      r0,|L11.100|
000048  6800              LDR      r0,[r0,#0]  ; _console_device
00004a  f7fffffe          BL       rt_device_write
;;;1122           _console_device->open_flag = old_flag;
00004e  4805              LDR      r0,|L11.100|
000050  6800              LDR      r0,[r0,#0]  ; _console_device
000052  8305              STRH     r5,[r0,#0x18]
;;;1123       }
000054  bf00              NOP      
                  |L11.86|
;;;1124   #else
;;;1125       rt_hw_console_output(rt_log_buf);
;;;1126   #endif
;;;1127       va_end(args);
000056  2000              MOVS     r0,#0
000058  9000              STR      r0,[sp,#0]
;;;1128   }
00005a  bc38              POP      {r3-r5}
00005c  f85dfb14          LDR      pc,[sp],#0x14
;;;1129   RTM_EXPORT(rt_kprintf);
                          ENDP

                  |L11.96|
                          DCD      rt_log_buf
                  |L11.100|
                          DCD      _console_device

                          AREA ||i.rt_malloc_align||, CODE, READONLY, ALIGN=1

                  rt_malloc_align PROC
;;;1141    */
;;;1142   void* rt_malloc_align(rt_size_t size, rt_size_t align)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1143   {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;1144       void *align_ptr;
;;;1145       void *ptr;
;;;1146       rt_size_t align_size;
;;;1147   
;;;1148       /* align the alignment size to 4 byte */
;;;1149       align = ((align + 0x03) & ~0x03);
000008  1ce0              ADDS     r0,r4,#3
00000a  f0200403          BIC      r4,r0,#3
;;;1150   
;;;1151       /* get total aligned size */
;;;1152       align_size = ((size + 0x03) & ~0x03) + align;
00000e  1cf8              ADDS     r0,r7,#3
000010  f0200003          BIC      r0,r0,#3
000014  eb000804          ADD      r8,r0,r4
;;;1153       /* allocate memory block from heap */
;;;1154       ptr = rt_malloc(align_size);
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       rt_malloc
00001e  4605              MOV      r5,r0
;;;1155       if (ptr != RT_NULL)
000020  b165              CBZ      r5,|L12.60|
;;;1156       {
;;;1157            /* the allocated memory block is aligned */
;;;1158           if (((rt_uint32_t)ptr & (align - 1)) == 0)
000022  1e60              SUBS     r0,r4,#1
000024  4028              ANDS     r0,r0,r5
000026  b908              CBNZ     r0,|L12.44|
;;;1159           {
;;;1160               align_ptr = (void *)((rt_uint32_t)ptr + align);
000028  192e              ADDS     r6,r5,r4
00002a  e004              B        |L12.54|
                  |L12.44|
;;;1161           }
;;;1162           else
;;;1163           {
;;;1164               align_ptr = (void *)(((rt_uint32_t)ptr + (align - 1)) & ~(align - 1));
00002c  1e60              SUBS     r0,r4,#1
00002e  4428              ADD      r0,r0,r5
000030  1e61              SUBS     r1,r4,#1
000032  ea200601          BIC      r6,r0,r1
                  |L12.54|
;;;1165           }
;;;1166   
;;;1167           /* set the pointer before alignment pointer to the real pointer */
;;;1168           *((rt_uint32_t *)((rt_uint32_t)align_ptr - sizeof(void *))) = (rt_uint32_t)ptr;
000036  f8465c04          STR      r5,[r6,#-4]
;;;1169   
;;;1170           ptr = align_ptr;
00003a  4635              MOV      r5,r6
                  |L12.60|
;;;1171       }
;;;1172   
;;;1173       return ptr;
00003c  4628              MOV      r0,r5
;;;1174   }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;1175   RTM_EXPORT(rt_malloc_align);
                          ENDP


                          AREA ||i.rt_memcmp||, CODE, READONLY, ALIGN=1

                  rt_memcmp PROC
;;;324     */
;;;325    rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
000000  b5f0              PUSH     {r4-r7,lr}
;;;326    {
000002  4603              MOV      r3,r0
;;;327        const unsigned char *su1, *su2;
;;;328        int res = 0;
000004  2000              MOVS     r0,#0
;;;329    
;;;330        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
000006  461c              MOV      r4,r3
000008  460d              MOV      r5,r1
00000a  e008              B        |L13.30|
                  |L13.12|
;;;331            if ((res = *su1 - *su2) != 0)
00000c  7826              LDRB     r6,[r4,#0]
00000e  782f              LDRB     r7,[r5,#0]
000010  1bf6              SUBS     r6,r6,r7
000012  0030              MOVS     r0,r6
000014  d000              BEQ      |L13.24|
;;;332                break;
000016  e004              B        |L13.34|
                  |L13.24|
000018  1c64              ADDS     r4,r4,#1              ;330
00001a  1c6d              ADDS     r5,r5,#1              ;330
00001c  1e52              SUBS     r2,r2,#1              ;330
                  |L13.30|
00001e  2a00              CMP      r2,#0                 ;330
000020  d8f4              BHI      |L13.12|
                  |L13.34|
000022  bf00              NOP      
;;;333    
;;;334        return res;
;;;335    }
000024  bdf0              POP      {r4-r7,pc}
;;;336    RTM_EXPORT(rt_memcmp);
                          ENDP


                          AREA ||i.rt_memcpy||, CODE, READONLY, ALIGN=1

                  rt_memcpy PROC
;;;218     */
;;;219    void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;220    {
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;221    #ifdef RT_TINY_SIZE
;;;222        char *tmp = (char *)dst, *s = (char *)src;
;;;223    
;;;224        while (count--)
;;;225            *tmp++ = *s++;
;;;226    
;;;227        return dst;
;;;228    #else
;;;229    
;;;230    #define UNALIGNED(X, Y)                                               \
;;;231                            (((rt_int32_t)X & (sizeof(rt_int32_t) - 1)) | \
;;;232                             ((rt_int32_t)Y & (sizeof(rt_int32_t) - 1)))
;;;233    #define BIGBLOCKSIZE    (sizeof(rt_int32_t) << 2)
;;;234    #define LITTLEBLOCKSIZE (sizeof(rt_int32_t))
;;;235    #define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)
;;;236    
;;;237        char *dst_ptr = (char *)dst;
000008  4604              MOV      r4,r0
;;;238        char *src_ptr = (char *)src;
00000a  463d              MOV      r5,r7
;;;239        rt_int32_t *aligned_dst;
;;;240        rt_int32_t *aligned_src;
;;;241        int len = count;
00000c  4633              MOV      r3,r6
;;;242    
;;;243        /* If the size is small, or either SRC or DST is unaligned,
;;;244        then punt into the byte copy loop.  This should be rare. */
;;;245        if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
00000e  2b10              CMP      r3,#0x10
000010  d328              BCC      |L14.100|
000012  f0050c03          AND      r12,r5,#3
000016  f0040803          AND      r8,r4,#3
00001a  ea4c0c08          ORR      r12,r12,r8
00001e  f1bc0f00          CMP      r12,#0
000022  d11f              BNE      |L14.100|
;;;246        {
;;;247            aligned_dst = (rt_int32_t *)dst_ptr;
000024  4621              MOV      r1,r4
;;;248            aligned_src = (rt_int32_t *)src_ptr;
000026  462a              MOV      r2,r5
;;;249    
;;;250            /* Copy 4X long words at a time if possible. */
;;;251            while (len >= BIGBLOCKSIZE)
000028  e010              B        |L14.76|
                  |L14.42|
;;;252            {
;;;253                *aligned_dst++ = *aligned_src++;
00002a  f852cb04          LDR      r12,[r2],#4
00002e  f841cb04          STR      r12,[r1],#4
;;;254                *aligned_dst++ = *aligned_src++;
000032  f852cb04          LDR      r12,[r2],#4
000036  f841cb04          STR      r12,[r1],#4
;;;255                *aligned_dst++ = *aligned_src++;
00003a  f852cb04          LDR      r12,[r2],#4
00003e  f841cb04          STR      r12,[r1],#4
;;;256                *aligned_dst++ = *aligned_src++;
000042  f852cb04          LDR      r12,[r2],#4
000046  f841cb04          STR      r12,[r1],#4
;;;257                len -= BIGBLOCKSIZE;
00004a  3b10              SUBS     r3,r3,#0x10
                  |L14.76|
00004c  2b10              CMP      r3,#0x10              ;251
00004e  d2ec              BCS      |L14.42|
;;;258            }
;;;259    
;;;260            /* Copy one long word at a time if possible. */
;;;261            while (len >= LITTLEBLOCKSIZE)
000050  e004              B        |L14.92|
                  |L14.82|
;;;262            {
;;;263                *aligned_dst++ = *aligned_src++;
000052  f852cb04          LDR      r12,[r2],#4
000056  f841cb04          STR      r12,[r1],#4
;;;264                len -= LITTLEBLOCKSIZE;
00005a  1f1b              SUBS     r3,r3,#4
                  |L14.92|
00005c  2b04              CMP      r3,#4                 ;261
00005e  d2f8              BCS      |L14.82|
;;;265            }
;;;266    
;;;267            /* Pick up any residual with a byte copier. */
;;;268            dst_ptr = (char *)aligned_dst;
000060  460c              MOV      r4,r1
;;;269            src_ptr = (char *)aligned_src;
000062  4615              MOV      r5,r2
                  |L14.100|
;;;270        }
;;;271    
;;;272        while (len--)
000064  e003              B        |L14.110|
                  |L14.102|
;;;273            *dst_ptr++ = *src_ptr++;
000066  f815cb01          LDRB     r12,[r5],#1
00006a  f804cb01          STRB     r12,[r4],#1
                  |L14.110|
00006e  ea5f0c03          MOVS     r12,r3                ;272
000072  f1a30301          SUB      r3,r3,#1              ;272
000076  d1f6              BNE      |L14.102|
;;;274    
;;;275        return dst;
;;;276    #undef UNALIGNED
;;;277    #undef BIGBLOCKSIZE
;;;278    #undef LITTLEBLOCKSIZE
;;;279    #undef TOO_SMALL
;;;280    #endif
;;;281    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;282    RTM_EXPORT(rt_memcpy);
                          ENDP


                          AREA ||i.rt_memmove||, CODE, READONLY, ALIGN=1

                  rt_memmove PROC
;;;293     */
;;;294    void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
000002  460c              MOV      r4,r1
;;;296        char *tmp = (char *)dest, *s = (char *)src;
000004  4601              MOV      r1,r0
000006  4623              MOV      r3,r4
;;;297    
;;;298        if (s < tmp && tmp < s + n)
000008  428b              CMP      r3,r1
00000a  d210              BCS      |L15.46|
00000c  189d              ADDS     r5,r3,r2
00000e  428d              CMP      r5,r1
000010  d90d              BLS      |L15.46|
;;;299        {
;;;300            tmp += n;
000012  4411              ADD      r1,r1,r2
;;;301            s += n;
000014  4413              ADD      r3,r3,r2
;;;302    
;;;303            while (n--)
000016  e005              B        |L15.36|
                  |L15.24|
;;;304                *(--tmp) = *(--s);
000018  1e5d              SUBS     r5,r3,#1
00001a  462b              MOV      r3,r5
00001c  782e              LDRB     r6,[r5,#0]
00001e  1e4d              SUBS     r5,r1,#1
000020  4629              MOV      r1,r5
000022  702e              STRB     r6,[r5,#0]
                  |L15.36|
000024  0015              MOVS     r5,r2                 ;303
000026  f1a20201          SUB      r2,r2,#1              ;303
00002a  d1f5              BNE      |L15.24|
00002c  e008              B        |L15.64|
                  |L15.46|
;;;305        }
;;;306        else
;;;307        {
;;;308            while (n--)
00002e  e003              B        |L15.56|
                  |L15.48|
;;;309                *tmp++ = *s++;
000030  f8135b01          LDRB     r5,[r3],#1
000034  f8015b01          STRB     r5,[r1],#1
                  |L15.56|
000038  0015              MOVS     r5,r2                 ;308
00003a  f1a20201          SUB      r2,r2,#1              ;308
00003e  d1f7              BNE      |L15.48|
                  |L15.64|
;;;310        }
;;;311    
;;;312        return dest;
;;;313    }
000040  bd70              POP      {r4-r6,pc}
;;;314    RTM_EXPORT(rt_memmove);
                          ENDP


                          AREA ||i.rt_memset||, CODE, READONLY, ALIGN=1

                  rt_memset PROC
;;;135     */
;;;136    void *rt_memset(void *s, int c, rt_ubase_t count)
000000  b5f0              PUSH     {r4-r7,lr}
;;;137    {
000002  460c              MOV      r4,r1
;;;138    #ifdef RT_TINY_SIZE
;;;139        char *xs = (char *)s;
;;;140    
;;;141        while (count--)
;;;142            *xs++ = c;
;;;143    
;;;144        return s;
;;;145    #else
;;;146    #define LBLOCKSIZE      (sizeof(rt_int32_t))
;;;147    #define UNALIGNED(X)    ((rt_int32_t)X & (LBLOCKSIZE - 1))
;;;148    #define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)
;;;149    
;;;150        int i;
;;;151        char *m = (char *)s;
000004  4605              MOV      r5,r0
;;;152        rt_uint32_t buffer;
;;;153        rt_uint32_t *aligned_addr;
;;;154        rt_uint32_t d = c & 0xff;
000006  b2e6              UXTB     r6,r4
;;;155    
;;;156        if (!TOO_SMALL(count) && !UNALIGNED(s))
000008  2a04              CMP      r2,#4
00000a  d315              BCC      |L16.56|
00000c  f0000703          AND      r7,r0,#3
000010  b997              CBNZ     r7,|L16.56|
;;;157        {
;;;158            /* If we get this far, we know that n is large and m is word-aligned. */
;;;159            aligned_addr = (rt_uint32_t *)s;
000012  4601              MOV      r1,r0
;;;160    
;;;161            /* Store D into each char sized location in BUFFER so that
;;;162             * we can set large blocks quickly.
;;;163             */
;;;164            if (LBLOCKSIZE == 4)
;;;165            {
;;;166                buffer = (d << 8) | d;
000014  ea462306          ORR      r3,r6,r6,LSL #8
;;;167                buffer |= (buffer << 16);
000018  ea434303          ORR      r3,r3,r3,LSL #16
;;;168            }
;;;169            else
;;;170            {
;;;171                buffer = 0;
;;;172                for (i = 0; i < LBLOCKSIZE; i ++)
;;;173                    buffer = (buffer << 8) | d;
;;;174            }
;;;175    
;;;176            while (count >= LBLOCKSIZE * 4)
00001c  e004              B        |L16.40|
                  |L16.30|
;;;177            {
;;;178                *aligned_addr++ = buffer;
00001e  c108              STM      r1!,{r3}
;;;179                *aligned_addr++ = buffer;
000020  c108              STM      r1!,{r3}
;;;180                *aligned_addr++ = buffer;
000022  c108              STM      r1!,{r3}
;;;181                *aligned_addr++ = buffer;
000024  c108              STM      r1!,{r3}
;;;182                count -= 4 * LBLOCKSIZE;
000026  3a10              SUBS     r2,r2,#0x10
                  |L16.40|
000028  2a10              CMP      r2,#0x10              ;176
00002a  d2f8              BCS      |L16.30|
;;;183            }
;;;184    
;;;185            while (count >= LBLOCKSIZE)
00002c  e001              B        |L16.50|
                  |L16.46|
;;;186            {
;;;187                *aligned_addr++ = buffer;
00002e  c108              STM      r1!,{r3}
;;;188                count -= LBLOCKSIZE;
000030  1f12              SUBS     r2,r2,#4
                  |L16.50|
000032  2a04              CMP      r2,#4                 ;185
000034  d2fb              BCS      |L16.46|
;;;189            }
;;;190    
;;;191            /* Pick up the remainder with a bytewise loop. */
;;;192            m = (char *)aligned_addr;
000036  460d              MOV      r5,r1
                  |L16.56|
;;;193        }
;;;194    
;;;195        while (count--)
000038  e001              B        |L16.62|
                  |L16.58|
;;;196        {
;;;197            *m++ = (char)d;
00003a  f8056b01          STRB     r6,[r5],#1
                  |L16.62|
00003e  0017              MOVS     r7,r2                 ;195
000040  f1a20201          SUB      r2,r2,#1              ;195
000044  d1f9              BNE      |L16.58|
;;;198        }
;;;199    
;;;200        return s;
;;;201    
;;;202    #undef LBLOCKSIZE
;;;203    #undef UNALIGNED
;;;204    #undef TOO_SMALL
;;;205    #endif
;;;206    }
000046  bdf0              POP      {r4-r7,pc}
;;;207    RTM_EXPORT(rt_memset);
                          ENDP


                          AREA ||i.rt_set_errno||, CODE, READONLY, ALIGN=2

                  rt_set_errno PROC
;;;82      */
;;;83     void rt_set_errno(rt_err_t error)
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
000002  4604              MOV      r4,r0
;;;85         rt_thread_t tid;
;;;86     
;;;87         if (rt_interrupt_get_nest() != 0)
000004  f7fffffe          BL       rt_interrupt_get_nest
000008  b110              CBZ      r0,|L17.16|
;;;88         {
;;;89             /* it's in interrupt context */
;;;90             _errno = error;
00000a  4806              LDR      r0,|L17.36|
00000c  6004              STR      r4,[r0,#0]  ; _errno
                  |L17.14|
;;;91     
;;;92             return;
;;;93         }
;;;94     
;;;95         tid = rt_thread_self();
;;;96         if (tid == RT_NULL)
;;;97         {
;;;98             _errno = error;
;;;99     
;;;100            return;
;;;101        }
;;;102    
;;;103        tid->error = error;
;;;104    }
00000e  bd70              POP      {r4-r6,pc}
                  |L17.16|
000010  f7fffffe          BL       rt_thread_self
000014  4605              MOV      r5,r0                 ;95
000016  b915              CBNZ     r5,|L17.30|
000018  4802              LDR      r0,|L17.36|
00001a  6004              STR      r4,[r0,#0]            ;98  ; _errno
00001c  e7f7              B        |L17.14|
                  |L17.30|
00001e  632c              STR      r4,[r5,#0x30]         ;103
000020  bf00              NOP      
000022  e7f4              B        |L17.14|
;;;105    RTM_EXPORT(rt_set_errno);
                          ENDP

                  |L17.36|
                          DCD      _errno

                          AREA ||i.rt_show_version||, CODE, READONLY, ALIGN=2

                  rt_show_version PROC
;;;510     */
;;;511    void rt_show_version(void)
000000  b508              PUSH     {r3,lr}
;;;512    {
;;;513        rt_kprintf("\n \\ | /\n");
000002  a009              ADR      r0,|L18.40|
000004  f7fffffe          BL       rt_kprintf
;;;514        rt_kprintf("- RT -     Thread Operating System\n");
000008  a00a              ADR      r0,|L18.52|
00000a  f7fffffe          BL       rt_kprintf
;;;515        rt_kprintf(" / | \\     %d.%d.%d build %s\n",
00000e  a012              ADR      r0,|L18.88|
000010  2300              MOVS     r3,#0
000012  2201              MOVS     r2,#1
000014  2102              MOVS     r1,#2
000016  9000              STR      r0,[sp,#0]
000018  a012              ADR      r0,|L18.100|
00001a  f7fffffe          BL       rt_kprintf
;;;516                   RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__);
;;;517        rt_kprintf(" 2006 - 2016 Copyright by rt-thread team\n");
00001e  a019              ADR      r0,|L18.132|
000020  f7fffffe          BL       rt_kprintf
;;;518    }
000024  bd08              POP      {r3,pc}
;;;519    RTM_EXPORT(rt_show_version);
                          ENDP

000026  0000              DCW      0x0000
                  |L18.40|
000028  0a205c20          DCB      "\n \\ | /\n",0
00002c  7c202f0a
000030  00      
000031  00                DCB      0
000032  00                DCB      0
000033  00                DCB      0
                  |L18.52|
000034  2d205254          DCB      "- RT -     Thread Operating System\n",0
000038  202d2020
00003c  20202054
000040  68726561
000044  64204f70
000048  65726174
00004c  696e6720
000050  53797374
000054  656d0a00
                  |L18.88|
000058  4d617920          DCB      "May 20 2017",0
00005c  32302032
000060  30313700
                  |L18.100|
000064  202f207c          DCB      " / | \\     %d.%d.%d build %s\n",0
000068  205c2020
00006c  20202025
000070  642e2564
000074  2e256420
000078  6275696c
00007c  64202573
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0
                  |L18.132|
000084  20323030          DCB      " 2006 - 2016 Copyright by rt-thread team\n",0
000088  36202d20
00008c  32303136
000090  20436f70
000094  79726967
000098  68742062
00009c  79207274
0000a0  2d746872
0000a4  65616420
0000a8  7465616d
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.rt_snprintf||, CODE, READONLY, ALIGN=1

                  rt_snprintf PROC
;;;989     */
;;;990    rt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *fmt, ...)
000000  b40f              PUSH     {r0-r3}
;;;991    {
000002  b5f8              PUSH     {r3-r7,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;992        rt_int32_t n;
;;;993        va_list args;
;;;994    
;;;995        va_start(args, fmt);
000008  a809              ADD      r0,sp,#0x24
00000a  9000              STR      r0,[sp,#0]
;;;996        n = rt_vsnprintf(buf, size, fmt, args);
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  9b00              LDR      r3,[sp,#0]
000012  9a08              LDR      r2,[sp,#0x20]
000014  f7fffffe          BL       rt_vsnprintf
000018  4606              MOV      r6,r0
;;;997        va_end(args);
00001a  2000              MOVS     r0,#0
00001c  9000              STR      r0,[sp,#0]
;;;998    
;;;999        return n;
00001e  4630              MOV      r0,r6
;;;1000   }
000020  bcf8              POP      {r3-r7}
000022  f85dfb14          LDR      pc,[sp],#0x14
;;;1001   RTM_EXPORT(rt_snprintf);
                          ENDP


                          AREA ||i.rt_sprintf||, CODE, READONLY, ALIGN=1

                  rt_sprintf PROC
;;;1021    */
;;;1022   rt_int32_t rt_sprintf(char *buf, const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;1023   {
000002  b538              PUSH     {r3-r5,lr}
000004  4604              MOV      r4,r0
;;;1024       rt_int32_t n;
;;;1025       va_list arg_ptr;
;;;1026   
;;;1027       va_start(arg_ptr, format);
000006  a806              ADD      r0,sp,#0x18
000008  9000              STR      r0,[sp,#0]
;;;1028       n = rt_vsprintf(buf ,format, arg_ptr);
00000a  4620              MOV      r0,r4
00000c  9a00              LDR      r2,[sp,#0]
00000e  9905              LDR      r1,[sp,#0x14]
000010  f7fffffe          BL       rt_vsprintf
000014  4605              MOV      r5,r0
;;;1029       va_end(arg_ptr);
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
;;;1030   
;;;1031       return n;
00001a  4628              MOV      r0,r5
;;;1032   }
00001c  bc38              POP      {r3-r5}
00001e  f85dfb14          LDR      pc,[sp],#0x14
;;;1033   RTM_EXPORT(rt_sprintf);
                          ENDP


                          AREA ||i.rt_strcasecmp||, CODE, READONLY, ALIGN=1

                  rt_strcasecmp PROC
;;;373     */
;;;374    rt_uint32_t rt_strcasecmp(const char *a, const char *b)
000000  b530              PUSH     {r4,r5,lr}
;;;375    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;376        int ca, cb;
;;;377    
;;;378        do
000006  bf00              NOP      
                  |L21.8|
;;;379        {
;;;380            ca = *a++ & 0xff;
000008  f8131b01          LDRB     r1,[r3],#1
;;;381            cb = *b++ & 0xff;
00000c  f8142b01          LDRB     r2,[r4],#1
;;;382            if (ca >= 'A' && ca <= 'Z')
000010  2941              CMP      r1,#0x41
000012  db02              BLT      |L21.26|
000014  295a              CMP      r1,#0x5a
000016  dc00              BGT      |L21.26|
;;;383                ca += 'a' - 'A';
000018  3120              ADDS     r1,r1,#0x20
                  |L21.26|
;;;384            if (cb >= 'A' && cb <= 'Z')
00001a  2a41              CMP      r2,#0x41
00001c  db02              BLT      |L21.36|
00001e  2a5a              CMP      r2,#0x5a
000020  dc00              BGT      |L21.36|
;;;385                cb += 'a' - 'A';
000022  3220              ADDS     r2,r2,#0x20
                  |L21.36|
;;;386        }
;;;387        while (ca == cb && ca != '\0');
000024  4291              CMP      r1,r2
000026  d101              BNE      |L21.44|
000028  2900              CMP      r1,#0
00002a  d1ed              BNE      |L21.8|
                  |L21.44|
;;;388    
;;;389        return ca - cb;
00002c  1a88              SUBS     r0,r1,r2
;;;390    }
00002e  bd30              POP      {r4,r5,pc}
;;;391    RTM_EXPORT(rt_strcasecmp);
                          ENDP


                          AREA ||i.rt_strcmp||, CODE, READONLY, ALIGN=1

                  rt_strcmp PROC
;;;456     */
;;;457    rt_int32_t rt_strcmp(const char *cs, const char *ct)
000000  4602              MOV      r2,r0
;;;458    {
;;;459        while (*cs && *cs == *ct)
000002  e001              B        |L22.8|
                  |L22.4|
;;;460            cs++, ct++;
000004  1c52              ADDS     r2,r2,#1
000006  1c49              ADDS     r1,r1,#1
                  |L22.8|
000008  7810              LDRB     r0,[r2,#0]            ;459
00000a  b118              CBZ      r0,|L22.20|
00000c  7810              LDRB     r0,[r2,#0]            ;459
00000e  780b              LDRB     r3,[r1,#0]            ;459
000010  4298              CMP      r0,r3                 ;459
000012  d0f7              BEQ      |L22.4|
                  |L22.20|
;;;461    
;;;462        return (*cs - *ct);
000014  7810              LDRB     r0,[r2,#0]
000016  780b              LDRB     r3,[r1,#0]
000018  1ac0              SUBS     r0,r0,r3
;;;463    }
00001a  4770              BX       lr
;;;464    RTM_EXPORT(rt_strcmp);
                          ENDP


                          AREA ||i.rt_strdup||, CODE, READONLY, ALIGN=1

                  rt_strdup PROC
;;;492     */
;;;493    char *rt_strdup(const char *s)
000000  b570              PUSH     {r4-r6,lr}
;;;494    {
000002  4604              MOV      r4,r0
;;;495        rt_size_t len = rt_strlen(s) + 1;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       rt_strlen
00000a  1c45              ADDS     r5,r0,#1
;;;496        char *tmp = (char *)rt_malloc(len);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       rt_malloc
000012  4606              MOV      r6,r0
;;;497    
;;;498        if (!tmp)
000014  b90e              CBNZ     r6,|L23.26|
;;;499            return RT_NULL;
000016  2000              MOVS     r0,#0
                  |L23.24|
;;;500    
;;;501        rt_memcpy(tmp, s, len);
;;;502    
;;;503        return tmp;
;;;504    }
000018  bd70              POP      {r4-r6,pc}
                  |L23.26|
00001a  462a              MOV      r2,r5                 ;501
00001c  4621              MOV      r1,r4                 ;501
00001e  4630              MOV      r0,r6                 ;501
000020  f7fffffe          BL       rt_memcpy
000024  4630              MOV      r0,r6                 ;503
000026  e7f7              B        |L23.24|
;;;505    RTM_EXPORT(rt_strdup);
                          ENDP


                          AREA ||i.rt_strlen||, CODE, READONLY, ALIGN=1

                  rt_strlen PROC
;;;473     */
;;;474    rt_size_t rt_strlen(const char *s)
000000  4601              MOV      r1,r0
;;;475    {
;;;476        const char *sc;
;;;477    
;;;478        for (sc = s; *sc != '\0'; ++sc) /* nothing */
000002  460a              MOV      r2,r1
000004  e000              B        |L24.8|
                  |L24.6|
000006  1c52              ADDS     r2,r2,#1
                  |L24.8|
000008  7810              LDRB     r0,[r2,#0]
00000a  2800              CMP      r0,#0
00000c  d1fb              BNE      |L24.6|
;;;479            ;
;;;480    
;;;481        return sc - s;
00000e  1a50              SUBS     r0,r2,r1
;;;482    }
000010  4770              BX       lr
;;;483    RTM_EXPORT(rt_strlen);
                          ENDP


                          AREA ||i.rt_strncmp||, CODE, READONLY, ALIGN=1

                  rt_strncmp PROC
;;;433     */
;;;434    rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
000000  b530              PUSH     {r4,r5,lr}
;;;435    {
000002  4603              MOV      r3,r0
;;;436        register signed char __res = 0;
000004  2000              MOVS     r0,#0
;;;437    
;;;438        while (count)
000006  e00b              B        |L25.32|
                  |L25.8|
;;;439        {
;;;440            if ((__res = *cs - *ct++) != 0 || !*cs++)
000008  f8115b01          LDRB     r5,[r1],#1
00000c  781c              LDRB     r4,[r3,#0]
00000e  1b64              SUBS     r4,r4,r5
000010  b264              SXTB     r4,r4
000012  0020              MOVS     r0,r4
000014  d102              BNE      |L25.28|
000016  f8135b01          LDRB     r5,[r3],#1
00001a  b905              CBNZ     r5,|L25.30|
                  |L25.28|
;;;441                break;
00001c  e002              B        |L25.36|
                  |L25.30|
;;;442            count --;
00001e  1e52              SUBS     r2,r2,#1
                  |L25.32|
000020  2a00              CMP      r2,#0                 ;438
000022  d1f1              BNE      |L25.8|
                  |L25.36|
000024  bf00              NOP                            ;441
;;;443        }
;;;444    
;;;445        return __res;
;;;446    }
000026  bd30              POP      {r4,r5,pc}
;;;447    RTM_EXPORT(rt_strncmp);
                          ENDP


                          AREA ||i.rt_strncpy||, CODE, READONLY, ALIGN=1

                  rt_strncpy PROC
;;;401     */
;;;402    char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
000000  b570              PUSH     {r4-r6,lr}
;;;403    {
000002  4603              MOV      r3,r0
;;;404        if (n != 0)
000004  b1a2              CBZ      r2,|L26.48|
;;;405        {
;;;406            char *d = dst;
000006  4618              MOV      r0,r3
;;;407            const char *s = src;
000008  460c              MOV      r4,r1
;;;408    
;;;409            do
00000a  bf00              NOP      
                  |L26.12|
;;;410            {
;;;411                if ((*d++ = *s++) == 0)
00000c  f8146b01          LDRB     r6,[r4],#1
000010  f8006b01          STRB     r6,[r0],#1
000014  b93e              CBNZ     r6,|L26.38|
;;;412                {
;;;413                    /* NUL pad the remaining n-1 bytes */
;;;414                    while (--n != 0)
000016  e002              B        |L26.30|
                  |L26.24|
;;;415                        *d++ = 0;
000018  2500              MOVS     r5,#0
00001a  f8005b01          STRB     r5,[r0],#1
                  |L26.30|
00001e  1e55              SUBS     r5,r2,#1              ;414
000020  002a              MOVS     r2,r5                 ;414
000022  d1f9              BNE      |L26.24|
;;;416                    break;
000024  e002              B        |L26.44|
                  |L26.38|
;;;417                }
;;;418            } while (--n != 0);
000026  1e55              SUBS     r5,r2,#1
000028  002a              MOVS     r2,r5
00002a  d1ef              BNE      |L26.12|
                  |L26.44|
00002c  bf00              NOP                            ;416
;;;419        }
00002e  bf00              NOP      
                  |L26.48|
;;;420    
;;;421        return (dst);
000030  4618              MOV      r0,r3
;;;422    }
000032  bd70              POP      {r4-r6,pc}
;;;423    RTM_EXPORT(rt_strncpy);
                          ENDP


                          AREA ||i.rt_strstr||, CODE, READONLY, ALIGN=1

                  rt_strstr PROC
;;;345     */
;;;346    char *rt_strstr(const char *s1, const char *s2)
000000  b5f0              PUSH     {r4-r7,lr}
;;;347    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;348        int l1, l2;
;;;349    
;;;350        l2 = rt_strlen(s2);
000006  4638              MOV      r0,r7
000008  f7fffffe          BL       rt_strlen
00000c  4605              MOV      r5,r0
;;;351        if (!l2)
00000e  b90d              CBNZ     r5,|L27.20|
;;;352            return (char *)s1;
000010  4630              MOV      r0,r6
                  |L27.18|
;;;353        l1 = rt_strlen(s1);
;;;354        while (l1 >= l2)
;;;355        {
;;;356            l1 --;
;;;357            if (!rt_memcmp(s1, s2, l2))
;;;358                return (char *)s1;
;;;359            s1 ++;
;;;360        }
;;;361    
;;;362        return RT_NULL;
;;;363    }
000012  bdf0              POP      {r4-r7,pc}
                  |L27.20|
000014  4630              MOV      r0,r6                 ;353
000016  f7fffffe          BL       rt_strlen
00001a  4604              MOV      r4,r0                 ;353
00001c  e009              B        |L27.50|
                  |L27.30|
00001e  1e64              SUBS     r4,r4,#1              ;356
000020  462a              MOV      r2,r5                 ;357
000022  4639              MOV      r1,r7                 ;357
000024  4630              MOV      r0,r6                 ;357
000026  f7fffffe          BL       rt_memcmp
00002a  b908              CBNZ     r0,|L27.48|
00002c  4630              MOV      r0,r6                 ;358
00002e  e7f0              B        |L27.18|
                  |L27.48|
000030  1c76              ADDS     r6,r6,#1              ;359
                  |L27.50|
000032  42ac              CMP      r4,r5                 ;354
000034  daf3              BGE      |L27.30|
000036  2000              MOVS     r0,#0                 ;362
000038  e7eb              B        |L27.18|
;;;364    RTM_EXPORT(rt_strstr);
                          ENDP


                          AREA ||i.rt_vsnprintf||, CODE, READONLY, ALIGN=2

                  rt_vsnprintf PROC
;;;722    
;;;723    rt_int32_t rt_vsnprintf(char       *buf,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;724                            rt_size_t   size,
;;;725                            const char *fmt,
;;;726                            va_list     args)
;;;727    {
000004  b089              SUB      sp,sp,#0x24
000006  4680              MOV      r8,r0
;;;728    #ifdef RT_PRINTF_LONGLONG
;;;729        unsigned long long num;
;;;730    #else
;;;731        rt_uint32_t num;
;;;732    #endif
;;;733        int i, len;
;;;734        char *str, *end, c;
;;;735        const char *s;
;;;736    
;;;737        rt_uint8_t base;            /* the base of number */
;;;738        rt_uint8_t flags;           /* flags to print number */
;;;739        rt_uint8_t qualifier;       /* 'h', 'l', or 'L' for integer fields */
;;;740        rt_int32_t field_width;     /* width of output field */
;;;741    
;;;742    #ifdef RT_PRINTF_PRECISION
;;;743        int precision;      /* min. # of digits for integers and max for a string */
;;;744    #endif
;;;745    
;;;746        str = buf;
000008  4644              MOV      r4,r8
;;;747        end = buf + size - 1;
00000a  980a              LDR      r0,[sp,#0x28]
00000c  4440              ADD      r0,r0,r8
00000e  1e46              SUBS     r6,r0,#1
;;;748    
;;;749        /* Make sure end is always >= buf */
;;;750        if (end < buf)
000010  4546              CMP      r6,r8
000012  d204              BCS      |L28.30|
;;;751        {
;;;752            end  = ((char *)-1);
000014  f04f36ff          MOV      r6,#0xffffffff
;;;753            size = end - buf;
000018  eba60008          SUB      r0,r6,r8
00001c  900a              STR      r0,[sp,#0x28]
                  |L28.30|
;;;754        }
;;;755    
;;;756        for (; *fmt ; ++fmt)
00001e  e16f              B        |L28.768|
                  |L28.32|
;;;757        {
;;;758            if (*fmt != '%')
000020  980b              LDR      r0,[sp,#0x2c]
000022  7800              LDRB     r0,[r0,#0]
000024  2825              CMP      r0,#0x25
000026  d006              BEQ      |L28.54|
;;;759            {
;;;760                if (str <= end)
000028  42b4              CMP      r4,r6
00002a  d802              BHI      |L28.50|
;;;761                    *str = *fmt;
00002c  980b              LDR      r0,[sp,#0x2c]
00002e  7800              LDRB     r0,[r0,#0]
000030  7020              STRB     r0,[r4,#0]
                  |L28.50|
;;;762                ++ str;
000032  1c64              ADDS     r4,r4,#1
;;;763                continue;
000034  e161              B        |L28.762|
                  |L28.54|
;;;764            }
;;;765    
;;;766            /* process flags */
;;;767            flags = 0;
000036  2500              MOVS     r5,#0
;;;768    
;;;769            while (1)
000038  e026              B        |L28.136|
                  |L28.58|
;;;770            {
;;;771                /* skips the first '%' also */
;;;772                ++ fmt;
00003a  980b              LDR      r0,[sp,#0x2c]
00003c  1c40              ADDS     r0,r0,#1
00003e  900b              STR      r0,[sp,#0x2c]
;;;773                if (*fmt == '-') flags |= LEFT;
000040  980b              LDR      r0,[sp,#0x2c]
000042  7800              LDRB     r0,[r0,#0]
000044  282d              CMP      r0,#0x2d
000046  d102              BNE      |L28.78|
000048  f0450510          ORR      r5,r5,#0x10
00004c  e01c              B        |L28.136|
                  |L28.78|
;;;774                else if (*fmt == '+') flags |= PLUS;
00004e  980b              LDR      r0,[sp,#0x2c]
000050  7800              LDRB     r0,[r0,#0]
000052  282b              CMP      r0,#0x2b
000054  d102              BNE      |L28.92|
000056  f0450504          ORR      r5,r5,#4
00005a  e015              B        |L28.136|
                  |L28.92|
;;;775                else if (*fmt == ' ') flags |= SPACE;
00005c  980b              LDR      r0,[sp,#0x2c]
00005e  7800              LDRB     r0,[r0,#0]
000060  2820              CMP      r0,#0x20
000062  d102              BNE      |L28.106|
000064  f0450508          ORR      r5,r5,#8
000068  e00e              B        |L28.136|
                  |L28.106|
;;;776                else if (*fmt == '#') flags |= SPECIAL;
00006a  980b              LDR      r0,[sp,#0x2c]
00006c  7800              LDRB     r0,[r0,#0]
00006e  2823              CMP      r0,#0x23
000070  d102              BNE      |L28.120|
000072  f0450520          ORR      r5,r5,#0x20
000076  e007              B        |L28.136|
                  |L28.120|
;;;777                else if (*fmt == '0') flags |= ZEROPAD;
000078  980b              LDR      r0,[sp,#0x2c]
00007a  7800              LDRB     r0,[r0,#0]
00007c  2830              CMP      r0,#0x30
00007e  d102              BNE      |L28.134|
000080  f0450501          ORR      r5,r5,#1
000084  e000              B        |L28.136|
                  |L28.134|
;;;778                else break;
000086  e000              B        |L28.138|
                  |L28.136|
000088  e7d7              B        |L28.58|
                  |L28.138|
00008a  bf00              NOP      
;;;779            }
;;;780    
;;;781            /* get field width */
;;;782            field_width = -1;
00008c  f04f37ff          MOV      r7,#0xffffffff
;;;783            if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
000090  980b              LDR      r0,[sp,#0x2c]
000092  7800              LDRB     r0,[r0,#0]
000094  3830              SUBS     r0,r0,#0x30
000096  280a              CMP      r0,#0xa
000098  d204              BCS      |L28.164|
00009a  a80b              ADD      r0,sp,#0x2c
00009c  f7fffffe          BL       skip_atoi
0000a0  4607              MOV      r7,r0
0000a2  e00e              B        |L28.194|
                  |L28.164|
;;;784            else if (*fmt == '*')
0000a4  980b              LDR      r0,[sp,#0x2c]
0000a6  7800              LDRB     r0,[r0,#0]
0000a8  282a              CMP      r0,#0x2a
0000aa  d10a              BNE      |L28.194|
;;;785            {
;;;786                ++ fmt;
0000ac  980b              LDR      r0,[sp,#0x2c]
0000ae  1c40              ADDS     r0,r0,#1
0000b0  900b              STR      r0,[sp,#0x2c]
;;;787                /* it's the next argument */
;;;788                field_width = va_arg(args, int);
0000b2  980c              LDR      r0,[sp,#0x30]
0000b4  c880              LDM      r0!,{r7}
0000b6  900c              STR      r0,[sp,#0x30]
;;;789                if (field_width < 0)
0000b8  2f00              CMP      r7,#0
0000ba  da02              BGE      |L28.194|
;;;790                {
;;;791                    field_width = -field_width;
0000bc  427f              RSBS     r7,r7,#0
;;;792                    flags |= LEFT;
0000be  f0450510          ORR      r5,r5,#0x10
                  |L28.194|
;;;793                }
;;;794            }
;;;795    
;;;796    #ifdef RT_PRINTF_PRECISION
;;;797            /* get the precision */
;;;798            precision = -1;
0000c2  f04f39ff          MOV      r9,#0xffffffff
;;;799            if (*fmt == '.')
0000c6  980b              LDR      r0,[sp,#0x2c]
0000c8  7800              LDRB     r0,[r0,#0]
0000ca  282e              CMP      r0,#0x2e
0000cc  d11c              BNE      |L28.264|
;;;800            {
;;;801                ++ fmt;
0000ce  980b              LDR      r0,[sp,#0x2c]
0000d0  1c40              ADDS     r0,r0,#1
0000d2  900b              STR      r0,[sp,#0x2c]
;;;802                if (isdigit(*fmt)) precision = skip_atoi(&fmt);
0000d4  980b              LDR      r0,[sp,#0x2c]
0000d6  7800              LDRB     r0,[r0,#0]
0000d8  3830              SUBS     r0,r0,#0x30
0000da  280a              CMP      r0,#0xa
0000dc  d204              BCS      |L28.232|
0000de  a80b              ADD      r0,sp,#0x2c
0000e0  f7fffffe          BL       skip_atoi
0000e4  4681              MOV      r9,r0
0000e6  e00a              B        |L28.254|
                  |L28.232|
;;;803                else if (*fmt == '*')
0000e8  980b              LDR      r0,[sp,#0x2c]
0000ea  7800              LDRB     r0,[r0,#0]
0000ec  282a              CMP      r0,#0x2a
0000ee  d106              BNE      |L28.254|
;;;804                {
;;;805                    ++ fmt;
0000f0  980b              LDR      r0,[sp,#0x2c]
0000f2  1c40              ADDS     r0,r0,#1
0000f4  900b              STR      r0,[sp,#0x2c]
;;;806                    /* it's the next argument */
;;;807                    precision = va_arg(args, int);
0000f6  980c              LDR      r0,[sp,#0x30]
0000f8  f8509b04          LDR      r9,[r0],#4
0000fc  900c              STR      r0,[sp,#0x30]
                  |L28.254|
;;;808                }
;;;809                if (precision < 0) precision = 0;
0000fe  f1b90f00          CMP      r9,#0
000102  da01              BGE      |L28.264|
000104  f04f0900          MOV      r9,#0
                  |L28.264|
;;;810            }
;;;811    #endif
;;;812            /* get the conversion qualifier */
;;;813            qualifier = 0;
000108  2000              MOVS     r0,#0
00010a  9004              STR      r0,[sp,#0x10]
;;;814    #ifdef RT_PRINTF_LONGLONG
;;;815            if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
;;;816    #else
;;;817            if (*fmt == 'h' || *fmt == 'l')
00010c  980b              LDR      r0,[sp,#0x2c]
00010e  7800              LDRB     r0,[r0,#0]
000110  2868              CMP      r0,#0x68
000112  d003              BEQ      |L28.284|
000114  980b              LDR      r0,[sp,#0x2c]
000116  7800              LDRB     r0,[r0,#0]
000118  286c              CMP      r0,#0x6c
00011a  d105              BNE      |L28.296|
                  |L28.284|
;;;818    #endif
;;;819            {
;;;820                qualifier = *fmt;
00011c  980b              LDR      r0,[sp,#0x2c]
00011e  7800              LDRB     r0,[r0,#0]
000120  9004              STR      r0,[sp,#0x10]
;;;821                ++ fmt;
000122  980b              LDR      r0,[sp,#0x2c]
000124  1c40              ADDS     r0,r0,#1
000126  900b              STR      r0,[sp,#0x2c]
                  |L28.296|
;;;822    #ifdef RT_PRINTF_LONGLONG
;;;823                if (qualifier == 'l' && *fmt == 'l')
;;;824                {
;;;825                    qualifier = 'L';
;;;826                    ++ fmt;
;;;827                }
;;;828    #endif
;;;829            }
;;;830    
;;;831            /* the default base */
;;;832            base = 10;
000128  200a              MOVS     r0,#0xa
00012a  9005              STR      r0,[sp,#0x14]
;;;833    
;;;834            switch (*fmt)
00012c  980b              LDR      r0,[sp,#0x2c]
00012e  7800              LDRB     r0,[r0,#0]
000130  286f              CMP      r0,#0x6f
000132  d075              BEQ      |L28.544|
000134  dc0c              BGT      |L28.336|
000136  2863              CMP      r0,#0x63
000138  d013              BEQ      |L28.354|
00013a  dc04              BGT      |L28.326|
00013c  2825              CMP      r0,#0x25
00013e  d070              BEQ      |L28.546|
000140  2858              CMP      r0,#0x58
                  |L28.322|
000142  d16f              BNE      |L28.548|
000144  e08d              B        |L28.610|
                  |L28.326|
000146  2864              CMP      r0,#0x64
000148  d06d              BEQ      |L28.550|
00014a  2869              CMP      r0,#0x69
00014c  d1f9              BNE      |L28.322|
00014e  e08f              B        |L28.624|
                  |L28.336|
000150  2870              CMP      r0,#0x70
000152  d06a              BEQ      |L28.554|
000154  2873              CMP      r0,#0x73
000156  d025              BEQ      |L28.420|
000158  2875              CMP      r0,#0x75
00015a  d078              BEQ      |L28.590|
00015c  2878              CMP      r0,#0x78
00015e  d1f0              BNE      |L28.322|
000160  e082              B        |L28.616|
                  |L28.354|
;;;835            {
;;;836            case 'c':
;;;837                if (!(flags & LEFT))
000162  f0050010          AND      r0,r5,#0x10
000166  b940              CBNZ     r0,|L28.378|
;;;838                {
;;;839                    while (--field_width > 0)
000168  e004              B        |L28.372|
                  |L28.362|
;;;840                    {
;;;841                        if (str <= end) *str = ' ';
00016a  42b4              CMP      r4,r6
00016c  d801              BHI      |L28.370|
00016e  2020              MOVS     r0,#0x20
000170  7020              STRB     r0,[r4,#0]
                  |L28.370|
;;;842                        ++ str;
000172  1c64              ADDS     r4,r4,#1
                  |L28.372|
000174  1e78              SUBS     r0,r7,#1              ;839
000176  1e07              SUBS     r7,r0,#0              ;839
000178  dcf7              BGT      |L28.362|
                  |L28.378|
;;;843                    }
;;;844                }
;;;845    
;;;846                /* get character */
;;;847                c = (rt_uint8_t)va_arg(args, int);
00017a  980c              LDR      r0,[sp,#0x30]
00017c  f8101b04          LDRB     r1,[r0],#4
000180  900c              STR      r0,[sp,#0x30]
000182  b2c8              UXTB     r0,r1
000184  9007              STR      r0,[sp,#0x1c]
;;;848                if (str <= end) *str = c;
000186  42b4              CMP      r4,r6
000188  d801              BHI      |L28.398|
00018a  9807              LDR      r0,[sp,#0x1c]
00018c  7020              STRB     r0,[r4,#0]
                  |L28.398|
;;;849                ++ str;
00018e  1c64              ADDS     r4,r4,#1
;;;850    
;;;851                /* put width */
;;;852                while (--field_width > 0)
000190  e004              B        |L28.412|
                  |L28.402|
;;;853                {
;;;854                    if (str <= end) *str = ' ';
000192  42b4              CMP      r4,r6
000194  d801              BHI      |L28.410|
000196  2020              MOVS     r0,#0x20
000198  7020              STRB     r0,[r4,#0]
                  |L28.410|
;;;855                    ++ str;
00019a  1c64              ADDS     r4,r4,#1
                  |L28.412|
00019c  1e78              SUBS     r0,r7,#1              ;852
00019e  1e07              SUBS     r7,r0,#0              ;852
0001a0  dcf7              BGT      |L28.402|
;;;856                }
;;;857                continue;
0001a2  e0aa              B        |L28.762|
                  |L28.420|
;;;858    
;;;859            case 's':
;;;860                s = va_arg(args, char *);
0001a4  980c              LDR      r0,[sp,#0x30]
0001a6  6800              LDR      r0,[r0,#0]
0001a8  9006              STR      r0,[sp,#0x18]
0001aa  980c              LDR      r0,[sp,#0x30]
0001ac  1d00              ADDS     r0,r0,#4
0001ae  900c              STR      r0,[sp,#0x30]
;;;861                if (!s) s = "(NULL)";
0001b0  9806              LDR      r0,[sp,#0x18]
0001b2  b908              CBNZ     r0,|L28.440|
0001b4  a05a              ADR      r0,|L28.800|
0001b6  9006              STR      r0,[sp,#0x18]
                  |L28.440|
;;;862    
;;;863                len = rt_strlen(s);
0001b8  9806              LDR      r0,[sp,#0x18]
0001ba  f7fffffe          BL       rt_strlen
0001be  4683              MOV      r11,r0
;;;864    #ifdef RT_PRINTF_PRECISION
;;;865                if (precision > 0 && len > precision) len = precision;
0001c0  f1b90f00          CMP      r9,#0
0001c4  dd02              BLE      |L28.460|
0001c6  45cb              CMP      r11,r9
0001c8  dd00              BLE      |L28.460|
0001ca  46cb              MOV      r11,r9
                  |L28.460|
;;;866    #endif
;;;867    
;;;868                if (!(flags & LEFT))
0001cc  f0050010          AND      r0,r5,#0x10
0001d0  b948              CBNZ     r0,|L28.486|
;;;869                {
;;;870                    while (len < field_width--)
0001d2  e004              B        |L28.478|
                  |L28.468|
;;;871                    {
;;;872                        if (str <= end) *str = ' ';
0001d4  42b4              CMP      r4,r6
0001d6  d801              BHI      |L28.476|
0001d8  2020              MOVS     r0,#0x20
0001da  7020              STRB     r0,[r4,#0]
                  |L28.476|
;;;873                        ++ str;
0001dc  1c64              ADDS     r4,r4,#1
                  |L28.478|
0001de  4638              MOV      r0,r7                 ;870
0001e0  1e7f              SUBS     r7,r7,#1              ;870
0001e2  4558              CMP      r0,r11                ;870
0001e4  dcf6              BGT      |L28.468|
                  |L28.486|
;;;874                    }
;;;875                }
;;;876    
;;;877                for (i = 0; i < len; ++i)
0001e6  2000              MOVS     r0,#0
0001e8  9008              STR      r0,[sp,#0x20]
0001ea  e00b              B        |L28.516|
                  |L28.492|
;;;878                {
;;;879                    if (str <= end) *str = *s;
0001ec  42b4              CMP      r4,r6
0001ee  d802              BHI      |L28.502|
0001f0  9806              LDR      r0,[sp,#0x18]
0001f2  7800              LDRB     r0,[r0,#0]
0001f4  7020              STRB     r0,[r4,#0]
                  |L28.502|
;;;880                    ++ str;
0001f6  1c64              ADDS     r4,r4,#1
;;;881                    ++ s;
0001f8  9806              LDR      r0,[sp,#0x18]
0001fa  1c40              ADDS     r0,r0,#1
0001fc  9006              STR      r0,[sp,#0x18]
0001fe  9808              LDR      r0,[sp,#0x20]         ;877
000200  1c40              ADDS     r0,r0,#1              ;877
000202  9008              STR      r0,[sp,#0x20]         ;877
                  |L28.516|
000204  9808              LDR      r0,[sp,#0x20]         ;877
000206  4558              CMP      r0,r11                ;877
000208  dbf0              BLT      |L28.492|
;;;882                }
;;;883    
;;;884                while (len < field_width--)
00020a  e004              B        |L28.534|
                  |L28.524|
;;;885                {
;;;886                    if (str <= end) *str = ' ';
00020c  42b4              CMP      r4,r6
00020e  d801              BHI      |L28.532|
000210  2020              MOVS     r0,#0x20
000212  7020              STRB     r0,[r4,#0]
                  |L28.532|
;;;887                    ++ str;
000214  1c64              ADDS     r4,r4,#1
                  |L28.534|
000216  4638              MOV      r0,r7                 ;884
000218  1e7f              SUBS     r7,r7,#1              ;884
00021a  4558              CMP      r0,r11                ;884
00021c  dcf6              BGT      |L28.524|
;;;888                }
;;;889                continue;
00021e  e06c              B        |L28.762|
                  |L28.544|
000220  e01c              B        |L28.604|
                  |L28.546|
000222  e015              B        |L28.592|
                  |L28.548|
000224  e028              B        |L28.632|
                  |L28.550|
000226  e022              B        |L28.622|
000228  e7ff              B        |L28.554|
                  |L28.554|
;;;890    
;;;891            case 'p':
;;;892                if (field_width == -1)
00022a  1c78              ADDS     r0,r7,#1
00022c  b910              CBNZ     r0,|L28.564|
;;;893                {
;;;894                    field_width = sizeof(void *) << 1;
00022e  2708              MOVS     r7,#8
;;;895                    flags |= ZEROPAD;
000230  f0450501          ORR      r5,r5,#1
                  |L28.564|
;;;896                }
;;;897    #ifdef RT_PRINTF_PRECISION
;;;898                str = print_number(str, end,
000234  e9cd7900          STRD     r7,r9,[sp,#0]
000238  9502              STR      r5,[sp,#8]
00023a  980c              LDR      r0,[sp,#0x30]
00023c  c804              LDM      r0!,{r2}
00023e  2310              MOVS     r3,#0x10
000240  4631              MOV      r1,r6
000242  900c              STR      r0,[sp,#0x30]
000244  4620              MOV      r0,r4
000246  f7fffffe          BL       print_number
00024a  4604              MOV      r4,r0
;;;899                                   (long)va_arg(args, void *),
;;;900                                   16, field_width, precision, flags);
;;;901    #else
;;;902                str = print_number(str, end,
;;;903                                   (long)va_arg(args, void *),
;;;904                                   16, field_width, flags);
;;;905    #endif
;;;906                continue;
00024c  e055              B        |L28.762|
                  |L28.590|
00024e  e012              B        |L28.630|
                  |L28.592|
;;;907    
;;;908            case '%':
;;;909                if (str <= end) *str = '%';
000250  42b4              CMP      r4,r6
000252  d801              BHI      |L28.600|
000254  2025              MOVS     r0,#0x25
000256  7020              STRB     r0,[r4,#0]
                  |L28.600|
;;;910                ++ str;
000258  1c64              ADDS     r4,r4,#1
;;;911                continue;
00025a  e04e              B        |L28.762|
                  |L28.604|
;;;912    
;;;913                /* integer number formats - set up the flags and "break" */
;;;914            case 'o':
;;;915                base = 8;
00025c  2008              MOVS     r0,#8
00025e  9005              STR      r0,[sp,#0x14]
;;;916                break;
000260  e01d              B        |L28.670|
                  |L28.610|
;;;917    
;;;918            case 'X':
;;;919                flags |= LARGE;
000262  f0450540          ORR      r5,r5,#0x40
;;;920            case 'x':
000266  bf00              NOP      
                  |L28.616|
;;;921                base = 16;
000268  2010              MOVS     r0,#0x10
00026a  9005              STR      r0,[sp,#0x14]
;;;922                break;
00026c  e017              B        |L28.670|
                  |L28.622|
;;;923    
;;;924            case 'd':
;;;925            case 'i':
00026e  bf00              NOP      
                  |L28.624|
;;;926                flags |= SIGN;
000270  f0450502          ORR      r5,r5,#2
;;;927            case 'u':
000274  bf00              NOP      
                  |L28.630|
;;;928                break;
000276  e012              B        |L28.670|
                  |L28.632|
;;;929    
;;;930            default:
;;;931                if (str <= end) *str = '%';
000278  42b4              CMP      r4,r6
00027a  d801              BHI      |L28.640|
00027c  2025              MOVS     r0,#0x25
00027e  7020              STRB     r0,[r4,#0]
                  |L28.640|
;;;932                ++ str;
000280  1c64              ADDS     r4,r4,#1
;;;933    
;;;934                if (*fmt)
000282  980b              LDR      r0,[sp,#0x2c]
000284  7800              LDRB     r0,[r0,#0]
000286  b130              CBZ      r0,|L28.662|
;;;935                {
;;;936                    if (str <= end) *str = *fmt;
000288  42b4              CMP      r4,r6
00028a  d802              BHI      |L28.658|
00028c  980b              LDR      r0,[sp,#0x2c]
00028e  7800              LDRB     r0,[r0,#0]
000290  7020              STRB     r0,[r4,#0]
                  |L28.658|
;;;937                    ++ str;
000292  1c64              ADDS     r4,r4,#1
000294  e002              B        |L28.668|
                  |L28.662|
;;;938                }
;;;939                else
;;;940                {
;;;941                    -- fmt;
000296  980b              LDR      r0,[sp,#0x2c]
000298  1e40              SUBS     r0,r0,#1
00029a  900b              STR      r0,[sp,#0x2c]
                  |L28.668|
;;;942                }
;;;943                continue;
00029c  e02d              B        |L28.762|
                  |L28.670|
00029e  bf00              NOP                            ;916
;;;944            }
;;;945    
;;;946    #ifdef RT_PRINTF_LONGLONG
;;;947            if (qualifier == 'L') num = va_arg(args, long long);
;;;948            else if (qualifier == 'l')
;;;949    #else
;;;950            if (qualifier == 'l')
0002a0  9804              LDR      r0,[sp,#0x10]
0002a2  286c              CMP      r0,#0x6c
0002a4  d107              BNE      |L28.694|
;;;951    #endif
;;;952            {
;;;953                num = va_arg(args, rt_uint32_t);
0002a6  980c              LDR      r0,[sp,#0x30]
0002a8  f850ab04          LDR      r10,[r0],#4
0002ac  900c              STR      r0,[sp,#0x30]
;;;954                if (flags & SIGN) num = (rt_int32_t)num;
0002ae  f0050002          AND      r0,r5,#2
0002b2  b1b8              CBZ      r0,|L28.740|
0002b4  e016              B        |L28.740|
                  |L28.694|
;;;955            }
;;;956            else if (qualifier == 'h')
0002b6  9804              LDR      r0,[sp,#0x10]
0002b8  2868              CMP      r0,#0x68
0002ba  d10b              BNE      |L28.724|
;;;957            {
;;;958                num = (rt_uint16_t)va_arg(args, rt_int32_t);
0002bc  980c              LDR      r0,[sp,#0x30]
0002be  f8301b04          LDRH     r1,[r0],#4
0002c2  fa1ffa81          UXTH     r10,r1
0002c6  900c              STR      r0,[sp,#0x30]
;;;959                if (flags & SIGN) num = (rt_int16_t)num;
0002c8  f0050002          AND      r0,r5,#2
0002cc  b150              CBZ      r0,|L28.740|
0002ce  fa0ffa8a          SXTH     r10,r10
0002d2  e007              B        |L28.740|
                  |L28.724|
;;;960            }
;;;961            else
;;;962            {
;;;963                num = va_arg(args, rt_uint32_t);
0002d4  980c              LDR      r0,[sp,#0x30]
0002d6  f850ab04          LDR      r10,[r0],#4
0002da  900c              STR      r0,[sp,#0x30]
;;;964                if (flags & SIGN) num = (rt_int32_t)num;
0002dc  f0050002          AND      r0,r5,#2
0002e0  b100              CBZ      r0,|L28.740|
0002e2  bf00              NOP      
                  |L28.740|
;;;965            }
;;;966    #ifdef RT_PRINTF_PRECISION
;;;967            str = print_number(str, end, num, base, field_width, precision, flags);
0002e4  e9cd7900          STRD     r7,r9,[sp,#0]
0002e8  9502              STR      r5,[sp,#8]
0002ea  4652              MOV      r2,r10
0002ec  4631              MOV      r1,r6
0002ee  4620              MOV      r0,r4
0002f0  9b05              LDR      r3,[sp,#0x14]
0002f2  f7fffffe          BL       print_number
0002f6  4604              MOV      r4,r0
0002f8  bf00              NOP                            ;763
                  |L28.762|
0002fa  980b              LDR      r0,[sp,#0x2c]         ;756
0002fc  1c40              ADDS     r0,r0,#1              ;756
0002fe  900b              STR      r0,[sp,#0x2c]         ;756
                  |L28.768|
000300  980b              LDR      r0,[sp,#0x2c]         ;756
000302  7800              LDRB     r0,[r0,#0]            ;756
000304  2800              CMP      r0,#0                 ;756
000306  f47fae8b          BNE      |L28.32|
;;;968    #else
;;;969            str = print_number(str, end, num, base, field_width, flags);
;;;970    #endif
;;;971        }
;;;972    
;;;973        if (str <= end) *str = '\0';
00030a  42b4              CMP      r4,r6
00030c  d801              BHI      |L28.786|
00030e  7020              STRB     r0,[r4,#0]
000310  e001              B        |L28.790|
                  |L28.786|
;;;974        else *end = '\0';
000312  2000              MOVS     r0,#0
000314  7030              STRB     r0,[r6,#0]
                  |L28.790|
;;;975    
;;;976        /* the trailing null byte doesn't count towards the total
;;;977        * ++str;
;;;978        */
;;;979        return str - buf;
000316  eba40008          SUB      r0,r4,r8
;;;980    }
00031a  b00d              ADD      sp,sp,#0x34
00031c  e8bd8ff0          POP      {r4-r11,pc}
;;;981    RTM_EXPORT(rt_vsnprintf);
                          ENDP

                  |L28.800|
000320  284e554c          DCB      "(NULL)",0
000324  4c2900  
000327  00                DCB      0

                          AREA ||i.rt_vsprintf||, CODE, READONLY, ALIGN=1

                  rt_vsprintf PROC
;;;1009    */
;;;1010   rt_int32_t rt_vsprintf(char *buf, const char *format, va_list arg_ptr)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;1011   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1012       return rt_vsnprintf(buf, (rt_size_t) -1, format, arg_ptr);
000006  4622              MOV      r2,r4
000008  f04f31ff          MOV      r1,#0xffffffff
00000c  4628              MOV      r0,r5
00000e  9b02              LDR      r3,[sp,#8]
000010  f7fffffe          BL       rt_vsnprintf
;;;1013   }
000014  bd3e              POP      {r1-r5,pc}
;;;1014   RTM_EXPORT(rt_vsprintf);
                          ENDP


                          AREA ||i.skip_atoi||, CODE, READONLY, ALIGN=1

                  skip_atoi PROC
;;;542    
;;;543    rt_inline int skip_atoi(const char **s)
000000  4601              MOV      r1,r0
;;;544    {
;;;545        register int i=0;
000002  2000              MOVS     r0,#0
;;;546        while (isdigit(**s))
000004  e009              B        |L30.26|
                  |L30.6|
;;;547            i = i * 10 + *((*s)++) - '0';
000006  680b              LDR      r3,[r1,#0]
000008  1c5a              ADDS     r2,r3,#1
00000a  600a              STR      r2,[r1,#0]
00000c  781a              LDRB     r2,[r3,#0]
00000e  eb000380          ADD      r3,r0,r0,LSL #2
000012  eb020243          ADD      r2,r2,r3,LSL #1
000016  f1a20030          SUB      r0,r2,#0x30
                  |L30.26|
00001a  680a              LDR      r2,[r1,#0]            ;546
00001c  7812              LDRB     r2,[r2,#0]            ;546
00001e  3a30              SUBS     r2,r2,#0x30           ;546
000020  2a0a              CMP      r2,#0xa               ;546
000022  d3f0              BCC      |L30.6|
;;;548    
;;;549        return i;
;;;550    }
000024  4770              BX       lr
;;;551    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  rt_log_buf
                          %        128

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __lowest_bit_bitmap
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00
                  small_digits
000100  30313233          DCB      0x30,0x31,0x32,0x33
000104  34353637          DCB      0x34,0x35,0x36,0x37
000108  38396162          DCB      0x38,0x39,0x61,0x62
00010c  63646566          DCB      0x63,0x64,0x65,0x66
000110  00                DCB      0x00
                  large_digits
000111  303132            DCB      0x30,0x31,0x32
000114  33343536          DCB      0x33,0x34,0x35,0x36
000118  37383941          DCB      0x37,0x38,0x39,0x41
00011c  42434445          DCB      0x42,0x43,0x44,0x45
000120  4600              DCB      0x46,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  _errno
                          DCD      0x00000000
                  _console_device
                          DCD      0x00000000
                  rt_assert_hook
                          DCD      0x00000000
