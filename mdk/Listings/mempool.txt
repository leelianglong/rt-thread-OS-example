; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mempool.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mempool.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\mempool.crf ..\rt_thread\kernel\mempool.c]
                          THUMB

                          AREA ||i.rt_list_init||, CODE, READONLY, ALIGN=1

                  rt_list_init PROC
;;;50      */
;;;51     rt_inline void rt_list_init(rt_list_t *l)
000000  6040              STR      r0,[r0,#4]
;;;52     {
;;;53         l->next = l->prev = l;
000002  6000              STR      r0,[r0,#0]
;;;54     }
000004  4770              BX       lr
;;;55     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;101     */
;;;102    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  4601              MOV      r1,r0
;;;103    {
;;;104        return l->next == l;
000002  6808              LDR      r0,[r1,#0]
000004  4288              CMP      r0,r1
000006  d101              BNE      |L2.12|
000008  2001              MOVS     r0,#1
                  |L2.10|
;;;105    }
00000a  4770              BX       lr
                  |L2.12|
00000c  2000              MOVS     r0,#0                 ;104
00000e  e7fc              B        |L2.10|
;;;106    
                          ENDP


                          AREA ||i.rt_mp_alloc||, CODE, READONLY, ALIGN=2

                  rt_mp_alloc PROC
;;;320     */
;;;321    void *rt_mp_alloc(rt_mp_t mp, rt_int32_t time)
000000  e92d47f3          PUSH     {r0,r1,r4-r10,lr}
;;;322    {
000004  4604              MOV      r4,r0
;;;323        rt_uint8_t *block_ptr;
;;;324        register rt_base_t level;
;;;325        struct rt_thread *thread;
;;;326        rt_uint32_t before_sleep = 0;
000006  f04f0800          MOV      r8,#0
;;;327    
;;;328        /* get current thread */
;;;329        thread = rt_thread_self();
00000a  f7fffffe          BL       rt_thread_self
00000e  4606              MOV      r6,r0
;;;330    
;;;331        /* disable interrupt */
;;;332        level = rt_hw_interrupt_disable();
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4607              MOV      r7,r0
;;;333    
;;;334        while (mp->block_free_count == 0)
000016  e05e              B        |L3.214|
                  |L3.24|
;;;335        {
;;;336            /* memory block is unavailable. */
;;;337            if (time == 0)
000018  9801              LDR      r0,[sp,#4]
00001a  b948              CBNZ     r0,|L3.48|
;;;338            {
;;;339                /* enable interrupt */
;;;340                rt_hw_interrupt_enable(level);
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       rt_hw_interrupt_enable
;;;341    
;;;342                rt_set_errno(-RT_ETIMEOUT);
000022  f06f0001          MVN      r0,#1
000026  f7fffffe          BL       rt_set_errno
;;;343    
;;;344                return RT_NULL;
00002a  2000              MOVS     r0,#0
                  |L3.44|
;;;345            }
;;;346    
;;;347            RT_DEBUG_NOT_IN_INTERRUPT;
;;;348    
;;;349            thread->error = RT_EOK;
;;;350    
;;;351            /* need suspend thread */
;;;352            rt_thread_suspend(thread);
;;;353            rt_list_insert_after(&(mp->suspend_thread), &(thread->tlist));
;;;354            mp->suspend_thread_count++;
;;;355    
;;;356            if (time > 0)
;;;357            {
;;;358                /* get the start tick of timer */
;;;359                before_sleep = rt_tick_get();
;;;360    
;;;361                /* init thread timer and start it */
;;;362                rt_timer_control(&(thread->thread_timer),
;;;363                                 RT_TIMER_CTRL_SET_TIME,
;;;364                                 &time);
;;;365                rt_timer_start(&(thread->thread_timer));
;;;366            }
;;;367    
;;;368            /* enable interrupt */
;;;369            rt_hw_interrupt_enable(level);
;;;370    
;;;371            /* do a schedule */
;;;372            rt_schedule();
;;;373    
;;;374            if (thread->error != RT_EOK)
;;;375                return RT_NULL;
;;;376    
;;;377            if (time > 0)
;;;378            {
;;;379                time -= rt_tick_get() - before_sleep;
;;;380                if (time < 0)
;;;381                    time = 0;
;;;382            }
;;;383            /* disable interrupt */
;;;384            level = rt_hw_interrupt_disable();
;;;385        }
;;;386    
;;;387        /* memory block is available. decrease the free block counter */
;;;388        mp->block_free_count--;
;;;389    
;;;390        /* get block from block list */
;;;391        block_ptr = mp->block_list;
;;;392        RT_ASSERT(block_ptr != RT_NULL);
;;;393    
;;;394        /* Setup the next free node. */
;;;395        mp->block_list = *(rt_uint8_t **)block_ptr;
;;;396    
;;;397        /* point to memory pool */
;;;398        *(rt_uint8_t **)block_ptr = (rt_uint8_t *)mp;
;;;399    
;;;400        /* enable interrupt */
;;;401        rt_hw_interrupt_enable(level);
;;;402    
;;;403        RT_OBJECT_HOOK_CALL(rt_mp_alloc_hook,
;;;404                            (mp, (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *))));
;;;405    
;;;406        return (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *));
;;;407    }
00002c  e8bd87fc          POP      {r2-r10,pc}
                  |L3.48|
000030  bf00              NOP                            ;347
000032  f7fffffe          BL       rt_hw_interrupt_disable
000036  4681              MOV      r9,r0                 ;347
000038  f7fffffe          BL       rt_interrupt_get_nest
00003c  b148              CBZ      r0,|L3.82|
00003e  4936              LDR      r1,|L3.280|
000040  a036              ADR      r0,|L3.284|
000042  f7fffffe          BL       rt_kprintf
000046  f240125b          MOV      r2,#0x15b             ;347
00004a  4933              LDR      r1,|L3.280|
00004c  a03c              ADR      r0,|L3.320|
00004e  f7fffffe          BL       rt_assert_handler
                  |L3.82|
000052  4648              MOV      r0,r9                 ;347
000054  f7fffffe          BL       rt_hw_interrupt_enable
000058  bf00              NOP                            ;347
00005a  2000              MOVS     r0,#0                 ;349
00005c  6330              STR      r0,[r6,#0x30]         ;349
00005e  4630              MOV      r0,r6                 ;352
000060  f7fffffe          BL       rt_thread_suspend
000064  f104002c          ADD      r0,r4,#0x2c           ;353
000068  f1060114          ADD      r1,r6,#0x14           ;353
00006c  6802              LDR      r2,[r0,#0]            ;353
00006e  6051              STR      r1,[r2,#4]            ;353
000070  6802              LDR      r2,[r0,#0]            ;353
000072  600a              STR      r2,[r1,#0]            ;353
000074  6001              STR      r1,[r0,#0]            ;353
000076  6048              STR      r0,[r1,#4]            ;353
000078  bf00              NOP                            ;353
00007a  6b60              LDR      r0,[r4,#0x34]         ;354
00007c  1c40              ADDS     r0,r0,#1              ;354
00007e  6360              STR      r0,[r4,#0x34]         ;354
000080  9801              LDR      r0,[sp,#4]            ;356
000082  2800              CMP      r0,#0                 ;356
000084  dd0c              BLE      |L3.160|
000086  f7fffffe          BL       rt_tick_get
00008a  4680              MOV      r8,r0                 ;359
00008c  aa01              ADD      r2,sp,#4              ;362
00008e  2100              MOVS     r1,#0                 ;362
000090  f106004c          ADD      r0,r6,#0x4c           ;362
000094  f7fffffe          BL       rt_timer_control
000098  f106004c          ADD      r0,r6,#0x4c           ;365
00009c  f7fffffe          BL       rt_timer_start
                  |L3.160|
0000a0  4638              MOV      r0,r7                 ;369
0000a2  f7fffffe          BL       rt_hw_interrupt_enable
0000a6  f7fffffe          BL       rt_schedule
0000aa  6b30              LDR      r0,[r6,#0x30]         ;374
0000ac  b108              CBZ      r0,|L3.178|
0000ae  2000              MOVS     r0,#0                 ;375
0000b0  e7bc              B        |L3.44|
                  |L3.178|
0000b2  9801              LDR      r0,[sp,#4]            ;377
0000b4  2800              CMP      r0,#0                 ;377
0000b6  dd0b              BLE      |L3.208|
0000b8  f7fffffe          BL       rt_tick_get
0000bc  eba00008          SUB      r0,r0,r8              ;379
0000c0  9901              LDR      r1,[sp,#4]            ;379
0000c2  1a08              SUBS     r0,r1,r0              ;379
0000c4  9001              STR      r0,[sp,#4]            ;379
0000c6  9801              LDR      r0,[sp,#4]            ;380
0000c8  2800              CMP      r0,#0                 ;380
0000ca  da01              BGE      |L3.208|
0000cc  2000              MOVS     r0,#0                 ;381
0000ce  9001              STR      r0,[sp,#4]            ;381
                  |L3.208|
0000d0  f7fffffe          BL       rt_hw_interrupt_disable
0000d4  4607              MOV      r7,r0                 ;384
                  |L3.214|
0000d6  6aa0              LDR      r0,[r4,#0x28]         ;334
0000d8  2800              CMP      r0,#0                 ;334
0000da  d09d              BEQ      |L3.24|
0000dc  6aa0              LDR      r0,[r4,#0x28]         ;388
0000de  1e40              SUBS     r0,r0,#1              ;388
0000e0  62a0              STR      r0,[r4,#0x28]         ;388
0000e2  6a25              LDR      r5,[r4,#0x20]         ;391
0000e4  b92d              CBNZ     r5,|L3.242|
0000e6  f44f72c4          MOV      r2,#0x188             ;392
0000ea  490b              LDR      r1,|L3.280|
0000ec  a015              ADR      r0,|L3.324|
0000ee  f7fffffe          BL       rt_assert_handler
                  |L3.242|
0000f2  6828              LDR      r0,[r5,#0]            ;395
0000f4  6220              STR      r0,[r4,#0x20]         ;395
0000f6  602c              STR      r4,[r5,#0]            ;398
0000f8  4638              MOV      r0,r7                 ;401
0000fa  f7fffffe          BL       rt_hw_interrupt_enable
0000fe  bf00              NOP                            ;403
000100  4816              LDR      r0,|L3.348|
000102  6800              LDR      r0,[r0,#0]            ;403  ; rt_mp_alloc_hook
000104  b120              CBZ      r0,|L3.272|
000106  1d29              ADDS     r1,r5,#4              ;403
000108  4620              MOV      r0,r4                 ;403
00010a  4a14              LDR      r2,|L3.348|
00010c  6812              LDR      r2,[r2,#0]            ;403  ; rt_mp_alloc_hook
00010e  4790              BLX      r2                    ;403
                  |L3.272|
000110  bf00              NOP                            ;403
000112  1d28              ADDS     r0,r5,#4              ;406
000114  e78a              B        |L3.44|
;;;408    RTM_EXPORT(rt_mp_alloc);
                          ENDP

000116  0000              DCW      0x0000
                  |L3.280|
                          DCD      |symbol_number.37|
                  |L3.284|
00011c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000120  74696f6e
000124  5b25735d
000128  20736861
00012c  6c6c206e
000130  6f742075
000134  73656420
000138  696e2049
00013c  53520a00
                  |L3.320|
000140  3000              DCB      "0",0
000142  00                DCB      0
000143  00                DCB      0
                  |L3.324|
000144  626c6f63          DCB      "block_ptr != RT_NULL",0
000148  6b5f7074
00014c  7220213d
000150  2052545f
000154  4e554c4c
000158  00      
000159  00                DCB      0
00015a  00                DCB      0
00015b  00                DCB      0
                  |L3.348|
                          DCD      rt_mp_alloc_hook

                          AREA ||i.rt_mp_alloc_sethook||, CODE, READONLY, ALIGN=2

                  rt_mp_alloc_sethook PROC
;;;53      */
;;;54     void rt_mp_alloc_sethook(void (*hook)(struct rt_mempool *mp, void *block))
000000  4901              LDR      r1,|L4.8|
;;;55     {
;;;56         rt_mp_alloc_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_mp_alloc_hook
;;;57     }
000004  4770              BX       lr
;;;58     
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      rt_mp_alloc_hook

                          AREA ||i.rt_mp_create||, CODE, READONLY, ALIGN=2

                  rt_mp_create PROC
;;;196     */
;;;197    rt_mp_t rt_mp_create(const char *name,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;198                         rt_size_t   block_count,
;;;199                         rt_size_t   block_size)
;;;200    {
000004  4681              MOV      r9,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;201        rt_uint8_t *block_ptr;
;;;202        struct rt_mempool *mp;
;;;203        register rt_base_t offset;
;;;204    
;;;205        RT_DEBUG_NOT_IN_INTERRUPT;
00000a  bf00              NOP      
00000c  f7fffffe          BL       rt_hw_interrupt_disable
000010  4682              MOV      r10,r0
000012  f7fffffe          BL       rt_interrupt_get_nest
000016  b140              CBZ      r0,|L5.42|
000018  4925              LDR      r1,|L5.176|
00001a  a026              ADR      r0,|L5.180|
00001c  f7fffffe          BL       rt_kprintf
000020  22cd              MOVS     r2,#0xcd
000022  4923              LDR      r1,|L5.176|
000024  a02c              ADR      r0,|L5.216|
000026  f7fffffe          BL       rt_assert_handler
                  |L5.42|
00002a  4650              MOV      r0,r10
00002c  f7fffffe          BL       rt_hw_interrupt_enable
000030  bf00              NOP      
;;;206    
;;;207        /* allocate object */
;;;208        mp = (struct rt_mempool *)rt_object_allocate(RT_Object_Class_MemPool, name);
000032  4649              MOV      r1,r9
000034  2006              MOVS     r0,#6
000036  f7fffffe          BL       rt_object_allocate
00003a  4604              MOV      r4,r0
;;;209        /* allocate object failed */
;;;210        if (mp == RT_NULL)
00003c  b914              CBNZ     r4,|L5.68|
;;;211            return RT_NULL;
00003e  2000              MOVS     r0,#0
                  |L5.64|
;;;212    
;;;213        /* initialize memory pool */
;;;214        block_size     = RT_ALIGN(block_size, RT_ALIGN_SIZE);
;;;215        mp->block_size = block_size;
;;;216        mp->size       = (block_size + sizeof(rt_uint8_t *)) * block_count;
;;;217    
;;;218        /* allocate memory */
;;;219        mp->start_address = rt_malloc((block_size + sizeof(rt_uint8_t *)) *
;;;220                                      block_count);
;;;221        if (mp->start_address == RT_NULL)
;;;222        {
;;;223            /* no memory, delete memory pool object */
;;;224            rt_object_delete(&(mp->parent));
;;;225    
;;;226            return RT_NULL;
;;;227        }
;;;228    
;;;229        mp->block_total_count = block_count;
;;;230        mp->block_free_count  = mp->block_total_count;
;;;231    
;;;232        /* initialize suspended thread list */
;;;233        rt_list_init(&(mp->suspend_thread));
;;;234        mp->suspend_thread_count = 0;
;;;235    
;;;236        /* initialize free block list */
;;;237        block_ptr = (rt_uint8_t *)mp->start_address;
;;;238        for (offset = 0; offset < mp->block_total_count; offset ++)
;;;239        {
;;;240            *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *)))
;;;241                = block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *));
;;;242        }
;;;243    
;;;244        *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *)))
;;;245            = RT_NULL;
;;;246    
;;;247        mp->block_list = block_ptr;
;;;248    
;;;249        return mp;
;;;250    }
000040  e8bd87f0          POP      {r4-r10,pc}
                  |L5.68|
000044  1ce8              ADDS     r0,r5,#3              ;214
000046  f0200503          BIC      r5,r0,#3              ;214
00004a  61e5              STR      r5,[r4,#0x1c]         ;215
00004c  1d28              ADDS     r0,r5,#4              ;216
00004e  fb00f008          MUL      r0,r0,r8              ;216
000052  61a0              STR      r0,[r4,#0x18]         ;216
000054  1d29              ADDS     r1,r5,#4              ;219
000056  fb01f008          MUL      r0,r1,r8              ;219
00005a  f7fffffe          BL       rt_malloc
00005e  6160              STR      r0,[r4,#0x14]         ;219
000060  6960              LDR      r0,[r4,#0x14]         ;221
000062  b920              CBNZ     r0,|L5.110|
000064  4620              MOV      r0,r4                 ;224
000066  f7fffffe          BL       rt_object_delete
00006a  2000              MOVS     r0,#0                 ;226
00006c  e7e8              B        |L5.64|
                  |L5.110|
00006e  f8c48024          STR      r8,[r4,#0x24]         ;229
000072  6a60              LDR      r0,[r4,#0x24]         ;230
000074  62a0              STR      r0,[r4,#0x28]         ;230
000076  f104002c          ADD      r0,r4,#0x2c           ;233
00007a  f7fffffe          BL       rt_list_init
00007e  2000              MOVS     r0,#0                 ;234
000080  6360              STR      r0,[r4,#0x34]         ;234
000082  6967              LDR      r7,[r4,#0x14]         ;237
000084  2600              MOVS     r6,#0                 ;238
000086  e007              B        |L5.152|
                  |L5.136|
000088  1c70              ADDS     r0,r6,#1              ;240
00008a  1d29              ADDS     r1,r5,#4              ;240
00008c  fb007101          MLA      r1,r0,r1,r7           ;240
000090  1d28              ADDS     r0,r5,#4              ;240
000092  4370              MULS     r0,r6,r0              ;240
000094  5039              STR      r1,[r7,r0]            ;240
000096  1c76              ADDS     r6,r6,#1              ;238
                  |L5.152|
000098  6a60              LDR      r0,[r4,#0x24]         ;238
00009a  42b0              CMP      r0,r6                 ;238
00009c  d8f4              BHI      |L5.136|
00009e  2200              MOVS     r2,#0                 ;244
0000a0  1e70              SUBS     r0,r6,#1              ;244
0000a2  1d29              ADDS     r1,r5,#4              ;244
0000a4  4348              MULS     r0,r1,r0              ;244
0000a6  503a              STR      r2,[r7,r0]            ;244
0000a8  6227              STR      r7,[r4,#0x20]         ;247
0000aa  4620              MOV      r0,r4                 ;249
0000ac  e7c8              B        |L5.64|
;;;251    RTM_EXPORT(rt_mp_create);
                          ENDP

0000ae  0000              DCW      0x0000
                  |L5.176|
                          DCD      |symbol_number.35|
                  |L5.180|
0000b4  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0000b8  74696f6e
0000bc  5b25735d
0000c0  20736861
0000c4  6c6c206e
0000c8  6f742075
0000cc  73656420
0000d0  696e2049
0000d4  53520a00
                  |L5.216|
0000d8  3000              DCB      "0",0
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.rt_mp_delete||, CODE, READONLY, ALIGN=2

                  rt_mp_delete PROC
;;;259     */
;;;260    rt_err_t rt_mp_delete(rt_mp_t mp)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;261    {
000004  4604              MOV      r4,r0
;;;262        struct rt_thread *thread;
;;;263        register rt_ubase_t temp;
;;;264    
;;;265        RT_DEBUG_NOT_IN_INTERRUPT;
000006  bf00              NOP      
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4607              MOV      r7,r0
00000e  f7fffffe          BL       rt_interrupt_get_nest
000012  b148              CBZ      r0,|L6.40|
000014  491b              LDR      r1,|L6.132|
000016  a01c              ADR      r0,|L6.136|
000018  f7fffffe          BL       rt_kprintf
00001c  f2401209          MOV      r2,#0x109
000020  4918              LDR      r1,|L6.132|
000022  a022              ADR      r0,|L6.172|
000024  f7fffffe          BL       rt_assert_handler
                  |L6.40|
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       rt_hw_interrupt_enable
00002e  bf00              NOP      
;;;266    
;;;267        /* parameter check */
;;;268        RT_ASSERT(mp != RT_NULL);
000030  b92c              CBNZ     r4,|L6.62|
000032  f44f7286          MOV      r2,#0x10c
000036  4913              LDR      r1,|L6.132|
000038  a01d              ADR      r0,|L6.176|
00003a  f7fffffe          BL       rt_assert_handler
                  |L6.62|
;;;269    
;;;270        /* wake up all suspended threads */
;;;271        while (!rt_list_isempty(&(mp->suspend_thread)))
00003e  e011              B        |L6.100|
                  |L6.64|
;;;272        {
;;;273            /* disable interrupt */
;;;274            temp = rt_hw_interrupt_disable();
000040  f7fffffe          BL       rt_hw_interrupt_disable
000044  4606              MOV      r6,r0
;;;275    
;;;276            /* get next suspend thread */
;;;277            thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
000046  6ae0              LDR      r0,[r4,#0x2c]
000048  f1a00514          SUB      r5,r0,#0x14
;;;278            /* set error code to RT_ERROR */
;;;279            thread->error = -RT_ERROR;
00004c  f04f30ff          MOV      r0,#0xffffffff
000050  6328              STR      r0,[r5,#0x30]
;;;280    
;;;281            /*
;;;282             * resume thread
;;;283             * In rt_thread_resume function, it will remove current thread from
;;;284             * suspend list
;;;285             */
;;;286            rt_thread_resume(thread);
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       rt_thread_resume
;;;287    
;;;288            /* decrease suspended thread count */
;;;289            mp->suspend_thread_count --;
000058  6b60              LDR      r0,[r4,#0x34]
00005a  1e40              SUBS     r0,r0,#1
00005c  6360              STR      r0,[r4,#0x34]
;;;290    
;;;291            /* enable interrupt */
;;;292            rt_hw_interrupt_enable(temp);
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       rt_hw_interrupt_enable
                  |L6.100|
000064  f104002c          ADD      r0,r4,#0x2c           ;271
000068  f7fffffe          BL       rt_list_isempty
00006c  2800              CMP      r0,#0                 ;271
00006e  d0e7              BEQ      |L6.64|
;;;293        }
;;;294    
;;;295    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;296        /* the mp object belongs to an application module */
;;;297        if (mp->parent.flag & RT_OBJECT_FLAG_MODULE)
;;;298            rt_module_free(mp->parent.module_id, mp->start_address);
;;;299        else
;;;300    #endif
;;;301    
;;;302        /* release allocated room */
;;;303        rt_free(mp->start_address);
000070  6960              LDR      r0,[r4,#0x14]
000072  f7fffffe          BL       rt_free
;;;304    
;;;305        /* detach object */
;;;306        rt_object_delete(&(mp->parent));
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       rt_object_delete
;;;307    
;;;308        return RT_EOK;
00007c  2000              MOVS     r0,#0
;;;309    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;310    RTM_EXPORT(rt_mp_delete);
                          ENDP

000082  0000              DCW      0x0000
                  |L6.132|
                          DCD      |symbol_number.36|
                  |L6.136|
000088  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00008c  74696f6e
000090  5b25735d
000094  20736861
000098  6c6c206e
00009c  6f742075
0000a0  73656420
0000a4  696e2049
0000a8  53520a00
                  |L6.172|
0000ac  3000              DCB      "0",0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L6.176|
0000b0  6d702021          DCB      "mp != RT_NULL",0
0000b4  3d205254
0000b8  5f4e554c
0000bc  4c00    
0000be  00                DCB      0
0000bf  00                DCB      0

                          AREA ||i.rt_mp_detach||, CODE, READONLY, ALIGN=2

                  rt_mp_detach PROC
;;;145     */
;;;146    rt_err_t rt_mp_detach(struct rt_mempool *mp)
000000  b570              PUSH     {r4-r6,lr}
;;;147    {
000002  4604              MOV      r4,r0
;;;148        struct rt_thread *thread;
;;;149        register rt_ubase_t temp;
;;;150    
;;;151        /* parameter check */
;;;152        RT_ASSERT(mp != RT_NULL);
000004  b924              CBNZ     r4,|L7.16|
000006  2298              MOVS     r2,#0x98
000008  4910              LDR      r1,|L7.76|
00000a  a011              ADR      r0,|L7.80|
00000c  f7fffffe          BL       rt_assert_handler
                  |L7.16|
;;;153    
;;;154        /* wake up all suspended threads */
;;;155        while (!rt_list_isempty(&(mp->suspend_thread)))
000010  e011              B        |L7.54|
                  |L7.18|
;;;156        {
;;;157            /* disable interrupt */
;;;158            temp = rt_hw_interrupt_disable();
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4606              MOV      r6,r0
;;;159    
;;;160            /* get next suspend thread */
;;;161            thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
000018  6ae0              LDR      r0,[r4,#0x2c]
00001a  f1a00514          SUB      r5,r0,#0x14
;;;162            /* set error code to RT_ERROR */
;;;163            thread->error = -RT_ERROR;
00001e  f04f30ff          MOV      r0,#0xffffffff
000022  6328              STR      r0,[r5,#0x30]
;;;164    
;;;165            /*
;;;166             * resume thread
;;;167             * In rt_thread_resume function, it will remove current thread from
;;;168             * suspend list
;;;169             */
;;;170            rt_thread_resume(thread);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       rt_thread_resume
;;;171    
;;;172            /* decrease suspended thread count */
;;;173            mp->suspend_thread_count --;
00002a  6b60              LDR      r0,[r4,#0x34]
00002c  1e40              SUBS     r0,r0,#1
00002e  6360              STR      r0,[r4,#0x34]
;;;174    
;;;175            /* enable interrupt */
;;;176            rt_hw_interrupt_enable(temp);
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       rt_hw_interrupt_enable
                  |L7.54|
000036  f104002c          ADD      r0,r4,#0x2c           ;155
00003a  f7fffffe          BL       rt_list_isempty
00003e  2800              CMP      r0,#0                 ;155
000040  d0e7              BEQ      |L7.18|
;;;177        }
;;;178    
;;;179        /* detach object */
;;;180        rt_object_detach(&(mp->parent));
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       rt_object_detach
;;;181    
;;;182        return RT_EOK;
000048  2000              MOVS     r0,#0
;;;183    }
00004a  bd70              POP      {r4-r6,pc}
;;;184    RTM_EXPORT(rt_mp_detach);
                          ENDP

                  |L7.76|
                          DCD      |symbol_number.34|
                  |L7.80|
000050  6d702021          DCB      "mp != RT_NULL",0
000054  3d205254
000058  5f4e554c
00005c  4c00    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.rt_mp_free||, CODE, READONLY, ALIGN=2

                  rt_mp_free PROC
;;;414     */
;;;415    void rt_mp_free(void *block)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;416    {
000004  4605              MOV      r5,r0
;;;417        rt_uint8_t **block_ptr;
;;;418        struct rt_mempool *mp;
;;;419        struct rt_thread *thread;
;;;420        register rt_base_t level;
;;;421    
;;;422        /* get the control block of pool which the block belongs to */
;;;423        block_ptr = (rt_uint8_t **)((rt_uint8_t *)block - sizeof(rt_uint8_t *));
000006  1f2e              SUBS     r6,r5,#4
;;;424        mp        = (struct rt_mempool *)*block_ptr;
000008  6834              LDR      r4,[r6,#0]
;;;425    
;;;426        RT_OBJECT_HOOK_CALL(rt_mp_free_hook, (mp, block));
00000a  bf00              NOP      
00000c  4815              LDR      r0,|L8.100|
00000e  6800              LDR      r0,[r0,#0]  ; rt_mp_free_hook
000010  b120              CBZ      r0,|L8.28|
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  4a13              LDR      r2,|L8.100|
000018  6812              LDR      r2,[r2,#0]  ; rt_mp_free_hook
00001a  4790              BLX      r2
                  |L8.28|
00001c  bf00              NOP      
;;;427    
;;;428        /* disable interrupt */
;;;429        level = rt_hw_interrupt_disable();
00001e  f7fffffe          BL       rt_hw_interrupt_disable
000022  4680              MOV      r8,r0
;;;430    
;;;431        /* increase the free block count */
;;;432        mp->block_free_count ++;
000024  6aa0              LDR      r0,[r4,#0x28]
000026  1c40              ADDS     r0,r0,#1
000028  62a0              STR      r0,[r4,#0x28]
;;;433    
;;;434        /* link the block into the block list */
;;;435        *block_ptr = mp->block_list;
00002a  6a20              LDR      r0,[r4,#0x20]
00002c  6030              STR      r0,[r6,#0]
;;;436        mp->block_list = (rt_uint8_t *)block_ptr;
00002e  6226              STR      r6,[r4,#0x20]
;;;437    
;;;438        if (mp->suspend_thread_count > 0)
000030  6b60              LDR      r0,[r4,#0x34]
000032  b188              CBZ      r0,|L8.88|
;;;439        {
;;;440            /* get the suspended thread */
;;;441            thread = rt_list_entry(mp->suspend_thread.next,
000034  6ae0              LDR      r0,[r4,#0x2c]
000036  f1a00714          SUB      r7,r0,#0x14
;;;442                                   struct rt_thread,
;;;443                                   tlist);
;;;444    
;;;445            /* set error */
;;;446            thread->error = RT_EOK;
00003a  2000              MOVS     r0,#0
00003c  6338              STR      r0,[r7,#0x30]
;;;447    
;;;448            /* resume thread */
;;;449            rt_thread_resume(thread);
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       rt_thread_resume
;;;450    
;;;451            /* decrease suspended thread count */
;;;452            mp->suspend_thread_count --;
000044  6b60              LDR      r0,[r4,#0x34]
000046  1e40              SUBS     r0,r0,#1
000048  6360              STR      r0,[r4,#0x34]
;;;453    
;;;454            /* enable interrupt */
;;;455            rt_hw_interrupt_enable(level);
00004a  4640              MOV      r0,r8
00004c  f7fffffe          BL       rt_hw_interrupt_enable
;;;456    
;;;457            /* do a schedule */
;;;458            rt_schedule();
000050  f7fffffe          BL       rt_schedule
                  |L8.84|
;;;459    
;;;460            return;
;;;461        }
;;;462    
;;;463        /* enable interrupt */
;;;464        rt_hw_interrupt_enable(level);
;;;465    }
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L8.88|
000058  4640              MOV      r0,r8                 ;464
00005a  f7fffffe          BL       rt_hw_interrupt_enable
00005e  bf00              NOP      
000060  e7f8              B        |L8.84|
;;;466    RTM_EXPORT(rt_mp_free);
                          ENDP

000062  0000              DCW      0x0000
                  |L8.100|
                          DCD      rt_mp_free_hook

                          AREA ||i.rt_mp_free_sethook||, CODE, READONLY, ALIGN=2

                  rt_mp_free_sethook PROC
;;;64      */
;;;65     void rt_mp_free_sethook(void (*hook)(struct rt_mempool *mp, void *block))
000000  4901              LDR      r1,|L9.8|
;;;66     {
;;;67         rt_mp_free_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_mp_free_hook
;;;68     }
000004  4770              BX       lr
;;;69     
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      rt_mp_free_hook

                          AREA ||i.rt_mp_init||, CODE, READONLY, ALIGN=2

                  rt_mp_init PROC
;;;90      */
;;;91     rt_err_t rt_mp_init(struct rt_mempool *mp,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;92                         const char        *name,
;;;93                         void              *start,
;;;94                         rt_size_t          size,
;;;95                         rt_size_t          block_size)
;;;96     {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
00000c  9e08              LDR      r6,[sp,#0x20]
;;;97         rt_uint8_t *block_ptr;
;;;98         register rt_base_t offset;
;;;99     
;;;100        /* parameter check */
;;;101        RT_ASSERT(mp != RT_NULL);
00000e  b924              CBNZ     r4,|L10.26|
000010  2265              MOVS     r2,#0x65
000012  491b              LDR      r1,|L10.128|
000014  a01b              ADR      r0,|L10.132|
000016  f7fffffe          BL       rt_assert_handler
                  |L10.26|
;;;102    
;;;103        /* initialize object */
;;;104        rt_object_init(&(mp->parent), RT_Object_Class_MemPool, name);
00001a  4642              MOV      r2,r8
00001c  2106              MOVS     r1,#6
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       rt_object_init
;;;105    
;;;106        /* initialize memory pool */
;;;107        mp->start_address = start;
000024  f8c49014          STR      r9,[r4,#0x14]
;;;108        mp->size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
000028  f02a0003          BIC      r0,r10,#3
00002c  61a0              STR      r0,[r4,#0x18]
;;;109    
;;;110        /* align the block size */
;;;111        block_size = RT_ALIGN(block_size, RT_ALIGN_SIZE);
00002e  1cf0              ADDS     r0,r6,#3
000030  f0200603          BIC      r6,r0,#3
;;;112        mp->block_size = block_size;
000034  61e6              STR      r6,[r4,#0x1c]
;;;113    
;;;114        /* align to align size byte */
;;;115        mp->block_total_count = mp->size / (mp->block_size + sizeof(rt_uint8_t *));
000036  e9d41006          LDRD     r1,r0,[r4,#0x18]
00003a  1d00              ADDS     r0,r0,#4
00003c  fbb1f0f0          UDIV     r0,r1,r0
000040  6260              STR      r0,[r4,#0x24]
;;;116        mp->block_free_count  = mp->block_total_count;
000042  6a60              LDR      r0,[r4,#0x24]
000044  62a0              STR      r0,[r4,#0x28]
;;;117    
;;;118        /* initialize suspended thread list */
;;;119        rt_list_init(&(mp->suspend_thread));
000046  f104002c          ADD      r0,r4,#0x2c
00004a  f7fffffe          BL       rt_list_init
;;;120        mp->suspend_thread_count = 0;
00004e  2000              MOVS     r0,#0
000050  6360              STR      r0,[r4,#0x34]
;;;121    
;;;122        /* initialize free block list */
;;;123        block_ptr = (rt_uint8_t *)mp->start_address;
000052  6967              LDR      r7,[r4,#0x14]
;;;124        for (offset = 0; offset < mp->block_total_count; offset ++)
000054  2500              MOVS     r5,#0
000056  e007              B        |L10.104|
                  |L10.88|
;;;125        {
;;;126            *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *))) =
000058  1c68              ADDS     r0,r5,#1
00005a  1d31              ADDS     r1,r6,#4
00005c  fb007101          MLA      r1,r0,r1,r7
000060  1d30              ADDS     r0,r6,#4
000062  4368              MULS     r0,r5,r0
000064  5039              STR      r1,[r7,r0]
000066  1c6d              ADDS     r5,r5,#1              ;124
                  |L10.104|
000068  6a60              LDR      r0,[r4,#0x24]         ;124
00006a  42a8              CMP      r0,r5                 ;124
00006c  d8f4              BHI      |L10.88|
;;;127                (rt_uint8_t *)(block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *)));
;;;128        }
;;;129    
;;;130        *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *))) =
00006e  2200              MOVS     r2,#0
000070  1e68              SUBS     r0,r5,#1
000072  1d31              ADDS     r1,r6,#4
000074  4348              MULS     r0,r1,r0
000076  503a              STR      r2,[r7,r0]
;;;131            RT_NULL;
;;;132    
;;;133        mp->block_list = block_ptr;
000078  6227              STR      r7,[r4,#0x20]
;;;134    
;;;135        return RT_EOK;
00007a  2000              MOVS     r0,#0
;;;136    }
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;137    RTM_EXPORT(rt_mp_init);
                          ENDP

                  |L10.128|
                          DCD      __FUNCTION__
                  |L10.132|
000084  6d702021          DCB      "mp != RT_NULL",0
000088  3d205254
00008c  5f4e554c
000090  4c00    
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000004  705f696e          DCB      0x70,0x5f,0x69,0x6e
000008  697400            DCB      0x69,0x74,0x00
                  |symbol_number.34|
00000b  72                DCB      0x72
00000c  745f6d70          DCB      0x74,0x5f,0x6d,0x70
000010  5f646574          DCB      0x5f,0x64,0x65,0x74
000014  61636800          DCB      0x61,0x63,0x68,0x00
                  |symbol_number.35|
000018  72745f6d          DCB      0x72,0x74,0x5f,0x6d
00001c  705f6372          DCB      0x70,0x5f,0x63,0x72
000020  65617465          DCB      0x65,0x61,0x74,0x65
000024  00                DCB      0x00
                  |symbol_number.36|
000025  72745f            DCB      0x72,0x74,0x5f
000028  6d705f64          DCB      0x6d,0x70,0x5f,0x64
00002c  656c6574          DCB      0x65,0x6c,0x65,0x74
000030  6500              DCB      0x65,0x00
                  |symbol_number.37|
000032  7274              DCB      0x72,0x74
000034  5f6d705f          DCB      0x5f,0x6d,0x70,0x5f
000038  616c6c6f          DCB      0x61,0x6c,0x6c,0x6f
00003c  6300              DCB      0x63,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  rt_mp_alloc_hook
                          DCD      0x00000000
                  rt_mp_free_hook
                          DCD      0x00000000
