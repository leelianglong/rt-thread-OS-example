L 1 "..\rt_thread\kernel\module.c"
N/*
N * File      : module.c
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2010-01-09     Bernard      first version
N * 2010-04-09     yi.qiu       implement based on first version
N * 2010-10-23     yi.qiu       implement module memory allocator
N * 2011-05-25     yi.qiu       implement module hook function
N * 2011-06-23     yi.qiu       rewrite module memory allocator
N * 2012-11-23     Bernard      using RT_DEBUG_LOG instead of rt_kprintf.
N * 2012-11-28     Bernard      remove rt_current_module and user
N *                             can use rt_module_unload to remove a module.
N */
N
N#include <rthw.h>
L 1 "..\rt_thread\include\rthw.h" 1
N/*
N * File      : rthw.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-18     Bernard      the first version
N * 2006-04-25     Bernard      add rt_hw_context_switch_interrupt declaration
N * 2006-09-24     Bernard      add rt_hw_context_switch_to declaration
N * 2012-12-29     Bernard      add rt_hw_exception_install declaration
N */
N
N#ifndef __RT_HW_H__
N#define __RT_HW_H__
N
N#include <rtthread.h>
L 1 "..\rt_thread\include\rtthread.h" 1
N/*
N * File      : rtthread.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-18     Bernard      the first version
N * 2006-04-26     Bernard      add semaphore APIs
N * 2006-08-10     Bernard      add version information
N * 2007-01-28     Bernard      rename RT_OBJECT_Class_Static to RT_Object_Class_Static
N * 2007-03-03     Bernard      clean up the definitions to rtdef.h
N * 2010-04-11     yi.qiu       add module feature
N * 2013-06-24     Bernard      add rt_kprintf re-define when not use RT_USING_CONSOLE.
N */
N
N#ifndef __RT_THREAD_H__
N#define __RT_THREAD_H__
N
N#include <rtconfig.h>
L 1 "..\app\rtconfig.h" 1
N/* RT-Thread config file */
N#ifndef __RTTHREAD_CFG_H__
N#define __RTTHREAD_CFG_H__
N
N/* RT_NAME_MAX*/
N#define RT_NAME_MAX	8
N
N/* RT_ALIGN_SIZE*/
N#define RT_ALIGN_SIZE	4
N
N/* PRIORITY_MAX */
N#define RT_THREAD_PRIORITY_MAX	32
N
N/* Tick per Second */
N#define RT_TICK_PER_SECOND	100    //每个 tick是10ms
N
N/* SECTION: RT_DEBUG */
N/* Thread Debug */
N#define RT_DEBUG
N#define SCHEDULER_DEBUG
N/* #define RT_THREAD_DEBUG */
N
N#define RT_USING_OVERFLOW_CHECK
N
N#define RT_USING_INTERRUPT_INFO
N
N/* Using Hook */
N#define RT_USING_HOOK      //需要使用钩子函数
N
N/* Using Software Timer */
N//#define RT_USING_TIMER_SOFT    //不使用软件定时器,而是用MCU的硬件定时器
N#define RT_TIMER_THREAD_PRIO		8
N#define RT_TIMER_THREAD_STACK_SIZE	512
N#define RT_TIMER_TICK_PER_SECOND	10
N
N/* SECTION: IPC */
N/* Using Semaphore */
N#define RT_USING_SEMAPHORE
N
N/* Using Mutex */
N#define RT_USING_MUTEX
N
N/* Using Event */
N#define RT_USING_EVENT
N
N/* Using MailBox */
N#define RT_USING_MAILBOX
N
N/* Using Message Queue */
N#define RT_USING_MESSAGEQUEUE
N
N/* SECTION: Memory Management */
N/* Using Memory Pool Management*/
N#define RT_USING_MEMPOOL
N
N/* Using Dynamic Heap Management */
N#define RT_USING_HEAP
N
N/* Using Small MM */
N/* #define RT_USING_SMALL_MEM */
N
N/* Using SLAB Allocator */
N#define RT_USING_SLAB
N
N/* SECTION: the runtime libc library */
N/* the runtime libc library */
N//#define RT_USING_LIBC
N//#define RT_USING_PTHREADS
N
N/* Using Module System */
N//#define RT_USING_MODULE
N//#define RT_USING_LIBDL
N
N/* SECTION: Device System */
N/* Using Device System */
N#define RT_USING_DEVICE
N
N#define RT_USING_DEVICE_IPC
N#define RT_USING_SERIAL
N
N/* SECTION: Console options */
N#define RT_USING_CONSOLE
N/* the buffer size of console */
N#define RT_CONSOLEBUF_SIZE	128
N#define RT_CONSOLE_DEVICE_NAME "uart0"
N
N/* SECTION: finsh, a C-Express shell */
N/* Using FinSH as Shell*/
N//#define RT_USING_FINSH
N/* Using symbol table */
N#define FINSH_USING_SYMTAB
N#define FINSH_USING_DESCRIPTION
N#define FINSH_THREAD_STACK_SIZE 4096
N
N/* SECTION: C++ support */
N/* Using C++ support */
N/* #define RT_USING_CPLUSPLUS */
N
N/* SECTION: Device filesystem support */
N/* using DFS support */
N//#define RT_USING_DFS
N//#define RT_USING_DFS_ELMFAT
N/* use long file name feature */
N//#define RT_DFS_ELM_USE_LFN			2
N//#define RT_DFS_ELM_REENTRANT
N/* define OEM code page */
N//#define RT_DFS_ELM_CODE_PAGE	936
N/* Using OEM code page file */
N// #define RT_DFS_ELM_CODE_PAGE_FILE
N/* the max number of file length */
N//#define RT_DFS_ELM_MAX_LFN			128
N/* #define RT_USING_DFS_YAFFS2 */
N//#define RT_USING_DFS_DEVFS
N
N//#define RT_USING_DFS_NFS
N//#define RT_NFS_HOST_EXPORT		"192.168.1.5:/"
N
N//#define DFS_USING_WORKDIR
N
N/* the max number of mounted filesystem */
N//#define DFS_FILESYSTEMS_MAX		4
N/* the max number of opened files */
N//#define DFS_FD_MAX					16
N/* the max number of cached sector */
N//#define DFS_CACHE_MAX_NUM   		4
N
N/* Enable freemodbus protocol stack*/
N/* #define RT_USING_MODBUS */
N
N#define RT_USING_LED
N
N//#define RT_USING_SDIO
N
N//#define RT_USING_I2C
N//#define RT_USING_I2C_BITOPS
N
N/*#define RT_USING_DBGU*/
N #define RT_USING_UART0
N/* #define RT_USING_UART1 */
N
N// #define RT_USING_UART3 
N// #define RT_USING_UART4
N
N/* SECTION: lwip, a lightweight TCP/IP protocol stack */
N/* Using lightweight TCP/IP protocol stack */
N//#define RT_USING_LWIP
N//#define RT_LWIP_DNS
N
N/* Trace LwIP protocol */
N// #define RT_LWIP_DEBUG 
N
N/* Enable ICMP protocol */
N//#define RT_LWIP_ICMP
N
N/* Enable IGMP protocol */
N//#define RT_LWIP_IGMP
N
N/* Enable UDP protocol */
N//#define RT_LWIP_UDP
N
N/* Enable TCP protocol */
N//#define RT_LWIP_TCP
N
N/* the number of simulatenously active TCP connections*/
N//#define RT_LWIP_TCP_PCB_NUM	5
N
N/* TCP sender buffer space */
N//#define RT_LWIP_TCP_SND_BUF	1024*10
N
N/* TCP receive window. */
N//#define RT_LWIP_TCP_WND	1024*8
N
N/* Enable SNMP protocol */
N/* #define RT_LWIP_SNMP */
N
N/* Using DHCP */
N/* #define RT_LWIP_DHCP */
N
N/* ip address of target */
N//#define RT_LWIP_IPADDR0	192
N//#define RT_LWIP_IPADDR1	168
N//#define RT_LWIP_IPADDR2	1
N//#define RT_LWIP_IPADDR3	30
N
N/* gateway address of target */
N//#define RT_LWIP_GWADDR0	192
N//#define RT_LWIP_GWADDR1	168
N//#define RT_LWIP_GWADDR2	1
N//#define RT_LWIP_GWADDR3	1
N
N/* mask address of target */
N//#define RT_LWIP_MSKADDR0	255
N//#define RT_LWIP_MSKADDR1	255
N//#define RT_LWIP_MSKADDR2	255
N//#define RT_LWIP_MSKADDR3	0
N
N/* the number of blocks for pbuf */
N//#define RT_LWIP_PBUF_NUM	16
N
N/* the number of simultaneously queued TCP */
N//#define RT_LWIP_TCP_SEG_NUM    40
N
N/* thread priority of tcpip thread */
N//#define RT_LWIP_TCPTHREAD_PRIORITY	128
N
N/* mail box size of tcpip thread to wait for */
N//#define RT_LWIP_TCPTHREAD_MBOX_SIZE	32
N
N/* thread stack size of tcpip thread */
N//#define RT_LWIP_TCPTHREAD_STACKSIZE	4096
N
N/* thread priority of ethnetif thread */
N//#define RT_LWIP_ETHTHREAD_PRIORITY	144
N
N/* mail box size of ethnetif thread to wait for */
N//#define RT_LWIP_ETHTHREAD_MBOX_SIZE	32
N
N/* thread stack size of ethnetif thread */
N//#define RT_LWIP_ETHTHREAD_STACKSIZE	1024
N
N
N/* SECTION: RTGUI support */
N/* using RTGUI support */
N/* #define RT_USING_RTGUI */
N
N/* name length of RTGUI object */
N//#define RTGUI_NAME_MAX		16
N/* support 16 weight font */
N//#define RTGUI_USING_FONT16
N/* support 16 weight font */
N//#define RTGUI_USING_FONT12
N/* support Chinese font */
N//#define RTGUI_USING_FONTHZ
N/* use DFS as file interface */
N//#define RTGUI_USING_DFS_FILERW
N/* use font file as Chinese font */
N/* #define RTGUI_USING_HZ_FILE */
N/* use Chinese bitmap font */
N//#define RTGUI_USING_HZ_BMP
N/* use small size in RTGUI */
N/* #define RTGUI_USING_SMALL_SIZE */
N/* use mouse cursor */
N/* #define RTGUI_USING_MOUSE_CURSOR */
N
N/* SECTION: FTK support */
N/* using FTK support */
N/* #define RT_USING_FTK */
N
N/*
N * Note on FTK:
N * 
N * FTK depends :
N * #define RT_USING_NEWLIB
N * #define DFS_USING_WORKDIR
N * 
N * And the maximal length must great than 64
N * #define RT_DFS_ELM_MAX_LFN	128
N */
N//#define RT_USING_CPU_FFS
N#define RT_USING_COMPONENTS_INIT
N#endif
L 35 "..\rt_thread\include\rtthread.h" 2
N#include <rtdebug.h>
L 1 "..\rt_thread\include\rtdebug.h" 1
N/*
N * File      : rtdebug.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N */
N
N#ifndef __RTDEBUG_H__
N#define __RTDEBUG_H__
N
N#include <rtconfig.h>
N
N/* Using this macro to control all kernel debug features. */
N#ifdef RT_DEBUG
N
N/* Turn on some of these (set to non-zero) to debug kernel */
N#ifndef RT_DEBUG_MEM
N#define RT_DEBUG_MEM                   0
N#endif
N
N#ifndef RT_DEBUG_MEMHEAP
N#define RT_DEBUG_MEMHEAP               0
N#endif
N
N#ifndef RT_DEBUG_MODULE
N#define RT_DEBUG_MODULE                0
N#endif
N
N#ifndef RT_DEBUG_SCHEDULER
N#define RT_DEBUG_SCHEDULER             0
N#endif
N
N#ifndef RT_DEBUG_SLAB
N#define RT_DEBUG_SLAB                  0
N#endif
N
N#ifndef RT_DEBUG_THREAD
N#define RT_DEBUG_THREAD                0
N#endif
N
N#ifndef RT_DEBUG_TIMER
N#define RT_DEBUG_TIMER                 0
N#endif
N
N#ifndef RT_DEBUG_IRQ
N#define RT_DEBUG_IRQ                   0
N#endif
N
N#ifndef RT_DEBUG_IPC
N#define RT_DEBUG_IPC                   0
N#endif
N
N#ifndef RT_DEBUG_INIT
N#define RT_DEBUG_INIT                  0
N#endif
N
N/* Turn on this to enable context check */
N#ifndef RT_DEBUG_CONTEXT_CHECK
N#define RT_DEBUG_CONTEXT_CHECK         1
N#endif
N
N#define RT_DEBUG_LOG(type, message)                                           \
Ndo                                                                            \
N{                                                                             \
N    if (type)                                                                 \
N        rt_kprintf message;                                                   \
N}                                                                             \
Nwhile (0)
X#define RT_DEBUG_LOG(type, message)                                           do                                                                            {                                                                                 if (type)                                                                         rt_kprintf message;                                                   }                                                                             while (0)
N
N#define RT_ASSERT(EX)                                                         \
Nif (!(EX))                                                                    \
N{                                                                             \
N    rt_assert_handler(#EX, __FUNCTION__, __LINE__);                           \
N}
X#define RT_ASSERT(EX)                                                         if (!(EX))                                                                    {                                                                                 rt_assert_handler(#EX, __FUNCTION__, __LINE__);                           }
N
N/* Macro to check current context */
N#if RT_DEBUG_CONTEXT_CHECK
X#if 1
N#define RT_DEBUG_NOT_IN_INTERRUPT                                             \
Ndo                                                                            \
N{                                                                             \
N    rt_base_t level;                                                          \
N    level = rt_hw_interrupt_disable();                                        \
N    if (rt_interrupt_get_nest() != 0)                                         \
N    {                                                                         \
N        rt_kprintf("Function[%s] shall not used in ISR\n", __FUNCTION__);     \
N        RT_ASSERT(0)                                                          \
N    }                                                                         \
N    rt_hw_interrupt_enable(level);                                            \
N}                                                                             \
Nwhile (0)
X#define RT_DEBUG_NOT_IN_INTERRUPT                                             do                                                                            {                                                                                 rt_base_t level;                                                              level = rt_hw_interrupt_disable();                                            if (rt_interrupt_get_nest() != 0)                                             {                                                                                 rt_kprintf("Function[%s] shall not used in ISR\n", __FUNCTION__);             RT_ASSERT(0)                                                              }                                                                             rt_hw_interrupt_enable(level);                                            }                                                                             while (0)
N
N/* "In thread context" means:
N *     1) the scheduler has been started
N *     2) not in interrupt context.
N */
N#define RT_DEBUG_IN_THREAD_CONTEXT                                            \
Ndo                                                                            \
N{                                                                             \
N    rt_base_t level;                                                          \
N    level = rt_hw_interrupt_disable();                                        \
N    if (rt_thread_self() == RT_NULL)                                          \
N    {                                                                         \
N        rt_kprintf("Function[%s] shall not be used before scheduler start\n", \
N                   __FUNCTION__);                                             \
N        RT_ASSERT(0)                                                          \
N    }                                                                         \
N    RT_DEBUG_NOT_IN_INTERRUPT;                                                \
N    rt_hw_interrupt_enable(level);                                            \
N}                                                                             \
Nwhile (0)
X#define RT_DEBUG_IN_THREAD_CONTEXT                                            do                                                                            {                                                                                 rt_base_t level;                                                              level = rt_hw_interrupt_disable();                                            if (rt_thread_self() == RT_NULL)                                              {                                                                                 rt_kprintf("Function[%s] shall not be used before scheduler start\n",                    __FUNCTION__);                                                     RT_ASSERT(0)                                                              }                                                                             RT_DEBUG_NOT_IN_INTERRUPT;                                                    rt_hw_interrupt_enable(level);                                            }                                                                             while (0)
N#else
S#define RT_DEBUG_NOT_IN_INTERRUPT
S#define RT_DEBUG_IN_THREAD_CONTEXT
N#endif
N
N#else /* RT_DEBUG */
S
S#define RT_ASSERT(EX)
S#define RT_DEBUG_LOG(type, message)
S#define RT_DEBUG_NOT_IN_INTERRUPT
S#define RT_DEBUG_IN_THREAD_CONTEXT
S
N#endif /* RT_DEBUG */
N
N#endif /* __RTDEBUG_H__ */
L 36 "..\rt_thread\include\rtthread.h" 2
N#include <rtdef.h>
L 1 "..\rt_thread\include\rtdef.h" 1
N/*
N * File      : rtdef.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2015, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2007-01-10     Bernard      the first version
N * 2008-07-12     Bernard      remove all rt_int8, rt_uint32_t etc typedef
N * 2010-10-26     yi.qiu       add module support
N * 2010-11-10     Bernard      add cleanup callback function in thread exit.
N * 2011-05-09     Bernard      use builtin va_arg in GCC 4.x
N * 2012-11-16     Bernard      change RT_NULL from ((void*)0) to 0.
N * 2012-12-29     Bernard      change the RT_USING_MEMPOOL location and add
N *                             RT_USING_MEMHEAP condition.
N * 2012-12-30     Bernard      add more control command for graphic.
N * 2013-01-09     Bernard      change version number.
N * 2015-02-01     Bernard      change version number to v2.1.0
N */
N
N#ifndef __RT_DEF_H__
N#define __RT_DEF_H__
N
N/* include rtconfig header to import configuration */
N#include <rtconfig.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @addtogroup BasicDef
N */
N
N/*@{*/
N
N/* RT-Thread version information */
N#define RT_VERSION                      2L              /**< major version number */
N#define RT_SUBVERSION                   1L              /**< minor version number */
N#define RT_REVISION                     0L              /**< revise version number */
N
N/* RT-Thread version */
N#define RTTHREAD_VERSION                ((RT_VERSION * 10000) + \
N                                         (RT_SUBVERSION * 100) + RT_REVISION)
X#define RTTHREAD_VERSION                ((RT_VERSION * 10000) +                                          (RT_SUBVERSION * 100) + RT_REVISION)
N
N/* RT-Thread basic data type definitions */
Ntypedef signed   char                   rt_int8_t;      /**<  8bit integer type */
Ntypedef signed   short                  rt_int16_t;     /**< 16bit integer type */
Ntypedef signed   long                   rt_int32_t;     /**< 32bit integer type */
Ntypedef unsigned char                   rt_uint8_t;     /**<  8bit unsigned integer type */
Ntypedef unsigned short                  rt_uint16_t;    /**< 16bit unsigned integer type */
Ntypedef unsigned long                   rt_uint32_t;    /**< 32bit unsigned integer type */
Ntypedef int                             rt_bool_t;      /**< boolean type */
N
N/* 32bit CPU */
Ntypedef long                            rt_base_t;      /**< Nbit CPU related date type */
Ntypedef unsigned long                   rt_ubase_t;     /**< Nbit unsigned CPU related data type */
N
Ntypedef rt_base_t                       rt_err_t;       /**< Type for error number */
Ntypedef rt_uint32_t                     rt_time_t;      /**< Type for time stamp */
Ntypedef rt_uint32_t                     rt_tick_t;      /**< Type for tick count */
Ntypedef rt_base_t                       rt_flag_t;      /**< Type for flags */
Ntypedef rt_ubase_t                      rt_size_t;      /**< Type for size number */
Ntypedef rt_ubase_t                      rt_dev_t;       /**< Type for device */
Ntypedef rt_base_t                       rt_off_t;       /**< Type for offset */
N
N/* boolean type definitions */
N#define RT_TRUE                         1               /**< boolean true  */
N#define RT_FALSE                        0               /**< boolean fails */
N
N/*@}*/
N
N/* maximum value of base type */
N#define RT_UINT8_MAX                    0xff            /**< Maxium number of UINT8 */
N#define RT_UINT16_MAX                   0xffff          /**< Maxium number of UINT16 */
N#define RT_UINT32_MAX                   0xffffffff      /**< Maxium number of UINT32 */
N#define RT_TICK_MAX                     RT_UINT32_MAX   /**< Maxium number of tick */
N
N/* Compiler Related Definitions */
N#ifdef __CC_ARM                         /* ARM Compiler */
N    #include <stdarg.h>
L 1 "D:\EngineeringSoftware\Keil_core\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5050106
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 96 "..\rt_thread\include\rtdef.h" 2
N    #define SECTION(x)                  __attribute__((section(x)))
N    #define RT_UNUSED                   __attribute__((unused))
N    #define RT_USED                     __attribute__((used))
N    #define ALIGN(n)                    __attribute__((aligned(n)))
N    #define WEAK						__weak
N    #define rt_inline                   static __inline
N    /* module compiling */
N    #ifdef RT_USING_MODULE
S        #define RTT_API                 __declspec(dllimport)
N    #else
N        #define RTT_API                 __declspec(dllexport)
N    #endif
N
N#elif defined (__IAR_SYSTEMS_ICC__)     /* for IAR Compiler */
S    #include <stdarg.h>
S    #define SECTION(x)                  @ x
S    #define RT_UNUSED
S    #define RT_USED
S    #define PRAGMA(x)                   _Pragma(#x)
S    #define ALIGN(n)                    PRAGMA(data_alignment=n)
S    #define WEAK                        __weak
S    #define rt_inline                   static inline
S    #define RTT_API
S
S#elif defined (__GNUC__)                /* GNU GCC Compiler */
S    #ifdef RT_USING_NEWLIB
S        #include <stdarg.h>
S    #else
S		/* the version of GNU GCC must be greater than 4.x */
S        typedef __builtin_va_list   __gnuc_va_list;
S        typedef __gnuc_va_list      va_list;
S        #define va_start(v,l)       __builtin_va_start(v,l)
S        #define va_end(v)           __builtin_va_end(v)
S        #define va_arg(v,l)         __builtin_va_arg(v,l)
S    #endif
S
S    #define SECTION(x)                  __attribute__((section(x)))
S    #define RT_UNUSED                   __attribute__((unused))
S    #define RT_USED                     __attribute__((used))
S    #define ALIGN(n)                    __attribute__((aligned(n)))
S    #define WEAK                        __attribute__((weak))
S    #define rt_inline                   static __inline
S    #define RTT_API
S#elif defined (__ADSPBLACKFIN__)        /* for VisualDSP++ Compiler */
S    #include <stdarg.h>
S    #define SECTION(x)                  __attribute__((section(x)))
S    #define RT_UNUSED                   __attribute__((unused))
S    #define RT_USED                     __attribute__((used))
S    #define ALIGN(n)                    __attribute__((aligned(n)))
S	#define WEAK                        __attribute__((weak))
S    #define rt_inline                   static inline
S    #define RTT_API
S#elif defined (_MSC_VER)
S    #include <stdarg.h>
S    #define SECTION(x)
S    #define RT_UNUSED
S    #define RT_USED
S    #define ALIGN(n)                    __declspec(align(n))
S	#define WEAK
S    #define rt_inline                   static __inline
S    #define RTT_API
S#elif defined (__TI_COMPILER_VERSION__)
S    #include <stdarg.h>
S    /* The way that TI compiler set section is different from other(at least
S     * GCC and MDK) compilers. See ARM Optimizing C/C++ Compiler 5.9.3 for more
S     * details. */
S    #define SECTION(x)
S    #define RT_UNUSED
S    #define RT_USED
S    #define PRAGMA(x)                   _Pragma(#x)
S    #define ALIGN(n)
S    #define WEAK
S    #define rt_inline                   static inline
S    #define RTT_API
S#else
S    #error not supported tool chain
N#endif
N
N/* initialization export */
N#ifdef RT_USING_COMPONENTS_INIT
Ntypedef int (*init_fn_t)(void);
N#ifdef _MSC_VER /* we do not support MS VC++ compiler */
S    #define INIT_EXPORT(fn, level)
N#else
N	#if RT_DEBUG_INIT
X	#if 0
S		struct rt_init_desc
S		{
S			const char* fn_name;
S			const init_fn_t fn;
S		};
S		#define INIT_EXPORT(fn, level)  		\
S			const char __rti_##fn##_name[] = #fn; \
S			const struct rt_init_desc __rt_init_desc_##fn SECTION(".rti_fn."level) = \
S			{ __rti_##fn##_name, fn};
X		#define INIT_EXPORT(fn, level)  					const char __rti_##fn##_name[] = #fn; 			const struct rt_init_desc __rt_init_desc_##fn SECTION(".rti_fn."level) = 			{ __rti_##fn##_name, fn};
N	#else
N    	#define INIT_EXPORT(fn, level)  \
N        	const init_fn_t __rt_init_##fn SECTION(".rti_fn."level) = fn
X    	#define INIT_EXPORT(fn, level)          	const init_fn_t __rt_init_##fn SECTION(".rti_fn."level) = fn
N	#endif
N#endif
N#else
S#define INIT_EXPORT(fn, level)
N#endif
N
N/* board init routines will be called in board_init() function */
N#define INIT_BOARD_EXPORT(fn)           INIT_EXPORT(fn, "1")
N/* device/component/fs/app init routines will be called in init_thread */
N/* device initialization */
N#define INIT_DEVICE_EXPORT(fn)          INIT_EXPORT(fn, "2")
N/* components initialization (dfs, lwip, ...) */
N#define INIT_COMPONENT_EXPORT(fn)       INIT_EXPORT(fn, "3")
N/* file system initialization (dfs-elm, dfs-rom, ...) */
N#define INIT_FS_EXPORT(fn)              INIT_EXPORT(fn, "4")
N/* environment initialization (mount disk, ...) */
N#define INIT_ENV_EXPORT(fn)				INIT_EXPORT(fn, "5")
N/* appliation initialization (rtgui application etc ...) */
N#define INIT_APP_EXPORT(fn)             INIT_EXPORT(fn, "6")
N
N#if !defined(RT_USING_FINSH)
X#if !0L
N/* define these to empty, even if not include finsh.h file */
N#define FINSH_FUNCTION_EXPORT(name, desc)
N#define FINSH_FUNCTION_EXPORT_ALIAS(name, alias, desc)
N#define FINSH_VAR_EXPORT(name, type, desc)
N
N#define MSH_CMD_EXPORT(command, desc)
N#define MSH_CMD_EXPORT_ALIAS(command, alias, desc)
N#elif !defined(FINSH_USING_SYMTAB)
S#define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)
N#endif
N
N/* event length */
N#define RT_EVENT_LENGTH                 32
N
N/* memory management option */
N#define RT_MM_PAGE_SIZE                 4096 //我改成512
N#define RT_MM_PAGE_MASK                 (RT_MM_PAGE_SIZE - 1)
N#define RT_MM_PAGE_BITS                 12
N
N/* kernel malloc definitions */
N#ifndef RT_KERNEL_MALLOC
N#define RT_KERNEL_MALLOC(sz)            rt_malloc(sz)
N#endif
N
N#ifndef RT_KERNEL_FREE
N#define RT_KERNEL_FREE(ptr)             rt_free(ptr)
N#endif
N
N#ifndef RT_KERNEL_REALLOC
N#define RT_KERNEL_REALLOC(ptr, size)    rt_realloc(ptr, size)
N#endif
N
N/**
N * @addtogroup Error
N */
N
N/*@{*/
N
N/* RT-Thread error code definitions */
N#define RT_EOK                          0               /**< There is no error */
N#define RT_ERROR                        1               /**< A generic error happens */
N#define RT_ETIMEOUT                     2               /**< Timed out */
N#define RT_EFULL                        3               /**< The resource is full */
N#define RT_EEMPTY                       4               /**< The resource is empty */
N#define RT_ENOMEM                       5               /**< No memory */
N#define RT_ENOSYS                       6               /**< No system */
N#define RT_EBUSY                        7               /**< Busy */
N#define RT_EIO                          8               /**< IO error */
N
N/*@}*/
N
N/**
N * @ingroup BasicDef
N *
N * @def RT_ALIGN(size, align)
N * Return the most contiguous size aligned at specified width. RT_ALIGN(13, 4)
N * would return 16.
N */
N#define RT_ALIGN(size, align)           (((size) + (align) - 1) & ~((align) - 1))
N
N/**
N * @ingroup BasicDef
N *
N * @def RT_ALIGN_DOWN(size, align)
N * Return the down number of aligned at specified width. RT_ALIGN_DOWN(13, 4)
N * would return 12.
N */
N#define RT_ALIGN_DOWN(size, align)      ((size) & ~((align) - 1))
N
N/**
N * @ingroup BasicDef
N *
N * @def RT_NULL
N * Similar as the \c NULL in C library.
N */
N#define RT_NULL                         (0)
N
Nstruct rt_list_node
N{
N    struct rt_list_node *next;                          /**< point to next node. */
N    struct rt_list_node *prev;                          /**< point to prev node. */
N};
Ntypedef struct rt_list_node rt_list_t;                  /**< Type for lists. */
N
N/**
N * @addtogroup KernelObject
N */
N
N/*@{*/
N
N/*
N * kernel object macros
N */
N#define RT_OBJECT_FLAG_MODULE           0x80            /**< is module object. */
N
N/**
N * Base structure of Kernel object
N */
Nstruct rt_object
N{
N    char       name[RT_NAME_MAX];                       /**< name of kernel object */
X    char       name[8];                        
N    rt_uint8_t type;                                    /**< type of kernel object */
N    rt_uint8_t flag;                                    /**< flag of kernel object */
N
N#ifdef RT_USING_MODULE
S    void      *module_id;                               /**< id of application module */
N#endif
N    rt_list_t  list;                                    /**< list node of kernel object */
N};
Ntypedef struct rt_object *rt_object_t;                  /**< Type for kernel objects. */
N
N/**
N *  The object type can be one of the follows with specific
N *  macros enabled:
N *  - Thread
N *  - Semaphore
N *  - Mutex
N *  - Event
N *  - MailBox
N *  - MessageQueue
N *  - MemHeap
N *  - MemPool
N *  - Device
N *  - Timer
N *  - Module
N *  - Unknown
N *  - Static
N */
Nenum rt_object_class_type
N{
N    RT_Object_Class_Thread = 0,                         /**< The object is a thread. */
N#ifdef RT_USING_SEMAPHORE
N    RT_Object_Class_Semaphore,                          /**< The object is a semaphore. */
N#endif
N#ifdef RT_USING_MUTEX
N    RT_Object_Class_Mutex,                              /**< The object is a mutex. */
N#endif
N#ifdef RT_USING_EVENT
N    RT_Object_Class_Event,                              /**< The object is a event. */
N#endif
N#ifdef RT_USING_MAILBOX
N    RT_Object_Class_MailBox,                            /**< The object is a mail box. */
N#endif
N#ifdef RT_USING_MESSAGEQUEUE
N    RT_Object_Class_MessageQueue,                       /**< The object is a message queue. */
N#endif
N#ifdef RT_USING_MEMHEAP
S    RT_Object_Class_MemHeap,                            /**< The object is a memory heap */
N#endif
N#ifdef RT_USING_MEMPOOL
N    RT_Object_Class_MemPool,                            /**< The object is a memory pool. */
N#endif
N#ifdef RT_USING_DEVICE
N    RT_Object_Class_Device,                             /**< The object is a device */
N#endif
N    RT_Object_Class_Timer,                              /**< The object is a timer. */
N#ifdef RT_USING_MODULE
S    RT_Object_Class_Module,                             /**< The object is a module. */
N#endif
N    RT_Object_Class_Unknown,                            /**< The object is unknown. */
N    RT_Object_Class_Static = 0x80                       /**< The object is a static object. */
N};
N
N/**
N * The information of the kernel object
N */
Nstruct rt_object_information
N{
N    enum rt_object_class_type type;                     /**< object class type */
N    rt_list_t                 object_list;              /**< object list */
N    rt_size_t                 object_size;              /**< object size */
N};
N
N/**
N * The hook function call macro
N */
N#ifdef RT_USING_HOOK
N#define RT_OBJECT_HOOK_CALL(func, argv) \
N    do { if ((func) != RT_NULL) func argv; } while (0)
X#define RT_OBJECT_HOOK_CALL(func, argv)     do { if ((func) != RT_NULL) func argv; } while (0)
N#else
S#define RT_OBJECT_HOOK_CALL(func, argv)
N#endif
N
N/*@}*/
N
N/**
N * @addtogroup Clock
N */
N
N/*@{*/
N
N/**
N * clock & timer macros
N */
N#define RT_TIMER_FLAG_DEACTIVATED       0x0             /**< timer is deactive */
N#define RT_TIMER_FLAG_ACTIVATED         0x1             /**< timer is active */
N#define RT_TIMER_FLAG_ONE_SHOT          0x0             /**< one shot timer */
N#define RT_TIMER_FLAG_PERIODIC          0x2             /**< periodic timer */
N
N#define RT_TIMER_FLAG_HARD_TIMER        0x0             /**< hard timer,the timer's callback function will be called in tick isr. */
N#define RT_TIMER_FLAG_SOFT_TIMER        0x4             /**< soft timer,the timer's callback function will be called in timer thread. */
N
N#define RT_TIMER_CTRL_SET_TIME          0x0             /**< set timer control command */
N#define RT_TIMER_CTRL_GET_TIME          0x1             /**< get timer control command */
N#define RT_TIMER_CTRL_SET_ONESHOT       0x2             /**< change timer to one shot */
N#define RT_TIMER_CTRL_SET_PERIODIC      0x3             /**< change timer to periodic */
N
N#ifndef RT_TIMER_SKIP_LIST_LEVEL
N#define RT_TIMER_SKIP_LIST_LEVEL          1
N#endif
N
N/* 1 or 3 */
N#ifndef RT_TIMER_SKIP_LIST_MASK
N#define RT_TIMER_SKIP_LIST_MASK         0x3
N#endif
N
N/**
N * timer structure
N */
Nstruct rt_timer
N{
N    struct rt_object parent;                            /**< inherit from rt_object */
N
N    rt_list_t        row[RT_TIMER_SKIP_LIST_LEVEL];
X    rt_list_t        row[1];
N
N    void (*timeout_func)(void *parameter);              /**< timeout function */
N    void            *parameter;                         /**< timeout function's parameter */
N
N    rt_tick_t        init_tick;                         /**< timer timeout tick */
N    rt_tick_t        timeout_tick;                      /**< timeout tick */
N};
Ntypedef struct rt_timer *rt_timer_t;
N
N/*@}*/
N
N/**
N * @addtogroup Thread
N */
N
N/*@{*/
N
N/*
N * Thread
N */
N
N/*
N * thread state definitions
N */
N#define RT_THREAD_INIT                  0x00                /**< Initialized status */
N#define RT_THREAD_READY                 0x01                /**< Ready status */
N#define RT_THREAD_SUSPEND               0x02                /**< Suspend status */
N#define RT_THREAD_RUNNING               0x03                /**< Running status */
N#define RT_THREAD_BLOCK                 RT_THREAD_SUSPEND   /**< Blocked status */
N#define RT_THREAD_CLOSE                 0x04                /**< Closed status */
N
N/**
N * thread control command definitions
N */
N#define RT_THREAD_CTRL_STARTUP          0x00                /**< Startup thread. */
N#define RT_THREAD_CTRL_CLOSE            0x01                /**< Close thread. */
N#define RT_THREAD_CTRL_CHANGE_PRIORITY  0x02                /**< Change thread priority. */
N#define RT_THREAD_CTRL_INFO             0x03                /**< Get thread information. */
N
N/**
N * Thread structure
N */
Nstruct rt_thread
N{
N    /* rt object */
N    char        name[RT_NAME_MAX];                      /**< the name of thread */
X    char        name[8];                       
N    rt_uint8_t  type;                                   /**< type of object */
N    rt_uint8_t  flags;                                  /**< thread's flags */
N
N#ifdef RT_USING_MODULE
S    void       *module_id;                              /**< id of application module */
N#endif
N
N    rt_list_t   list;                                   /**< the object list */
N    rt_list_t   tlist;                                  /**< the thread list */
N
N    /* stack point and entry */
N    void       *sp;                                     /**< stack point */
N    void       *entry;                                  /**< entry */
N    void       *parameter;                              /**< parameter */
N    void       *stack_addr;                             /**< stack address */
N    rt_uint32_t stack_size;                             /**< stack size */
N
N    /* error code */
N    rt_err_t    error;                                  /**< error code */
N
N    rt_uint8_t  stat;                                   /**< thread stat */
N
N    /* priority */
N    rt_uint8_t  current_priority;                       /**< current priority */
N    rt_uint8_t  init_priority;                          /**< initialized priority */
N#if RT_THREAD_PRIORITY_MAX > 32
X#if 32 > 32
S    rt_uint8_t  number;
S    rt_uint8_t  high_mask;
N#endif
N    rt_uint32_t number_mask;
N
N#if defined(RT_USING_EVENT)
X#if 1L
N    /* thread event */
N    rt_uint32_t event_set;
N    rt_uint8_t  event_info;
N#endif
N
N    rt_ubase_t  init_tick;                              /**< thread's initialized tick */
N    rt_ubase_t  remaining_tick;                         /**< remaining tick */
N
N    struct rt_timer thread_timer;                       /**< built-in thread timer */
N
N    void (*cleanup)(struct rt_thread *tid);             /**< cleanup function when thread exit */
N
N    rt_uint32_t user_data;                              /**< private user data beyond this thread */
N};
Ntypedef struct rt_thread *rt_thread_t;
N
N/*@}*/
N
N/**
N * @addtogroup IPC
N */
N
N/*@{*/
N
N/**
N * IPC flags and control command definitions
N */
N#define RT_IPC_FLAG_FIFO                0x00            /**< FIFOed IPC. @ref IPC. */
N#define RT_IPC_FLAG_PRIO                0x01            /**< PRIOed IPC. @ref IPC. */
N
N#define RT_IPC_CMD_UNKNOWN              0x00            /**< unknown IPC command */
N#define RT_IPC_CMD_RESET                0x01            /**< reset IPC object */
N
N#define RT_WAITING_FOREVER              -1              /**< Block forever until get resource. */
N#define RT_WAITING_NO                   0               /**< Non-block. */
N
N/**
N * Base structure of IPC object
N */
Nstruct rt_ipc_object
N{
N    struct rt_object parent;                            /**< inherit from rt_object */
N
N    rt_list_t        suspend_thread;                    /**< threads pended on this resource */
N};
N
N#ifdef RT_USING_SEMAPHORE
N/**
N * Semaphore structure
N */
Nstruct rt_semaphore
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint16_t          value;                         /**< value of semaphore. */
N};
Ntypedef struct rt_semaphore *rt_sem_t;
N#endif
N
N#ifdef RT_USING_MUTEX
N/**
N * Mutual exclusion (mutex) structure
N */
Nstruct rt_mutex
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint16_t          value;                         /**< value of mutex */
N
N    rt_uint8_t           original_priority;             /**< priority of last thread hold the mutex */
N    rt_uint8_t           hold;                          /**< numbers of thread hold the mutex */
N
N    struct rt_thread    *owner;                         /**< current owner of mutex */
N};
Ntypedef struct rt_mutex *rt_mutex_t;
N#endif
N
N#ifdef RT_USING_EVENT
N/**
N * flag defintions in event
N */
N#define RT_EVENT_FLAG_AND               0x01            /**< logic and */
N#define RT_EVENT_FLAG_OR                0x02            /**< logic or */
N#define RT_EVENT_FLAG_CLEAR             0x04            /**< clear flag */
N
N/*
N * event structure
N */
Nstruct rt_event
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint32_t          set;                           /**< event set */
N};
Ntypedef struct rt_event *rt_event_t;
N#endif
N
N#ifdef RT_USING_MAILBOX
N/**
N * mailbox structure
N */
Nstruct rt_mailbox
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint32_t         *msg_pool;                      /**< start address of message buffer */
N
N    rt_uint16_t          size;                          /**< size of message pool */
N
N    rt_uint16_t          entry;                         /**< index of messages in msg_pool */
N    rt_uint16_t          in_offset;                     /**< input offset of the message buffer */
N    rt_uint16_t          out_offset;                    /**< output offset of the message buffer */
N
N    rt_list_t            suspend_sender_thread;         /**< sender thread suspended on this mailbox */
N};
Ntypedef struct rt_mailbox *rt_mailbox_t;
N#endif
N
N#ifdef RT_USING_MESSAGEQUEUE
N/**
N * message queue structure
N */
Nstruct rt_messagequeue
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    void                *msg_pool;                      /**< start address of message queue */
N
N    rt_uint16_t          msg_size;                      /**< message size of each message */
N    rt_uint16_t          max_msgs;                      /**< max number of messages */
N
N    rt_uint16_t          entry;                         /**< index of messages in the queue */
N
N    void                *msg_queue_head;                /**< list head */
N    void                *msg_queue_tail;                /**< list tail */
N    void                *msg_queue_free;                /**< pointer indicated the free node of queue */
N};
Ntypedef struct rt_messagequeue *rt_mq_t;
N#endif
N
N/*@}*/
N
N/**
N * @addtogroup MM
N */
N
N/*@{*/
N
N/*
N * memory management
N * heap & partition
N */
N
N#ifdef RT_USING_MEMHEAP
S/**
S * memory item on the heap
S */
Sstruct rt_memheap_item
S{
S    rt_uint32_t             magic;                      /**< magic number for memheap */
S    struct rt_memheap      *pool_ptr;                   /**< point of pool */
S
S    struct rt_memheap_item *next;                       /**< next memheap item */
S    struct rt_memheap_item *prev;                       /**< prev memheap item */
S
S    struct rt_memheap_item *next_free;                  /**< next free memheap item */
S    struct rt_memheap_item *prev_free;                  /**< prev free memheap item */
S};
S
S/**
S * Base structure of memory heap object
S */
Sstruct rt_memheap
S{
S    struct rt_object        parent;                     /**< inherit from rt_object */
S
S    void                   *start_addr;                 /**< pool start address and size */
S
S    rt_uint32_t             pool_size;                  /**< pool size */
S    rt_uint32_t             available_size;             /**< available size */
S    rt_uint32_t             max_used_size;              /**< maximum allocated size */
S
S    struct rt_memheap_item *block_list;                 /**< used block list */
S
S    struct rt_memheap_item *free_list;                  /**< free block list */
S    struct rt_memheap_item  free_header;                /**< free block list header */
S
S    struct rt_semaphore     lock;                       /**< semaphore lock */
S};
N#endif
N
N#ifdef RT_USING_MEMPOOL
N/**
N * Base structure of Memory pool object
N */
Nstruct rt_mempool
N{
N    struct rt_object parent;                            /**< inherit from rt_object */
N
N    void            *start_address;                     /**< memory pool start */
N    rt_size_t        size;                              /**< size of memory pool */
N
N    rt_size_t        block_size;                        /**< size of memory blocks */
N    rt_uint8_t      *block_list;                        /**< memory blocks list */
N
N    rt_size_t        block_total_count;                 /**< numbers of memory block */
N    rt_size_t        block_free_count;                  /**< numbers of free memory block */
N
N    rt_list_t        suspend_thread;                    /**< threads pended on this resource */
N    rt_size_t        suspend_thread_count;              /**< numbers of thread pended on this resource */
N};
Ntypedef struct rt_mempool *rt_mp_t;
N#endif
N
N/*@}*/
N
N#ifdef RT_USING_DEVICE
N/**
N * @addtogroup Device
N */
N
N/*@{*/
N
N/**
N * device (I/O) class type
N */
Nenum rt_device_class_type
N{
N    RT_Device_Class_Char = 0,                           /**< character device */
N    RT_Device_Class_Block,                              /**< block device */
N    RT_Device_Class_NetIf,                              /**< net interface */
N    RT_Device_Class_MTD,                                /**< memory device */
N    RT_Device_Class_CAN,                                /**< CAN device */
N    RT_Device_Class_RTC,                                /**< RTC device */
N    RT_Device_Class_Sound,                              /**< Sound device */
N    RT_Device_Class_Graphic,                            /**< Graphic device */
N    RT_Device_Class_I2CBUS,                             /**< I2C bus device */
N    RT_Device_Class_USBDevice,                          /**< USB slave device */
N    RT_Device_Class_USBHost,                            /**< USB host bus */
N    RT_Device_Class_SPIBUS,                             /**< SPI bus device */
N    RT_Device_Class_SPIDevice,                          /**< SPI device */
N    RT_Device_Class_SDIO,                               /**< SDIO bus device */
N    RT_Device_Class_PM,                                 /**< PM pseudo device */
N    RT_Device_Class_Pipe,                               /**< Pipe device */
N    RT_Device_Class_Portal,                             /**< Portal device */
N    RT_Device_Class_Timer,                              /**< Timer device */
N	RT_Device_Class_Miscellaneous,                      /**< Miscellaneous device */
N	RT_Device_Class_Unknown                             /**< unknown device */
N};
N
N/**
N * device flags defitions
N */
N#define RT_DEVICE_FLAG_DEACTIVATE       0x000           /**< device is not not initialized */
N
N#define RT_DEVICE_FLAG_RDONLY           0x001           /**< read only */
N#define RT_DEVICE_FLAG_WRONLY           0x002           /**< write only */
N#define RT_DEVICE_FLAG_RDWR             0x003           /**< read and write */
N
N#define RT_DEVICE_FLAG_REMOVABLE        0x004           /**< removable device */
N#define RT_DEVICE_FLAG_STANDALONE       0x008           /**< standalone device */
N#define RT_DEVICE_FLAG_ACTIVATED        0x010           /**< device is activated */
N#define RT_DEVICE_FLAG_SUSPENDED        0x020           /**< device is suspended */
N#define RT_DEVICE_FLAG_STREAM           0x040           /**< stream mode */
N
N#define RT_DEVICE_CTRL_CONFIG           0x03    	/* configure device */
N#define RT_DEVICE_CTRL_SET_INT          0x10    	/* enable receive irq */
N#define RT_DEVICE_CTRL_CLR_INT          0x11    	/* disable receive irq */
N#define RT_DEVICE_CTRL_GET_INT          0x12
N
N#define RT_DEVICE_FLAG_INT_RX           0x100           /**< INT mode on Rx */
N#define RT_DEVICE_FLAG_DMA_RX           0x200           /**< DMA mode on Rx */
N#define RT_DEVICE_FLAG_INT_TX           0x400           /**< INT mode on Tx */
N#define RT_DEVICE_FLAG_DMA_TX           0x800           /**< DMA mode on Tx */
N
N#define RT_DEVICE_OFLAG_CLOSE           0x000           /**< device is closed */
N#define RT_DEVICE_OFLAG_RDONLY          0x001           /**< read only access */
N#define RT_DEVICE_OFLAG_WRONLY          0x002           /**< write only access */
N#define RT_DEVICE_OFLAG_RDWR            0x003           /**< read and write */
N#define RT_DEVICE_OFLAG_OPEN            0x008           /**< device is opened */
N
N/**
N * general device commands
N */
N#define RT_DEVICE_CTRL_RESUME           0x01            /**< resume device */
N#define RT_DEVICE_CTRL_SUSPEND          0x02            /**< suspend device */
N
N/**
N * special device commands
N */
N#define RT_DEVICE_CTRL_CHAR_STREAM      0x10            /**< stream mode on char device */
N#define RT_DEVICE_CTRL_BLK_GETGEOME     0x10            /**< get geometry information   */
N#define RT_DEVICE_CTRL_BLK_SYNC         0x11            /**< flush data to block device */
N#define RT_DEVICE_CTRL_BLK_ERASE        0x12            /**< erase block on block device */
N#define RT_DEVICE_CTRL_BLK_AUTOREFRESH  0x13            /**< block device : enter/exit auto refresh mode */
N#define RT_DEVICE_CTRL_NETIF_GETMAC     0x10            /**< get mac address */
N#define RT_DEVICE_CTRL_MTD_FORMAT       0x10            /**< format a MTD device */
N#define RT_DEVICE_CTRL_RTC_GET_TIME     0x10            /**< get time */
N#define RT_DEVICE_CTRL_RTC_SET_TIME     0x11            /**< set time */
N#define RT_DEVICE_CTRL_RTC_GET_ALARM    0x12            /**< get alarm */
N#define RT_DEVICE_CTRL_RTC_SET_ALARM    0x13            /**< set alarm */
N
Ntypedef struct rt_device *rt_device_t;
N/**
N * Device structure
N */
Nstruct rt_device
N{
N    struct rt_object          parent;                   /**< inherit from rt_object */
N
N    enum rt_device_class_type type;                     /**< device type */
N    rt_uint16_t               flag;                     /**< device flag */
N    rt_uint16_t               open_flag;                /**< device open flag */
N
N    rt_uint8_t                ref_count;                /**< reference count */
N    rt_uint8_t                device_id;                /**< 0 - 255 */
N
N    /* device call back */
N    rt_err_t (*rx_indicate)(rt_device_t dev, rt_size_t size);
N    rt_err_t (*tx_complete)(rt_device_t dev, void *buffer);
N
N    /* common device interface */
N    rt_err_t  (*init)   (rt_device_t dev);
N    rt_err_t  (*open)   (rt_device_t dev, rt_uint16_t oflag);
N    rt_err_t  (*close)  (rt_device_t dev);
N    rt_size_t (*read)   (rt_device_t dev, rt_off_t pos, void *buffer, rt_size_t size);
N    rt_size_t (*write)  (rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size);
N    rt_err_t  (*control)(rt_device_t dev, rt_uint8_t cmd, void *args);
N
N    void                     *user_data;                /**< device private data */
N};
N
N/**
N * block device geometry structure
N */
Nstruct rt_device_blk_geometry
N{
N    rt_uint32_t sector_count;                           /**< count of sectors */
N    rt_uint32_t bytes_per_sector;                       /**< number of bytes per sector */
N    rt_uint32_t block_size;                             /**< number of bytes to erase one block */
N};
N
N/**
N * sector arrange struct on block device
N */
Nstruct rt_device_blk_sectors
N{
N    rt_uint32_t sector_begin;                           /**< begin sector */
N    rt_uint32_t sector_end;                             /**< end sector   */
N};
N
N/**
N * cursor control command
N */
N#define RT_DEVICE_CTRL_CURSOR_SET_POSITION  0x10
N#define RT_DEVICE_CTRL_CURSOR_SET_TYPE      0x11
N
N/**
N * graphic device control command
N */
N#define RTGRAPHIC_CTRL_RECT_UPDATE      0
N#define RTGRAPHIC_CTRL_POWERON          1
N#define RTGRAPHIC_CTRL_POWEROFF         2
N#define RTGRAPHIC_CTRL_GET_INFO         3
N#define RTGRAPHIC_CTRL_SET_MODE         4
N#define RTGRAPHIC_CTRL_GET_EXT          5
N
N/* graphic deice */
Nenum
N{
N    RTGRAPHIC_PIXEL_FORMAT_MONO = 0,
N    RTGRAPHIC_PIXEL_FORMAT_GRAY4,
N    RTGRAPHIC_PIXEL_FORMAT_GRAY16,
N    RTGRAPHIC_PIXEL_FORMAT_RGB332,
N    RTGRAPHIC_PIXEL_FORMAT_RGB444,
N    RTGRAPHIC_PIXEL_FORMAT_RGB565,
N    RTGRAPHIC_PIXEL_FORMAT_RGB565P,
N    RTGRAPHIC_PIXEL_FORMAT_BGR565 = RTGRAPHIC_PIXEL_FORMAT_RGB565P,
N    RTGRAPHIC_PIXEL_FORMAT_RGB666,
N    RTGRAPHIC_PIXEL_FORMAT_RGB888,
N    RTGRAPHIC_PIXEL_FORMAT_ARGB888,
N    RTGRAPHIC_PIXEL_FORMAT_ABGR888,
N};
N
N/**
N * build a pixel position according to (x, y) coordinates.
N */
N#define RTGRAPHIC_PIXEL_POSITION(x, y)  ((x << 16) | y)
N
N/**
N * graphic device information structure
N */
Nstruct rt_device_graphic_info
N{
N    rt_uint8_t  pixel_format;                           /**< graphic format */
N    rt_uint8_t  bits_per_pixel;                         /**< bits per pixel */
N    rt_uint16_t reserved;                               /**< reserved field */
N
N    rt_uint16_t width;                                  /**< width of graphic device */
N    rt_uint16_t height;                                 /**< height of graphic device */
N
N    rt_uint8_t *framebuffer;                            /**< frame buffer */
N};
N
N/**
N * rectangle information structure
N */
Nstruct rt_device_rect_info
N{
N    rt_uint16_t x;                                      /**< x coordinate */
N    rt_uint16_t y;                                      /**< y coordinate */
N    rt_uint16_t width;                                  /**< width */
N    rt_uint16_t height;                                 /**< height */
N};
N
N/**
N * graphic operations
N */
Nstruct rt_device_graphic_ops
N{
N    void (*set_pixel) (const char *pixel, int x, int y);
N    void (*get_pixel) (char *pixel, int x, int y);
N
N    void (*draw_hline)(const char *pixel, int x1, int x2, int y);
N    void (*draw_vline)(const char *pixel, int x, int y1, int y2);
N
N    void (*blit_line) (const char *pixel, int x, int y, rt_size_t size);
N};
N#define rt_graphix_ops(device)          ((struct rt_device_graphic_ops *)(device->user_data))
N
N/*@}*/
N#endif
N
N#ifdef RT_USING_MODULE
S/**
S * @addtogroup Module
S */
S
S/*@{*/
S
S/*
S * module system
S */
S
S#define RT_MODULE_FLAG_WITHENTRY        0x00            /**< with entry point */
S#define RT_MODULE_FLAG_WITHOUTENTRY     0x01            /**< without entry point */
S
S/**
S * Application Module structure
S */
Sstruct rt_module
S{
S    struct rt_object             parent;                /**< inherit from object */
S
S    rt_uint32_t                  vstart_addr;            /**< VMA base address for the
S                                                          first LOAD segment. */
S    rt_uint8_t                  *module_space;          /**< module memory space */
S
S    void                        *module_entry;          /**< the entry address of module */
S    rt_thread_t                  module_thread;         /**< the main thread of module */
S
S	rt_uint8_t*                  module_cmd_line;		/**< module command line */
S	rt_uint32_t                  module_cmd_size;		/**< the size of module command line */
S
S#ifdef RT_USING_SLAB
S    /* module memory allocator */
S    void                        *mem_list;              /**< module's free memory list */
S    void                        *page_array;            /**< module's using pages */
S    rt_uint32_t                  page_cnt;              /**< module's using pages count */
S#endif
S
S    rt_uint16_t                  nref;                  /**< reference count */
S
S    rt_uint16_t                  nsym;                  /**< number of symbol in the module */
S    struct rt_module_symtab     *symtab;                /**< module symbol table */
S
S    /* object in this module, module object is the last basic object type */
S    struct rt_object_information module_object[RT_Object_Class_Unknown];
S};
Stypedef struct rt_module *rt_module_t;
S
S/*@}*/
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 37 "..\rt_thread\include\rtthread.h" 2
N#include <rtservice.h>
L 1 "..\rt_thread\include\rtservice.h" 1
N/*
N * File      : rtservice.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-16     Bernard      the first version
N * 2006-09-07     Bernard      move the kservice APIs to rtthread.h
N * 2007-06-27     Bernard      fix the rt_list_remove bug
N * 2012-03-22     Bernard      rename kservice.h to rtservice.h
N */
N
N#ifndef __RT_SERVICE_H__
N#define __RT_SERVICE_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @addtogroup KernelService
N */
N
N/*@{*/
N
N/**
N * @brief initialize a list object
N */
N#define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }
N
N/**
N * @brief initialize a list
N *
N * @param l list to be initialized
N */
Nrt_inline void rt_list_init(rt_list_t *l)
Xstatic __inline void rt_list_init(rt_list_t *l)
N{
N    l->next = l->prev = l;
N}
N
N/**
N * @brief insert a node after a list
N *
N * @param l list to insert it
N * @param n new node to be inserted
N */
Nrt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
Xstatic __inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
N{
N    l->next->prev = n;
N    n->next = l->next;
N
N    l->next = n;
N    n->prev = l;
N}
N
N/**
N * @brief insert a node before a list
N *
N * @param n new node to be inserted
N * @param l list to insert it
N */
Nrt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
Xstatic __inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
N{
N    l->prev->next = n;
N    n->prev = l->prev;
N
N    l->prev = n;
N    n->next = l;
N}
N
N/**
N * @brief remove node from list.
N * @param n the node to remove from the list.
N */
Nrt_inline void rt_list_remove(rt_list_t *n)
Xstatic __inline void rt_list_remove(rt_list_t *n)
N{
N    n->next->prev = n->prev;
N    n->prev->next = n->next;
N
N    n->next = n->prev = n;
N}
N
N/**
N * @brief tests whether a list is empty
N * @param l the list to test.
N */
Nrt_inline int rt_list_isempty(const rt_list_t *l)
Xstatic __inline int rt_list_isempty(const rt_list_t *l)
N{
N    return l->next == l;
N}
N
N/**
N * @brief get the struct for this entry
N * @param node the entry point
N * @param type the type of structure
N * @param member the name of list in structure
N */
N#define rt_list_entry(node, type, member) \
N    ((type *)((char *)(node) - (unsigned long)(&((type *)0)->member)))
X#define rt_list_entry(node, type, member)     ((type *)((char *)(node) - (unsigned long)(&((type *)0)->member)))
N
N/**
N * list_for_each_entry  -   iterate over list of given type
N * @pos:    the type * to use as a loop cursor.
N * @head:   the head for your list.
N * @member: the name of the list_struct within the struct.
N */
N#define list_for_each_entry(pos, head, member)              \
N    for (pos = rt_list_entry((head)->next, typeof(*pos), member);  \
N         &pos->member != (head);    \
N         pos = rt_list_entry(pos->member.next, typeof(*pos), member))
X#define list_for_each_entry(pos, head, member)                  for (pos = rt_list_entry((head)->next, typeof(*pos), member);           &pos->member != (head);             pos = rt_list_entry(pos->member.next, typeof(*pos), member))
N
N/**
N * list_first_entry - get the first element from a list
N * @ptr:    the list head to take the element from.
N * @type:   the type of the struct this is embedded in.
N * @member: the name of the list_struct within the struct.
N *
N * Note, that list is expected to be not empty.
N */
N#define list_first_entry(ptr, type, member) \
N    rt_list_entry((ptr)->next, type, member)
X#define list_first_entry(ptr, type, member)     rt_list_entry((ptr)->next, type, member)
N/*@}*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 38 "..\rt_thread\include\rtthread.h" 2
N#include <rtm.h>
L 1 "..\rt_thread\include\rtm.h" 1
N/*
N * File      : rtm.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N */
N
N#ifndef __RTM_H__
N#define __RTM_H__
N
N#include <rtdef.h>
N#include <rtthread.h>
L 1 "..\rt_thread\include\rtthread.h" 1
N/*
N * File      : rtthread.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-18     Bernard      the first version
N * 2006-04-26     Bernard      add semaphore APIs
N * 2006-08-10     Bernard      add version information
N * 2007-01-28     Bernard      rename RT_OBJECT_Class_Static to RT_Object_Class_Static
N * 2007-03-03     Bernard      clean up the definitions to rtdef.h
N * 2010-04-11     yi.qiu       add module feature
N * 2013-06-24     Bernard      add rt_kprintf re-define when not use RT_USING_CONSOLE.
N */
N
N#ifndef __RT_THREAD_H__
S#define __RT_THREAD_H__
S
S#include <rtconfig.h>
S#include <rtdebug.h>
S#include <rtdef.h>
S#include <rtservice.h>
S#include <rtm.h>
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/**
S * @addtogroup KernelObject
S */
S
S/*@{*/
S
S/*
S * kernel object interface
S */
Svoid rt_system_object_init(void);
Sstruct rt_object_information *
Srt_object_get_information(enum rt_object_class_type type);
Svoid rt_object_init(struct rt_object         *object,
S                    enum rt_object_class_type type,
S                    const char               *name);
Svoid rt_object_detach(rt_object_t object);
Srt_object_t rt_object_allocate(enum rt_object_class_type type,
S                               const char               *name);
Svoid rt_object_delete(rt_object_t object);
Srt_bool_t rt_object_is_systemobject(rt_object_t object);
Srt_object_t rt_object_find(const char *name, rt_uint8_t type);
S
S#ifdef RT_USING_HOOK
Svoid rt_object_attach_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_detach_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_trytake_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_take_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_put_sethook(void (*hook)(struct rt_object *object));
S#endif
S
S/*@}*/
S
S/**
S * @addtogroup Clock
S */
S
S/*@{*/
S
S/*
S * clock & timer interface
S */
Svoid rt_system_tick_init(void);
Srt_tick_t rt_tick_get(void);
Svoid rt_tick_set(rt_tick_t tick);
Svoid rt_tick_increase(void);
Srt_tick_t rt_tick_from_millisecond(rt_uint32_t ms);
S
Svoid rt_system_timer_init(void);
Svoid rt_system_timer_thread_init(void);
S
Svoid rt_timer_init(rt_timer_t  timer,
S                   const char *name,
S                   void (*timeout)(void *parameter),
S                   void       *parameter,
S                   rt_tick_t   time,
S                   rt_uint8_t  flag);
Srt_err_t rt_timer_detach(rt_timer_t timer);
Srt_timer_t rt_timer_create(const char *name,
S                           void (*timeout)(void *parameter),
S                           void       *parameter,
S                           rt_tick_t   time,
S                           rt_uint8_t  flag);
Srt_err_t rt_timer_delete(rt_timer_t timer);
Srt_err_t rt_timer_start(rt_timer_t timer);
Srt_err_t rt_timer_stop(rt_timer_t timer);
Srt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg);
S
Srt_tick_t rt_timer_next_timeout_tick(void);
Svoid rt_timer_check(void);
S
S#ifdef RT_USING_HOOK
Svoid rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer));
S#endif
S
S/*@}*/
S
S/**
S * @addtogroup Thread
S */
S
S/*@{*/
S
S/*
S * thread interface
S */
Srt_err_t rt_thread_init(struct rt_thread *thread,
S                        const char       *name,
S                        void (*entry)(void *parameter),
S                        void             *parameter,
S                        void             *stack_start,
S                        rt_uint32_t       stack_size,
S                        rt_uint8_t        priority,
S                        rt_uint32_t       tick);
Srt_err_t rt_thread_detach(rt_thread_t thread);
Srt_thread_t rt_thread_create(const char *name,
S                             void (*entry)(void *parameter),
S                             void       *parameter,
S                             rt_uint32_t stack_size,
S                             rt_uint8_t  priority,
S                             rt_uint32_t tick);
Srt_thread_t rt_thread_self(void);
Srt_thread_t rt_thread_find(char *name);
Srt_err_t rt_thread_startup(rt_thread_t thread);
Srt_err_t rt_thread_delete(rt_thread_t thread);
S
Srt_err_t rt_thread_yield(void);
Srt_err_t rt_thread_delay(rt_tick_t tick);
Srt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg);
Srt_err_t rt_thread_suspend(rt_thread_t thread);
Srt_err_t rt_thread_resume(rt_thread_t thread);
Svoid rt_thread_timeout(void *parameter);
S
S/*
S * idle thread interface
S */
Svoid rt_thread_idle_init(void);
S#ifdef RT_USING_HOOK
Svoid rt_thread_idle_sethook(void (*hook)(void));
S#endif
Svoid rt_thread_idle_excute(void);
S
S/*
S * schedule service
S */
Svoid rt_system_scheduler_init(void);
Svoid rt_system_scheduler_start(void);
S
Svoid rt_schedule(void);
Svoid rt_schedule_insert_thread(struct rt_thread *thread);
Svoid rt_schedule_remove_thread(struct rt_thread *thread);
S
Svoid rt_enter_critical(void);
Svoid rt_exit_critical(void);
Srt_uint16_t rt_critical_level(void);
S
S#ifdef RT_USING_HOOK
Svoid rt_scheduler_sethook(void (*hook)(rt_thread_t from, rt_thread_t to));
S#endif
S
S/*@}*/
S
S/**
S * @addtogroup MM
S */
S
S/*@{*/
S
S/*
S * memory management interface
S */
S#ifdef RT_USING_MEMPOOL
S/*
S * memory pool interface
S */
Srt_err_t rt_mp_init(struct rt_mempool *mp,
S                    const char        *name,
S                    void              *start,
S                    rt_size_t          size,
S                    rt_size_t          block_size);
Srt_err_t rt_mp_detach(struct rt_mempool *mp);
Srt_mp_t rt_mp_create(const char *name,
S                     rt_size_t   block_count,
S                     rt_size_t   block_size);
Srt_err_t rt_mp_delete(rt_mp_t mp);
S
Svoid *rt_mp_alloc(rt_mp_t mp, rt_int32_t time);
Svoid rt_mp_free(void *block);
S
S#ifdef RT_USING_HOOK
Svoid rt_mp_alloc_sethook(void (*hook)(struct rt_mempool *mp, void *block));
Svoid rt_mp_free_sethook(void (*hook)(struct rt_mempool *mp, void *block));
S#endif
S
S#endif
S
S#ifdef RT_USING_HEAP
S/*
S * heap memory interface
S */
Svoid rt_system_heap_init(void *begin_addr, void *end_addr);
S
Svoid *rt_malloc(rt_size_t nbytes);
Svoid rt_free(void *ptr);
Svoid *rt_realloc(void *ptr, rt_size_t nbytes);
Svoid *rt_calloc(rt_size_t count, rt_size_t size);
Svoid *rt_malloc_align(rt_size_t size, rt_size_t align);
Svoid rt_free_align(void *ptr);
S
Svoid rt_memory_info(rt_uint32_t *total,
S                    rt_uint32_t *used,
S                    rt_uint32_t *max_used);
S
S#ifdef RT_USING_SLAB
Svoid *rt_page_alloc(rt_size_t npages);
Svoid rt_page_free(void *addr, rt_size_t npages);
S#endif
S
S#ifdef RT_USING_HOOK
Svoid rt_malloc_sethook(void (*hook)(void *ptr, rt_uint32_t size));
Svoid rt_free_sethook(void (*hook)(void *ptr));
S#endif
S
S#endif
S
S#ifdef RT_USING_MEMHEAP
S/**
S * memory heap object interface
S */
Srt_err_t rt_memheap_init(struct rt_memheap *memheap,
S                         const char        *name,
S                         void              *start_addr,
S                         rt_uint32_t        size);
Srt_err_t rt_memheap_detach(struct rt_memheap *heap);
Svoid* rt_memheap_alloc(struct rt_memheap *heap, rt_uint32_t size);
Svoid *rt_memheap_realloc(struct rt_memheap* heap, void* ptr, rt_size_t newsize);
Svoid rt_memheap_free(void *ptr);
S#endif
S
S/*@}*/
S
S/**
S * @addtogroup IPC
S */
S
S/*@{*/
S
S#ifdef RT_USING_SEMAPHORE
S/*
S * semaphore interface
S */
Srt_err_t rt_sem_init(rt_sem_t    sem,
S                     const char *name,
S                     rt_uint32_t value,
S                     rt_uint8_t  flag);
Srt_err_t rt_sem_detach(rt_sem_t sem);
Srt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);
Srt_err_t rt_sem_delete(rt_sem_t sem);
S
Srt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time);
Srt_err_t rt_sem_trytake(rt_sem_t sem);
Srt_err_t rt_sem_release(rt_sem_t sem);
Srt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_MUTEX
S/*
S * mutex interface
S */
Srt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag);
Srt_err_t rt_mutex_detach(rt_mutex_t mutex);
Srt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);
Srt_err_t rt_mutex_delete(rt_mutex_t mutex);
S
Srt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time);
Srt_err_t rt_mutex_release(rt_mutex_t mutex);
Srt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_EVENT
S/*
S * event interface
S */
Srt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag);
Srt_err_t rt_event_detach(rt_event_t event);
Srt_event_t rt_event_create(const char *name, rt_uint8_t flag);
Srt_err_t rt_event_delete(rt_event_t event);
S
Srt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);
Srt_err_t rt_event_recv(rt_event_t   event,
S                       rt_uint32_t  set,
S                       rt_uint8_t   opt,
S                       rt_int32_t   timeout,
S                       rt_uint32_t *recved);
Srt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_MAILBOX
S/*
S * mailbox interface
S */
Srt_err_t rt_mb_init(rt_mailbox_t mb,
S                    const char  *name,
S                    void        *msgpool,
S                    rt_size_t    size,
S                    rt_uint8_t   flag);
Srt_err_t rt_mb_detach(rt_mailbox_t mb);
Srt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag);
Srt_err_t rt_mb_delete(rt_mailbox_t mb);
S
Srt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value);
Srt_err_t rt_mb_send_wait(rt_mailbox_t mb,
S                         rt_uint32_t  value,
S                         rt_int32_t   timeout);
Srt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout);
Srt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_MESSAGEQUEUE
S/*
S * message queue interface
S */
Srt_err_t rt_mq_init(rt_mq_t     mq,
S                    const char *name,
S                    void       *msgpool,
S                    rt_size_t   msg_size,
S                    rt_size_t   pool_size,
S                    rt_uint8_t  flag);
Srt_err_t rt_mq_detach(rt_mq_t mq);
Srt_mq_t rt_mq_create(const char *name,
S                     rt_size_t   msg_size,
S                     rt_size_t   max_msgs,
S                     rt_uint8_t  flag);
Srt_err_t rt_mq_delete(rt_mq_t mq);
S
Srt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size);
Srt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size);
Srt_err_t rt_mq_recv(rt_mq_t    mq,
S                    void      *buffer,
S                    rt_size_t  size,
S                    rt_int32_t timeout);
Srt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg);
S#endif
S
S/*@}*/
S
S#ifdef RT_USING_DEVICE
S/**
S * @addtogroup Device
S */
S
S/*@{*/
S
S/*
S * device (I/O) system interface
S */
Srt_device_t rt_device_find(const char *name);
S
Srt_err_t rt_device_register(rt_device_t dev,
S                            const char *name,
S                            rt_uint16_t flags);
Srt_err_t rt_device_unregister(rt_device_t dev);
Srt_err_t rt_device_init_all(void);
S
Srt_err_t
Srt_device_set_rx_indicate(rt_device_t dev,
S                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size));
Srt_err_t
Srt_device_set_tx_complete(rt_device_t dev,
S                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer));
S
Srt_err_t  rt_device_init (rt_device_t dev);
Srt_err_t  rt_device_open (rt_device_t dev, rt_uint16_t oflag);
Srt_err_t  rt_device_close(rt_device_t dev);
Srt_size_t rt_device_read (rt_device_t dev,
S                          rt_off_t    pos,
S                          void       *buffer,
S                          rt_size_t   size);
Srt_size_t rt_device_write(rt_device_t dev,
S                          rt_off_t    pos,
S                          const void *buffer,
S                          rt_size_t   size);
Srt_err_t  rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg);
S
S/*@}*/
S#endif
S
S#ifdef RT_USING_MODULE
S/**
S * @addtogroup Module
S */
S
S/*@{*/
S
S/*
S * module interface
S */
Srt_module_t rt_module_load(const char *name, void *module_ptr);
Srt_err_t rt_module_unload(rt_module_t module);
S#ifdef RT_USING_DFS
Srt_module_t rt_module_open(const char *filename);
Srt_module_t rt_module_exec_cmd(const char *path, const char* cmd_line, int size);
S#endif
Svoid *rt_module_malloc(rt_size_t size);
Svoid *rt_module_realloc(void *ptr, rt_size_t size);
Svoid rt_module_free(rt_module_t module, void *addr);
Srt_module_t rt_module_self(void);
Srt_module_t rt_module_find(const char *name);
S
S#ifdef RT_USING_HOOK
Svoid rt_module_load_sethook(void (*hook)(rt_module_t module));
Svoid rt_module_unload_sethook(void (*hook)(rt_module_t module));
S#endif
S
Svoid rt_module_init_object_container(struct rt_module *module);
Srt_err_t rt_module_destroy(rt_module_t module);
S
S/*
S * application module system initialization
S */
Sint rt_system_module_init(void);
S
S/*@}*/
S#endif
S
S/*
S * interrupt service
S */
S
S/*
S * rt_interrupt_enter and rt_interrupt_leave only can be called by BSP
S */
Svoid rt_interrupt_enter(void);
Svoid rt_interrupt_leave(void);
S
S/*
S * the number of nested interrupts.
S */
Srt_uint8_t rt_interrupt_get_nest(void);
S
S#ifdef RT_USING_COMPONENTS_INIT
Svoid rt_components_init(void);
Svoid rt_components_board_init(void);
S#endif
S
S/**
S * @addtogroup KernelService
S */
S
S/*@{*/
S
S/*
S * general kernel service
S */
S#ifndef RT_USING_CONSOLE
S#define rt_kprintf(...)
S#else
Svoid rt_kprintf(const char *fmt, ...);
S#endif
Srt_int32_t rt_vsprintf(char *dest, const char *format, va_list arg_ptr);
Srt_int32_t rt_vsnprintf(char *buf, rt_size_t size, const char *fmt, va_list args);
Srt_int32_t rt_sprintf(char *buf ,const char *format, ...);
Srt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *format, ...);
S
S#if defined(RT_USING_DEVICE) && defined(RT_USING_CONSOLE)
Srt_device_t rt_console_set_device(const char *name);
Srt_device_t rt_console_get_device(void);
S#endif
S
Srt_err_t rt_get_errno(void);
Svoid rt_set_errno(rt_err_t no);
Sint *_rt_errno(void);
S#ifndef RT_USING_NEWLIB
S#ifndef errno
S#define errno    *_rt_errno()
S#endif
S#endif
S
Svoid *rt_memset(void *src, int c, rt_ubase_t n);
Svoid *rt_memcpy(void *dest, const void *src, rt_ubase_t n);
S
Srt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count);
Srt_int32_t rt_strcmp (const char *cs, const char *ct);
Srt_size_t rt_strlen (const char *src);
Schar *rt_strdup(const char *s);
S
Schar *rt_strstr(const char *str1, const char *str2);
Srt_int32_t rt_sscanf(const char *buf, const char *fmt, ...);
Schar *rt_strncpy(char *dest, const char *src, rt_ubase_t n);
Svoid *rt_memmove(void *dest, const void *src, rt_ubase_t n);
Srt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count);
Srt_uint32_t rt_strcasecmp(const char *a, const char *b);
S
Svoid rt_show_version(void);
S
S#ifdef RT_DEBUG
Sextern void (*rt_assert_hook)(const char* ex, const char* func, rt_size_t line);
Svoid rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line));
S
Svoid rt_assert_handler(const char* ex, const char* func, rt_size_t line);
S#endif /* RT_DEBUG */
S
S/*@}*/
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif
L 26 "..\rt_thread\include\rtm.h" 2
N
N#ifdef RT_USING_MODULE
Sstruct rt_module_symtab
S{
S    void       *addr;
S    const char *name;
S};
S
S#if defined(_MSC_VER)
S#pragma section("RTMSymTab$f",read)
S#define RTM_EXPORT(symbol)                                            \
S__declspec(allocate("RTMSymTab$f"))const char __rtmsym_##symbol##_name[] = "__vs_rtm_"#symbol;
X#define RTM_EXPORT(symbol)                                            __declspec(allocate("RTMSymTab$f"))const char __rtmsym_##symbol##_name[] = "__vs_rtm_"#symbol;
S#pragma comment(linker, "/merge:RTMSymTab=mytext")
S
S#elif defined(__MINGW32__)
S#define RTM_EXPORT(symbol)
S
S#else
S#define RTM_EXPORT(symbol)                                            \
Sconst char __rtmsym_##symbol##_name[] SECTION(".rodata.name") = #symbol;     \
Sconst struct rt_module_symtab __rtmsym_##symbol SECTION("RTMSymTab")= \
S{                                                                     \
S    (void *)&symbol,                                                  \
S    __rtmsym_##symbol##_name                                          \
S};
X#define RTM_EXPORT(symbol)                                            const char __rtmsym_##symbol##_name[] SECTION(".rodata.name") = #symbol;     const struct rt_module_symtab __rtmsym_##symbol SECTION("RTMSymTab")= {                                                                         (void *)&symbol,                                                      __rtmsym_##symbol##_name                                          };
S#endif
S
N#else
N#define RTM_EXPORT(symbol)
N#endif
N
N#endif
L 39 "..\rt_thread\include\rtthread.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @addtogroup KernelObject
N */
N
N/*@{*/
N
N/*
N * kernel object interface
N */
Nvoid rt_system_object_init(void);
Nstruct rt_object_information *
Nrt_object_get_information(enum rt_object_class_type type);
Nvoid rt_object_init(struct rt_object         *object,
N                    enum rt_object_class_type type,
N                    const char               *name);
Nvoid rt_object_detach(rt_object_t object);
Nrt_object_t rt_object_allocate(enum rt_object_class_type type,
N                               const char               *name);
Nvoid rt_object_delete(rt_object_t object);
Nrt_bool_t rt_object_is_systemobject(rt_object_t object);
Nrt_object_t rt_object_find(const char *name, rt_uint8_t type);
N
N#ifdef RT_USING_HOOK
Nvoid rt_object_attach_sethook(void (*hook)(struct rt_object *object));
Nvoid rt_object_detach_sethook(void (*hook)(struct rt_object *object));
Nvoid rt_object_trytake_sethook(void (*hook)(struct rt_object *object));
Nvoid rt_object_take_sethook(void (*hook)(struct rt_object *object));
Nvoid rt_object_put_sethook(void (*hook)(struct rt_object *object));
N#endif
N
N/*@}*/
N
N/**
N * @addtogroup Clock
N */
N
N/*@{*/
N
N/*
N * clock & timer interface
N */
Nvoid rt_system_tick_init(void);
Nrt_tick_t rt_tick_get(void);
Nvoid rt_tick_set(rt_tick_t tick);
Nvoid rt_tick_increase(void);
Nrt_tick_t rt_tick_from_millisecond(rt_uint32_t ms);
N
Nvoid rt_system_timer_init(void);
Nvoid rt_system_timer_thread_init(void);
N
Nvoid rt_timer_init(rt_timer_t  timer,
N                   const char *name,
N                   void (*timeout)(void *parameter),
N                   void       *parameter,
N                   rt_tick_t   time,
N                   rt_uint8_t  flag);
Nrt_err_t rt_timer_detach(rt_timer_t timer);
Nrt_timer_t rt_timer_create(const char *name,
N                           void (*timeout)(void *parameter),
N                           void       *parameter,
N                           rt_tick_t   time,
N                           rt_uint8_t  flag);
Nrt_err_t rt_timer_delete(rt_timer_t timer);
Nrt_err_t rt_timer_start(rt_timer_t timer);
Nrt_err_t rt_timer_stop(rt_timer_t timer);
Nrt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg);
N
Nrt_tick_t rt_timer_next_timeout_tick(void);
Nvoid rt_timer_check(void);
N
N#ifdef RT_USING_HOOK
Nvoid rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer));
N#endif
N
N/*@}*/
N
N/**
N * @addtogroup Thread
N */
N
N/*@{*/
N
N/*
N * thread interface
N */
Nrt_err_t rt_thread_init(struct rt_thread *thread,
N                        const char       *name,
N                        void (*entry)(void *parameter),
N                        void             *parameter,
N                        void             *stack_start,
N                        rt_uint32_t       stack_size,
N                        rt_uint8_t        priority,
N                        rt_uint32_t       tick);
Nrt_err_t rt_thread_detach(rt_thread_t thread);
Nrt_thread_t rt_thread_create(const char *name,
N                             void (*entry)(void *parameter),
N                             void       *parameter,
N                             rt_uint32_t stack_size,
N                             rt_uint8_t  priority,
N                             rt_uint32_t tick);
Nrt_thread_t rt_thread_self(void);
Nrt_thread_t rt_thread_find(char *name);
Nrt_err_t rt_thread_startup(rt_thread_t thread);
Nrt_err_t rt_thread_delete(rt_thread_t thread);
N
Nrt_err_t rt_thread_yield(void);
Nrt_err_t rt_thread_delay(rt_tick_t tick);
Nrt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg);
Nrt_err_t rt_thread_suspend(rt_thread_t thread);
Nrt_err_t rt_thread_resume(rt_thread_t thread);
Nvoid rt_thread_timeout(void *parameter);
N
N/*
N * idle thread interface
N */
Nvoid rt_thread_idle_init(void);
N#ifdef RT_USING_HOOK
Nvoid rt_thread_idle_sethook(void (*hook)(void));
N#endif
Nvoid rt_thread_idle_excute(void);
N
N/*
N * schedule service
N */
Nvoid rt_system_scheduler_init(void);
Nvoid rt_system_scheduler_start(void);
N
Nvoid rt_schedule(void);
Nvoid rt_schedule_insert_thread(struct rt_thread *thread);
Nvoid rt_schedule_remove_thread(struct rt_thread *thread);
N
Nvoid rt_enter_critical(void);
Nvoid rt_exit_critical(void);
Nrt_uint16_t rt_critical_level(void);
N
N#ifdef RT_USING_HOOK
Nvoid rt_scheduler_sethook(void (*hook)(rt_thread_t from, rt_thread_t to));
N#endif
N
N/*@}*/
N
N/**
N * @addtogroup MM
N */
N
N/*@{*/
N
N/*
N * memory management interface
N */
N#ifdef RT_USING_MEMPOOL
N/*
N * memory pool interface
N */
Nrt_err_t rt_mp_init(struct rt_mempool *mp,
N                    const char        *name,
N                    void              *start,
N                    rt_size_t          size,
N                    rt_size_t          block_size);
Nrt_err_t rt_mp_detach(struct rt_mempool *mp);
Nrt_mp_t rt_mp_create(const char *name,
N                     rt_size_t   block_count,
N                     rt_size_t   block_size);
Nrt_err_t rt_mp_delete(rt_mp_t mp);
N
Nvoid *rt_mp_alloc(rt_mp_t mp, rt_int32_t time);
Nvoid rt_mp_free(void *block);
N
N#ifdef RT_USING_HOOK
Nvoid rt_mp_alloc_sethook(void (*hook)(struct rt_mempool *mp, void *block));
Nvoid rt_mp_free_sethook(void (*hook)(struct rt_mempool *mp, void *block));
N#endif
N
N#endif
N
N#ifdef RT_USING_HEAP
N/*
N * heap memory interface
N */
Nvoid rt_system_heap_init(void *begin_addr, void *end_addr);
N
Nvoid *rt_malloc(rt_size_t nbytes);
Nvoid rt_free(void *ptr);
Nvoid *rt_realloc(void *ptr, rt_size_t nbytes);
Nvoid *rt_calloc(rt_size_t count, rt_size_t size);
Nvoid *rt_malloc_align(rt_size_t size, rt_size_t align);
Nvoid rt_free_align(void *ptr);
N
Nvoid rt_memory_info(rt_uint32_t *total,
N                    rt_uint32_t *used,
N                    rt_uint32_t *max_used);
N
N#ifdef RT_USING_SLAB
Nvoid *rt_page_alloc(rt_size_t npages);
Nvoid rt_page_free(void *addr, rt_size_t npages);
N#endif
N
N#ifdef RT_USING_HOOK
Nvoid rt_malloc_sethook(void (*hook)(void *ptr, rt_uint32_t size));
Nvoid rt_free_sethook(void (*hook)(void *ptr));
N#endif
N
N#endif
N
N#ifdef RT_USING_MEMHEAP
S/**
S * memory heap object interface
S */
Srt_err_t rt_memheap_init(struct rt_memheap *memheap,
S                         const char        *name,
S                         void              *start_addr,
S                         rt_uint32_t        size);
Srt_err_t rt_memheap_detach(struct rt_memheap *heap);
Svoid* rt_memheap_alloc(struct rt_memheap *heap, rt_uint32_t size);
Svoid *rt_memheap_realloc(struct rt_memheap* heap, void* ptr, rt_size_t newsize);
Svoid rt_memheap_free(void *ptr);
N#endif
N
N/*@}*/
N
N/**
N * @addtogroup IPC
N */
N
N/*@{*/
N
N#ifdef RT_USING_SEMAPHORE
N/*
N * semaphore interface
N */
Nrt_err_t rt_sem_init(rt_sem_t    sem,
N                     const char *name,
N                     rt_uint32_t value,
N                     rt_uint8_t  flag);
Nrt_err_t rt_sem_detach(rt_sem_t sem);
Nrt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);
Nrt_err_t rt_sem_delete(rt_sem_t sem);
N
Nrt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time);
Nrt_err_t rt_sem_trytake(rt_sem_t sem);
Nrt_err_t rt_sem_release(rt_sem_t sem);
Nrt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_MUTEX
N/*
N * mutex interface
N */
Nrt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag);
Nrt_err_t rt_mutex_detach(rt_mutex_t mutex);
Nrt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);
Nrt_err_t rt_mutex_delete(rt_mutex_t mutex);
N
Nrt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time);
Nrt_err_t rt_mutex_release(rt_mutex_t mutex);
Nrt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_EVENT
N/*
N * event interface
N */
Nrt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag);
Nrt_err_t rt_event_detach(rt_event_t event);
Nrt_event_t rt_event_create(const char *name, rt_uint8_t flag);
Nrt_err_t rt_event_delete(rt_event_t event);
N
Nrt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);
Nrt_err_t rt_event_recv(rt_event_t   event,
N                       rt_uint32_t  set,
N                       rt_uint8_t   opt,
N                       rt_int32_t   timeout,
N                       rt_uint32_t *recved);
Nrt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_MAILBOX
N/*
N * mailbox interface
N */
Nrt_err_t rt_mb_init(rt_mailbox_t mb,
N                    const char  *name,
N                    void        *msgpool,
N                    rt_size_t    size,
N                    rt_uint8_t   flag);
Nrt_err_t rt_mb_detach(rt_mailbox_t mb);
Nrt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag);
Nrt_err_t rt_mb_delete(rt_mailbox_t mb);
N
Nrt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value);
Nrt_err_t rt_mb_send_wait(rt_mailbox_t mb,
N                         rt_uint32_t  value,
N                         rt_int32_t   timeout);
Nrt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout);
Nrt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_MESSAGEQUEUE
N/*
N * message queue interface
N */
Nrt_err_t rt_mq_init(rt_mq_t     mq,
N                    const char *name,
N                    void       *msgpool,
N                    rt_size_t   msg_size,
N                    rt_size_t   pool_size,
N                    rt_uint8_t  flag);
Nrt_err_t rt_mq_detach(rt_mq_t mq);
Nrt_mq_t rt_mq_create(const char *name,
N                     rt_size_t   msg_size,
N                     rt_size_t   max_msgs,
N                     rt_uint8_t  flag);
Nrt_err_t rt_mq_delete(rt_mq_t mq);
N
Nrt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size);
Nrt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size);
Nrt_err_t rt_mq_recv(rt_mq_t    mq,
N                    void      *buffer,
N                    rt_size_t  size,
N                    rt_int32_t timeout);
Nrt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg);
N#endif
N
N/*@}*/
N
N#ifdef RT_USING_DEVICE
N/**
N * @addtogroup Device
N */
N
N/*@{*/
N
N/*
N * device (I/O) system interface
N */
Nrt_device_t rt_device_find(const char *name);
N
Nrt_err_t rt_device_register(rt_device_t dev,
N                            const char *name,
N                            rt_uint16_t flags);
Nrt_err_t rt_device_unregister(rt_device_t dev);
Nrt_err_t rt_device_init_all(void);
N
Nrt_err_t
Nrt_device_set_rx_indicate(rt_device_t dev,
N                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size));
Nrt_err_t
Nrt_device_set_tx_complete(rt_device_t dev,
N                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer));
N
Nrt_err_t  rt_device_init (rt_device_t dev);
Nrt_err_t  rt_device_open (rt_device_t dev, rt_uint16_t oflag);
Nrt_err_t  rt_device_close(rt_device_t dev);
Nrt_size_t rt_device_read (rt_device_t dev,
N                          rt_off_t    pos,
N                          void       *buffer,
N                          rt_size_t   size);
Nrt_size_t rt_device_write(rt_device_t dev,
N                          rt_off_t    pos,
N                          const void *buffer,
N                          rt_size_t   size);
Nrt_err_t  rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg);
N
N/*@}*/
N#endif
N
N#ifdef RT_USING_MODULE
S/**
S * @addtogroup Module
S */
S
S/*@{*/
S
S/*
S * module interface
S */
Srt_module_t rt_module_load(const char *name, void *module_ptr);
Srt_err_t rt_module_unload(rt_module_t module);
S#ifdef RT_USING_DFS
Srt_module_t rt_module_open(const char *filename);
Srt_module_t rt_module_exec_cmd(const char *path, const char* cmd_line, int size);
S#endif
Svoid *rt_module_malloc(rt_size_t size);
Svoid *rt_module_realloc(void *ptr, rt_size_t size);
Svoid rt_module_free(rt_module_t module, void *addr);
Srt_module_t rt_module_self(void);
Srt_module_t rt_module_find(const char *name);
S
S#ifdef RT_USING_HOOK
Svoid rt_module_load_sethook(void (*hook)(rt_module_t module));
Svoid rt_module_unload_sethook(void (*hook)(rt_module_t module));
S#endif
S
Svoid rt_module_init_object_container(struct rt_module *module);
Srt_err_t rt_module_destroy(rt_module_t module);
S
S/*
S * application module system initialization
S */
Sint rt_system_module_init(void);
S
S/*@}*/
N#endif
N
N/*
N * interrupt service
N */
N
N/*
N * rt_interrupt_enter and rt_interrupt_leave only can be called by BSP
N */
Nvoid rt_interrupt_enter(void);
Nvoid rt_interrupt_leave(void);
N
N/*
N * the number of nested interrupts.
N */
Nrt_uint8_t rt_interrupt_get_nest(void);
N
N#ifdef RT_USING_COMPONENTS_INIT
Nvoid rt_components_init(void);
Nvoid rt_components_board_init(void);
N#endif
N
N/**
N * @addtogroup KernelService
N */
N
N/*@{*/
N
N/*
N * general kernel service
N */
N#ifndef RT_USING_CONSOLE
S#define rt_kprintf(...)
N#else
Nvoid rt_kprintf(const char *fmt, ...);
N#endif
Nrt_int32_t rt_vsprintf(char *dest, const char *format, va_list arg_ptr);
Nrt_int32_t rt_vsnprintf(char *buf, rt_size_t size, const char *fmt, va_list args);
Nrt_int32_t rt_sprintf(char *buf ,const char *format, ...);
Nrt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *format, ...);
N
N#if defined(RT_USING_DEVICE) && defined(RT_USING_CONSOLE)
X#if 1L && 1L
Nrt_device_t rt_console_set_device(const char *name);
Nrt_device_t rt_console_get_device(void);
N#endif
N
Nrt_err_t rt_get_errno(void);
Nvoid rt_set_errno(rt_err_t no);
Nint *_rt_errno(void);
N#ifndef RT_USING_NEWLIB
N#ifndef errno
N#define errno    *_rt_errno()
N#endif
N#endif
N
Nvoid *rt_memset(void *src, int c, rt_ubase_t n);
Nvoid *rt_memcpy(void *dest, const void *src, rt_ubase_t n);
N
Nrt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count);
Nrt_int32_t rt_strcmp (const char *cs, const char *ct);
Nrt_size_t rt_strlen (const char *src);
Nchar *rt_strdup(const char *s);
N
Nchar *rt_strstr(const char *str1, const char *str2);
Nrt_int32_t rt_sscanf(const char *buf, const char *fmt, ...);
Nchar *rt_strncpy(char *dest, const char *src, rt_ubase_t n);
Nvoid *rt_memmove(void *dest, const void *src, rt_ubase_t n);
Nrt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count);
Nrt_uint32_t rt_strcasecmp(const char *a, const char *b);
N
Nvoid rt_show_version(void);
N
N#ifdef RT_DEBUG
Nextern void (*rt_assert_hook)(const char* ex, const char* func, rt_size_t line);
Nvoid rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line));
N
Nvoid rt_assert_handler(const char* ex, const char* func, rt_size_t line);
N#endif /* RT_DEBUG */
N
N/*@}*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 32 "..\rt_thread\include\rthw.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*
N * CPU interfaces
N */
Nvoid rt_hw_cpu_icache_enable(void);
Nvoid rt_hw_cpu_icache_disable(void);
Nrt_base_t rt_hw_cpu_icache_status(void);
Nvoid rt_hw_cpu_dcache_enable(void);
Nvoid rt_hw_cpu_dcache_disable(void);
Nrt_base_t rt_hw_cpu_dcache_status(void);
Nvoid rt_hw_cpu_reset(void);
Nvoid rt_hw_cpu_shutdown(void);
N
Nrt_uint8_t *rt_hw_stack_init(void       *entry,
N                             void       *parameter,
N                             rt_uint8_t *stack_addr,
N                             void       *exit);
N
N/*
N * Interrupt handler definition
N */
Ntypedef void (*rt_isr_handler_t)(int vector, void *param);
N
Nstruct rt_irq_desc
N{
N    rt_isr_handler_t handler;
N    void            *param;
N
N#ifdef RT_USING_INTERRUPT_INFO
N    char             name[RT_NAME_MAX];
X    char             name[8];
N    rt_uint32_t      counter;
N#endif
N};
N
N/*
N * Interrupt interfaces
N */
Nvoid rt_hw_interrupt_init(void);
Nvoid rt_hw_interrupt_mask(int vector);
Nvoid rt_hw_interrupt_umask(int vector);
Nrt_isr_handler_t rt_hw_interrupt_install(int              vector,
N                                         rt_isr_handler_t handler,
N                                         void            *param,
N                                         char            *name);
N
Nrt_base_t rt_hw_interrupt_disable(void);
Nvoid rt_hw_interrupt_enable(rt_base_t level);
N
N/*
N * Context interfaces
N */
Nvoid rt_hw_context_switch(rt_uint32_t from, rt_uint32_t to);
Nvoid rt_hw_context_switch_to(rt_uint32_t to);
Nvoid rt_hw_context_switch_interrupt(rt_uint32_t from, rt_uint32_t to);
N
Nvoid rt_hw_console_output(const char *str);
N
Nvoid rt_hw_backtrace(rt_uint32_t *fp, rt_uint32_t thread_entry);
Nvoid rt_hw_show_memory(rt_uint32_t addr, rt_uint32_t size);
N
N/*
N * Exception interfaces
N */
Nvoid rt_hw_exception_install(rt_err_t (*exception_handle)(void *context));
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 33 "..\rt_thread\kernel\module.c" 2
N#include <rtthread.h>
N#include <rtm.h>
N
N#ifdef RT_USING_FINSH
S#include <finsh.h>
N#endif
N
N#ifdef RT_USING_MODULE
S#include "module.h"
S
S#define elf_module        ((Elf32_Ehdr *)module_ptr)
S#define shdr              ((Elf32_Shdr *)((rt_uint8_t *)module_ptr + elf_module->e_shoff))
S#define phdr              ((Elf32_Phdr *)((rt_uint8_t *)module_ptr + elf_module->e_phoff))
S
S#define IS_PROG(s)        (s.sh_type == SHT_PROGBITS)
S#define IS_NOPROG(s)      (s.sh_type == SHT_NOBITS)
S#define IS_REL(s)         (s.sh_type == SHT_REL)
S#define IS_RELA(s)        (s.sh_type == SHT_RELA)
S#define IS_ALLOC(s)       (s.sh_flags == SHF_ALLOC)
S#define IS_AX(s)          ((s.sh_flags & SHF_ALLOC) && (s.sh_flags & SHF_EXECINSTR))
S#define IS_AW(s)          ((s.sh_flags & SHF_ALLOC) && (s.sh_flags & SHF_WRITE))
S
S#ifdef RT_USING_MODULE_STKSZ
S#undef RT_USING_MODULE_STKSZ
S#endif
S
S#ifndef RT_USING_MODULE_STKSZ
S#define RT_USING_MODULE_STKSZ (4096 * 2)
S#endif
S
S#ifndef RT_USING_MODULE_PRIO
S#define RT_USING_MODULE_PRIO (RT_THREAD_PRIORITY_MAX - 2)
S#endif
S
S#ifdef RT_USING_SLAB
S#define PAGE_COUNT_MAX    256
S
S/* module memory allocator */
Sstruct rt_mem_head
S{
S    rt_size_t size;                /* size of memory block */
S    struct rt_mem_head *next;      /* next valid memory block */
S};
S
Sstruct rt_page_info
S{
S    rt_uint32_t *page_ptr;
S    rt_uint32_t npage;
S};
S
Sstatic void *rt_module_malloc_page(rt_size_t npages);
Sstatic void rt_module_free_page(rt_module_t module,
S                                void       *page_ptr,
S                                rt_size_t   npages);
S
Sstatic struct rt_semaphore mod_sem;
S#endif
S
Sstatic struct rt_module_symtab *_rt_module_symtab_begin = RT_NULL;
Sstatic struct rt_module_symtab *_rt_module_symtab_end   = RT_NULL;
S
S#if defined(__IAR_SYSTEMS_ICC__) /* for IAR compiler */
S    #pragma section="RTMSymTab"
S#endif
S
S/**
S * @ingroup SystemInit
S *
S * This function will initialize system module
S */
Sint rt_system_module_init(void)
S{
S#if defined(__GNUC__) && !defined(__CC_ARM)
S    extern int __rtmsymtab_start;
S    extern int __rtmsymtab_end;
S
S    _rt_module_symtab_begin = (struct rt_module_symtab *)&__rtmsymtab_start;
S    _rt_module_symtab_end   = (struct rt_module_symtab *)&__rtmsymtab_end;
S#elif defined (__CC_ARM)
S    extern int RTMSymTab$$Base;
S    extern int RTMSymTab$$Limit;
S
S    _rt_module_symtab_begin = (struct rt_module_symtab *)&RTMSymTab$$Base;
S    _rt_module_symtab_end   = (struct rt_module_symtab *)&RTMSymTab$$Limit;
S#elif defined (__IAR_SYSTEMS_ICC__)
S    _rt_module_symtab_begin = __section_begin("RTMSymTab");
S    _rt_module_symtab_end   = __section_begin("RTMSymTab");
S#endif
S
S#ifdef RT_USING_SLAB
S    /* initialize heap semaphore */
S    rt_sem_init(&mod_sem, "module", 1, RT_IPC_FLAG_FIFO);
S#endif
S    return 0;
S}
SINIT_COMPONENT_EXPORT(rt_system_module_init);
S
S#ifdef RT_USING_FINSH
Svoid list_symbol(void)
S{
S    /* find in kernel symbol table */
S    struct rt_module_symtab *index;
S
S    for (index = _rt_module_symtab_begin;
S         index != _rt_module_symtab_end;
S         index ++)
S    {
S    	rt_kprintf("%s\n", index->name);
S    }
S
S    return ;
S}
SFINSH_FUNCTION_EXPORT(list_symbol, list symbol for module);
SMSH_CMD_EXPORT(list_symbol, list symbol for module);
S#endif
S
Sstatic rt_uint32_t rt_module_symbol_find(const char *sym_str)
S{
S    /* find in kernel symbol table */
S    struct rt_module_symtab *index;
S
S    for (index = _rt_module_symtab_begin;
S         index != _rt_module_symtab_end;
S         index ++)
S    {
S        if (rt_strcmp(index->name, sym_str) == 0)
S            return (rt_uint32_t)index->addr;
S    }
S
S    return 0;
S}
S
S/**
S * This function will return self module object
S *
S * @return the self module object
S */
Srt_module_t rt_module_self(void)
S{
S    rt_thread_t tid;
S
S    tid = rt_thread_self();
S    if (tid == RT_NULL)
S        return RT_NULL;
S
S    /* return current module */
S    return (rt_module_t)tid->module_id;
S}
SRTM_EXPORT(rt_module_self);
S
Sstatic int rt_module_arm_relocate(struct rt_module *module,
S                                  Elf32_Rel        *rel,
S                                  Elf32_Addr        sym_val)
S{
S    Elf32_Addr *where, tmp;
S    Elf32_Sword addend, offset;
S    rt_uint32_t upper, lower, sign, j1, j2;
S
S    where = (Elf32_Addr *)((rt_uint8_t *)module->module_space
S                           + rel->r_offset
S                           - module->vstart_addr);
S    switch (ELF32_R_TYPE(rel->r_info))
S    {
S    case R_ARM_NONE:
S        break;
S    case R_ARM_ABS32:
S        *where += (Elf32_Addr)sym_val;
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("R_ARM_ABS32: %x -> %x\n",
S                                       where, *where));
S        break;
S    case R_ARM_PC24:
S    case R_ARM_PLT32:
S    case R_ARM_CALL:
S    case R_ARM_JUMP24:
S        addend = *where & 0x00ffffff;
S        if (addend & 0x00800000)
S            addend |= 0xff000000;
S        tmp = sym_val - (Elf32_Addr)where + (addend << 2);
S        tmp >>= 2;
S        *where = (*where & 0xff000000) | (tmp & 0x00ffffff);
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("R_ARM_PC24: %x -> %x\n",
S                                       where, *where));
S        break;
S    case R_ARM_REL32:
S        *where += sym_val - (Elf32_Addr)where;
S        RT_DEBUG_LOG(RT_DEBUG_MODULE,
S                     ("R_ARM_REL32: %x -> %x, sym %x, offset %x\n",
S                      where, *where, sym_val, rel->r_offset));
S        break;
S    case R_ARM_V4BX:
S        *where &= 0xf000000f;
S        *where |= 0x01a0f000;
S        break;
S    case R_ARM_GLOB_DAT:
S    case R_ARM_JUMP_SLOT:
S        *where = (Elf32_Addr)sym_val;
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("R_ARM_JUMP_SLOT: 0x%x -> 0x%x 0x%x\n",
S                                       where, *where, sym_val));
S        break;
S#if 0        /* To do */
S    case R_ARM_GOT_BREL:
S        temp   = (Elf32_Addr)sym_val;
S        *where = (Elf32_Addr)&temp;
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("R_ARM_GOT_BREL: 0x%x -> 0x%x 0x%x\n",
S                                       where, *where, sym_val));
S        break;
S#endif
S    case R_ARM_RELATIVE:
S        *where = (Elf32_Addr)sym_val + *where;
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("R_ARM_RELATIVE: 0x%x -> 0x%x 0x%x\n",
S                                       where, *where, sym_val));
S        break;
S    case R_ARM_THM_CALL:
S    case R_ARM_THM_JUMP24:
S        upper  = *(rt_uint16_t *)where;
S        lower  = *(rt_uint16_t *)((Elf32_Addr)where + 2);
S
S        sign   = (upper >> 10) & 1;
S        j1     = (lower >> 13) & 1;
S        j2     = (lower >> 11) & 1;
S        offset = (sign << 24) |
S            ((~(j1 ^ sign) & 1) << 23) |
S            ((~(j2 ^ sign) & 1) << 22) |
S            ((upper & 0x03ff) << 12) |
S            ((lower & 0x07ff) << 1);
S        if (offset & 0x01000000)
S            offset -= 0x02000000;
S        offset += sym_val - (Elf32_Addr)where;
S
S        if (!(offset & 1) ||
S            offset <= (rt_int32_t)0xff000000 ||
S            offset >= (rt_int32_t)0x01000000)
S        {
S            rt_kprintf("Module: Only Thumb addresses allowed\n");
S
S            return -1;
S        }
S
S        sign = (offset >> 24) & 1;
S        j1   = sign ^ (~(offset >> 23) & 1);
S        j2   = sign ^ (~(offset >> 22) & 1);
S        *(rt_uint16_t *)where = (rt_uint16_t)((upper & 0xf800) |
S                                              (sign << 10) |
S                                              ((offset >> 12) & 0x03ff));
S        *(rt_uint16_t *)(where + 2) = (rt_uint16_t)((lower & 0xd000) |
S                                                    (j1 << 13) | (j2 << 11) |
S                                                    ((offset >> 1) & 0x07ff));
S        upper = *(rt_uint16_t *)where;
S        lower = *(rt_uint16_t *)((Elf32_Addr)where + 2);
S        break;
S    default:
S        return -1;
S    }
S
S    return 0;
S}
S
Svoid rt_module_init_object_container(struct rt_module *module)
S{
S    RT_ASSERT(module != RT_NULL);
S
S    /* initialize object container - thread */
S    rt_list_init(&(module->module_object[RT_Object_Class_Thread].object_list));
S    module->module_object[RT_Object_Class_Thread].object_size = sizeof(struct rt_thread);
S    module->module_object[RT_Object_Class_Thread].type = RT_Object_Class_Thread;
S
S#ifdef RT_USING_SEMAPHORE
S    /* initialize object container - semaphore */
S    rt_list_init(&(module->module_object[RT_Object_Class_Semaphore].object_list));
S    module->module_object[RT_Object_Class_Semaphore].object_size = sizeof(struct rt_semaphore);
S    module->module_object[RT_Object_Class_Semaphore].type = RT_Object_Class_Semaphore;
S#endif
S
S#ifdef RT_USING_MUTEX
S    /* initialize object container - mutex */
S    rt_list_init(&(module->module_object[RT_Object_Class_Mutex].object_list));
S    module->module_object[RT_Object_Class_Mutex].object_size = sizeof(struct rt_mutex);
S    module->module_object[RT_Object_Class_Mutex].type = RT_Object_Class_Mutex;
S#endif
S
S#ifdef RT_USING_EVENT
S    /* initialize object container - event */
S    rt_list_init(&(module->module_object[RT_Object_Class_Event].object_list));
S    module->module_object[RT_Object_Class_Event].object_size = sizeof(struct rt_event);
S    module->module_object[RT_Object_Class_Event].type = RT_Object_Class_Event;
S#endif
S
S#ifdef RT_USING_MAILBOX
S    /* initialize object container - mailbox */
S    rt_list_init(&(module->module_object[RT_Object_Class_MailBox].object_list));
S    module->module_object[RT_Object_Class_MailBox].object_size = sizeof(struct rt_mailbox);
S    module->module_object[RT_Object_Class_MailBox].type = RT_Object_Class_MailBox;
S#endif
S
S#ifdef RT_USING_MESSAGEQUEUE
S    /* initialize object container - message queue */
S    rt_list_init(&(module->module_object[RT_Object_Class_MessageQueue].object_list));
S    module->module_object[RT_Object_Class_MessageQueue].object_size = sizeof(struct rt_messagequeue);
S    module->module_object[RT_Object_Class_MessageQueue].type = RT_Object_Class_MessageQueue;
S#endif
S
S#ifdef RT_USING_MEMHEAP
S    /* initialize object container - memory heap */
S    rt_list_init(&(module->module_object[RT_Object_Class_MemHeap].object_list));
S    module->module_object[RT_Object_Class_MemHeap].object_size = sizeof(struct rt_memheap);
S    module->module_object[RT_Object_Class_MemHeap].type = RT_Object_Class_MemHeap;
S#endif
S
S#ifdef RT_USING_MEMPOOL
S    /* initialize object container - memory pool */
S    rt_list_init(&(module->module_object[RT_Object_Class_MemPool].object_list));
S    module->module_object[RT_Object_Class_MemPool].object_size = sizeof(struct rt_mempool);
S    module->module_object[RT_Object_Class_MemPool].type = RT_Object_Class_MemPool;
S#endif
S
S#ifdef RT_USING_DEVICE
S    /* initialize object container - device */
S    rt_list_init(&(module->module_object[RT_Object_Class_Device].object_list));
S    module->module_object[RT_Object_Class_Device].object_size = sizeof(struct rt_device);
S    module->module_object[RT_Object_Class_Device].type = RT_Object_Class_Device;
S#endif
S
S    /* initialize object container - timer */
S    rt_list_init(&(module->module_object[RT_Object_Class_Timer].object_list));
S    module->module_object[RT_Object_Class_Timer].object_size = sizeof(struct rt_timer);
S    module->module_object[RT_Object_Class_Timer].type = RT_Object_Class_Timer;
S}
S
S#ifdef RT_USING_HOOK
Sstatic void (*rt_module_load_hook)(rt_module_t module);
Sstatic void (*rt_module_unload_hook)(rt_module_t module);
S
S/**
S * @addtogroup Hook
S */
S
S/*@{*/
S
S/**
S * This function will set a hook function, which will be invoked when module
S * be loaded to system.
S *
S * @param hook the hook function
S */
Svoid rt_module_load_sethook(void (*hook)(rt_module_t module))
S{
S    rt_module_load_hook = hook;
S}
S
S/**
S * This function will set a hook function, which will be invoked when module
S * be unloaded from system.
S *
S * @param hook the hook function
S */
Svoid rt_module_unload_sethook(void (*hook)(rt_module_t module))
S{
S    rt_module_unload_hook = hook;
S}
S
S/*@}*/
S#endif
S
Sstatic struct rt_module *_load_shared_object(const char *name,
S                                             void       *module_ptr)
S{
S    rt_module_t module = RT_NULL;
S    rt_bool_t linked   = RT_FALSE;
S    rt_uint32_t index, module_size = 0;
S    Elf32_Addr vstart_addr, vend_addr;
S    rt_bool_t has_vstart;
S
S    RT_ASSERT(module_ptr != RT_NULL);
S
S    if (rt_memcmp(elf_module->e_ident, RTMMAG, SELFMAG) == 0)
S    {
S        /* rtmlinker finished */
S        linked = RT_TRUE;
S    }
S
S    /* get the ELF image size */
S    has_vstart = RT_FALSE;
S    vstart_addr = vend_addr = RT_NULL;
S    for (index = 0; index < elf_module->e_phnum; index++)
S    {
S        if (phdr[index].p_type != PT_LOAD)
S            continue;
S
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("LOAD segment: %d, 0x%p, 0x%08x\n",
S                                       index, phdr[index].p_vaddr, phdr[index].p_memsz));
S
S        if (phdr[index].p_memsz < phdr[index].p_filesz)
S        {
S            rt_kprintf("invalid elf: segment %d: p_memsz: %d, p_filesz: %d\n",
S                       index, phdr[index].p_memsz, phdr[index].p_filesz);
S            return RT_NULL;
S        }
S        if (!has_vstart)
S        {
S            vstart_addr = phdr[index].p_vaddr;
S            vend_addr = phdr[index].p_vaddr + phdr[index].p_memsz;
S            has_vstart = RT_TRUE;
S            if (vend_addr < vstart_addr)
S            {
S                rt_kprintf("invalid elf: segment %d: p_vaddr: %d, p_memsz: %d\n",
S                           index, phdr[index].p_vaddr, phdr[index].p_memsz);
S                return RT_NULL;
S            }
S        }
S        else
S        {
S            if (phdr[index].p_vaddr < vend_addr)
S            {
S                rt_kprintf("invalid elf: segment should be sorted and not overlapped\n");
S                return RT_NULL;
S            }
S            if (phdr[index].p_vaddr > vend_addr + 16)
S            {
S                /* There should not be too much padding in the object files. */
S                rt_kprintf("warning: too much padding before segment %d\n", index);
S            }
S
S            vend_addr = phdr[index].p_vaddr + phdr[index].p_memsz;
S            if (vend_addr < phdr[index].p_vaddr)
S            {
S                rt_kprintf("invalid elf: "
S                           "segment %d address overflow\n", index);
S                return RT_NULL;
S            }
S        }
S    }
S
S    module_size = vend_addr - vstart_addr;
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("module size: %d, vstart_addr: 0x%p\n",
S                                   module_size, vstart_addr));
S
S    if (module_size == 0)
S    {
S        rt_kprintf("Module: size error\n");
S
S        return RT_NULL;
S    }
S
S    /* allocate module */
S    module = (struct rt_module *)rt_object_allocate(RT_Object_Class_Module,
S                                                    name);
S    if (!module)
S        return RT_NULL;
S
S    module->vstart_addr = vstart_addr;
S
S    module->nref = 0;
S
S    /* allocate module space */
S    module->module_space = rt_malloc(module_size);
S    if (module->module_space == RT_NULL)
S    {
S        rt_kprintf("Module: allocate space failed.\n");
S        rt_object_delete(&(module->parent));
S
S        return RT_NULL;
S    }
S
S    /* zero all space */
S    rt_memset(module->module_space, 0, module_size);
S
S    for (index = 0; index < elf_module->e_phnum; index++)
S    {
S        if (phdr[index].p_type == PT_LOAD)
S        {
S            rt_memcpy(module->module_space + phdr[index].p_vaddr - vstart_addr,
S                      (rt_uint8_t *)elf_module + phdr[index].p_offset,
S                      phdr[index].p_filesz);
S        }
S    }
S
S    /* set module entry */
S    module->module_entry = module->module_space
S        + elf_module->e_entry - vstart_addr;
S
S    /* handle relocation section */
S    for (index = 0; index < elf_module->e_shnum; index ++)
S    {
S        rt_uint32_t i, nr_reloc;
S        Elf32_Sym *symtab;
S        Elf32_Rel *rel;
S        rt_uint8_t *strtab;
S        static rt_bool_t unsolved = RT_FALSE;
S
S        if (!IS_REL(shdr[index]))
S            continue;
S
S        /* get relocate item */
S        rel = (Elf32_Rel *)((rt_uint8_t *)module_ptr + shdr[index].sh_offset);
S
S        /* locate .rel.plt and .rel.dyn section */
S        symtab = (Elf32_Sym *)((rt_uint8_t *)module_ptr +
S                               shdr[shdr[index].sh_link].sh_offset);
S        strtab = (rt_uint8_t *)module_ptr +
S            shdr[shdr[shdr[index].sh_link].sh_link].sh_offset;
S        nr_reloc = (rt_uint32_t)(shdr[index].sh_size / sizeof(Elf32_Rel));
S
S        /* relocate every items */
S        for (i = 0; i < nr_reloc; i ++)
S        {
S            Elf32_Sym *sym = &symtab[ELF32_R_SYM(rel->r_info)];
S
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("relocate symbol %s shndx %d\n",
S                                           strtab + sym->st_name,
S                                           sym->st_shndx));
S
S            if ((sym->st_shndx != SHT_NULL) ||
S                (ELF_ST_BIND(sym->st_info) == STB_LOCAL))
S            {
S                rt_module_arm_relocate(module, rel,
S                                       (Elf32_Addr)(module->module_space
S                                                    + sym->st_value
S                                                    - vstart_addr));
S            }
S            else if (!linked)
S            {
S                Elf32_Addr addr;
S
S                RT_DEBUG_LOG(RT_DEBUG_MODULE, ("relocate symbol: %s\n",
S                                               strtab + sym->st_name));
S
S                /* need to resolve symbol in kernel symbol table */
S                addr = rt_module_symbol_find((const char *)(strtab + sym->st_name));
S                if (addr == 0)
S                {
S                    rt_kprintf("Module: can't find %s in kernel symbol table\n",
S                               strtab + sym->st_name);
S                    unsolved = RT_TRUE;
S                }
S                else
S                    rt_module_arm_relocate(module, rel, addr);
S            }
S            rel ++;
S        }
S
S        if (unsolved)
S        {
S            rt_object_delete(&(module->parent));
S
S            return RT_NULL;
S        }
S    }
S
S    /* construct module symbol table */
S    for (index = 0; index < elf_module->e_shnum; index ++)
S    {
S        /* find .dynsym section */
S        rt_uint8_t *shstrab;
S        shstrab = (rt_uint8_t *)module_ptr +
S            shdr[elf_module->e_shstrndx].sh_offset;
S        if (rt_strcmp((const char *)(shstrab + shdr[index].sh_name), ELF_DYNSYM) == 0)
S            break;
S    }
S
S    /* found .dynsym section */
S    if (index != elf_module->e_shnum)
S    {
S        int i, count = 0;
S        Elf32_Sym  *symtab = RT_NULL;
S        rt_uint8_t *strtab = RT_NULL;
S
S        symtab =(Elf32_Sym *)((rt_uint8_t *)module_ptr + shdr[index].sh_offset);
S        strtab = (rt_uint8_t *)module_ptr + shdr[shdr[index].sh_link].sh_offset;
S
S        for (i = 0; i < shdr[index].sh_size/sizeof(Elf32_Sym); i++)
S        {
S            if ((ELF_ST_BIND(symtab[i].st_info) == STB_GLOBAL) &&
S                (ELF_ST_TYPE(symtab[i].st_info) == STT_FUNC))
S                count ++;
S        }
S
S        module->symtab = (struct rt_module_symtab *)rt_malloc
S            (count * sizeof(struct rt_module_symtab));
S        module->nsym = count;
S        for (i = 0, count = 0; i < shdr[index].sh_size/sizeof(Elf32_Sym); i++)
S        {
S            rt_size_t length;
S
S            if ((ELF_ST_BIND(symtab[i].st_info) != STB_GLOBAL) ||
S                (ELF_ST_TYPE(symtab[i].st_info) != STT_FUNC))
S                continue;
S
S            length = rt_strlen((const char *)(strtab + symtab[i].st_name)) + 1;
S
S            module->symtab[count].addr =
S                (void *)(module->module_space + symtab[i].st_value);
S            module->symtab[count].name = rt_malloc(length);
S            rt_memset((void *)module->symtab[count].name, 0, length);
S            rt_memcpy((void *)module->symtab[count].name,
S                      strtab + symtab[i].st_name,
S                      length);
S            count ++;
S        }
S    }
S
S    return module;
S}
S
Sstatic struct rt_module* _load_relocated_object(const char *name,
S                                                void       *module_ptr)
S{
S    rt_uint32_t index, rodata_addr = 0, bss_addr = 0, data_addr = 0;
S    rt_uint32_t module_addr = 0, module_size = 0;
S    struct rt_module *module = RT_NULL;
S    rt_uint8_t *ptr, *strtab, *shstrab;
S
S    /* get the ELF image size */
S    for (index = 0; index < elf_module->e_shnum; index ++)
S    {
S        /* text */
S        if (IS_PROG(shdr[index]) && IS_AX(shdr[index]))
S        {
S            module_size += shdr[index].sh_size;
S            module_addr = shdr[index].sh_addr;
S        }
S        /* rodata */
S        if (IS_PROG(shdr[index]) && IS_ALLOC(shdr[index]))
S        {
S            module_size += shdr[index].sh_size;
S        }
S        /* data */
S        if (IS_PROG(shdr[index]) && IS_AW(shdr[index]))
S        {
S            module_size += shdr[index].sh_size;
S        }
S        /* bss */
S        if (IS_NOPROG(shdr[index]) && IS_AW(shdr[index]))
S        {
S            module_size += shdr[index].sh_size;
S        }
S    }
S
S    /* no text, data and bss on image */
S    if (module_size == 0)
S        return RT_NULL;
S
S    /* allocate module */
S    module = (struct rt_module *)
S        rt_object_allocate(RT_Object_Class_Module, (const char *)name);
S    if (module == RT_NULL)
S        return RT_NULL;
S
S    module->vstart_addr = 0;
S
S    /* allocate module space */
S    module->module_space = rt_malloc(module_size);
S    if (module->module_space == RT_NULL)
S    {
S        rt_kprintf("Module: allocate space failed.\n");
S        rt_object_delete(&(module->parent));
S
S        return RT_NULL;
S    }
S
S    /* zero all space */
S    ptr = module->module_space;
S    rt_memset(ptr, 0, module_size);
S
S    /* load text and data section */
S    for (index = 0; index < elf_module->e_shnum; index ++)
S    {
S        /* load text section */
S        if (IS_PROG(shdr[index]) && IS_AX(shdr[index]))
S        {
S            rt_memcpy(ptr,
S                      (rt_uint8_t *)elf_module + shdr[index].sh_offset,
S                      shdr[index].sh_size);
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("load text 0x%x, size %d\n",
S                                           ptr, shdr[index].sh_size));
S            ptr += shdr[index].sh_size;
S        }
S
S        /* load rodata section */
S        if (IS_PROG(shdr[index]) && IS_ALLOC(shdr[index]))
S        {
S            rt_memcpy(ptr,
S                      (rt_uint8_t *)elf_module + shdr[index].sh_offset,
S                      shdr[index].sh_size);
S            rodata_addr = (rt_uint32_t)ptr;
S            RT_DEBUG_LOG(RT_DEBUG_MODULE,
S                         ("load rodata 0x%x, size %d, rodata 0x%x\n",
S                          ptr, shdr[index].sh_size, *(rt_uint32_t *)data_addr));
S            ptr += shdr[index].sh_size;
S        }
S
S        /* load data section */
S        if (IS_PROG(shdr[index]) && IS_AW(shdr[index]))
S        {
S            rt_memcpy(ptr,
S                      (rt_uint8_t *)elf_module + shdr[index].sh_offset,
S                      shdr[index].sh_size);
S            data_addr = (rt_uint32_t)ptr;
S            RT_DEBUG_LOG(RT_DEBUG_MODULE,
S                         ("load data 0x%x, size %d, data 0x%x\n",
S                          ptr, shdr[index].sh_size, *(rt_uint32_t *)data_addr));
S            ptr += shdr[index].sh_size;
S        }
S
S        /* load bss section */
S        if (IS_NOPROG(shdr[index]) && IS_AW(shdr[index]))
S        {
S            rt_memset(ptr, 0, shdr[index].sh_size);
S            bss_addr = (rt_uint32_t)ptr;
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("load bss 0x%x, size %d,\n",
S                                           ptr, shdr[index].sh_size));
S        }
S    }
S
S    /* set module entry */
S    module->module_entry =
S        (rt_uint8_t *)module->module_space + elf_module->e_entry - module_addr;
S
S    /* handle relocation section */
S    for (index = 0; index < elf_module->e_shnum; index ++)
S    {
S        rt_uint32_t i, nr_reloc;
S        Elf32_Sym *symtab;
S        Elf32_Rel *rel;
S
S        if (!IS_REL(shdr[index]))
S            continue;
S
S        /* get relocate item */
S        rel = (Elf32_Rel *)((rt_uint8_t *)module_ptr + shdr[index].sh_offset);
S
S        /* locate .dynsym and .dynstr */
S        symtab   = (Elf32_Sym *)((rt_uint8_t *)module_ptr +
S                                 shdr[shdr[index].sh_link].sh_offset);
S        strtab   = (rt_uint8_t *)module_ptr +
S            shdr[shdr[shdr[index].sh_link].sh_link].sh_offset;
S        shstrab  = (rt_uint8_t *)module_ptr +
S            shdr[elf_module->e_shstrndx].sh_offset;
S        nr_reloc = (rt_uint32_t)(shdr[index].sh_size / sizeof(Elf32_Rel));
S
S        /* relocate every items */
S        for (i = 0; i < nr_reloc; i ++)
S        {
S            Elf32_Sym *sym = &symtab[ELF32_R_SYM(rel->r_info)];
S
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("relocate symbol: %s\n",
S                                           strtab + sym->st_name));
S
S            if (sym->st_shndx != STN_UNDEF)
S            {
S                if ((ELF_ST_TYPE(sym->st_info) == STT_SECTION) ||
S                    (ELF_ST_TYPE(sym->st_info) == STT_OBJECT))
S                {
S                    if (rt_strncmp((const char *)(shstrab +
S                                                  shdr[sym->st_shndx].sh_name), ELF_RODATA, 8) == 0)
S                    {
S                        /* relocate rodata section */
S                        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rodata\n"));
S                        rt_module_arm_relocate(module, rel,
S                                               (Elf32_Addr)(rodata_addr + sym->st_value));
S                    }
S                    else if (rt_strncmp((const char*)
S                                        (shstrab + shdr[sym->st_shndx].sh_name), ELF_BSS, 5) == 0)
S                    {
S                        /* relocate bss section */
S                        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("bss\n"));
S                        rt_module_arm_relocate(module, rel,
S                                               (Elf32_Addr)bss_addr + sym->st_value);
S                    }
S                    else if (rt_strncmp((const char *)(shstrab + shdr[sym->st_shndx].sh_name),
S                                        ELF_DATA, 6) == 0)
S                    {
S                        /* relocate data section */
S                        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("data\n"));
S                        rt_module_arm_relocate(module, rel,
S                                               (Elf32_Addr)data_addr + sym->st_value);
S                    }
S                }
S            }
S            else if (ELF_ST_TYPE(sym->st_info) == STT_FUNC)
S            {
S                /* relocate function */
S                rt_module_arm_relocate(module, rel,
S                                       (Elf32_Addr)((rt_uint8_t *)
S                                                    module->module_space
S                                                    - module_addr
S                                                    + sym->st_value));
S            }
S            else
S            {
S                Elf32_Addr addr;
S
S                if (ELF32_R_TYPE(rel->r_info) != R_ARM_V4BX)
S                {
S                    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("relocate symbol: %s\n",
S                                                   strtab + sym->st_name));
S
S                    /* need to resolve symbol in kernel symbol table */
S                    addr = rt_module_symbol_find((const char *)(strtab + sym->st_name));
S                    if (addr != (Elf32_Addr)RT_NULL)
S                    {
S                        rt_module_arm_relocate(module, rel, addr);
S                        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("symbol addr 0x%x\n",
S                                                       addr));
S                    }
S                    else
S                        rt_kprintf("Module: can't find %s in kernel symbol table\n",
S                                   strtab + sym->st_name);
S                }
S                else
S                {
S                    rt_module_arm_relocate(module, rel,
S                                           (Elf32_Addr)((rt_uint8_t*)
S                                                        module->module_space
S                                                        - module_addr
S                                                        + sym->st_value));
S                }
S            }
S            rel ++;
S        }
S    }
S
S    return module;
S}
S
S#define RT_MODULE_ARG_MAX    8
Sstatic int _rt_module_split_arg(char* cmd, rt_size_t length, char* argv[])
S{
S    int argc = 0;
S    char *ptr = cmd;
S
S    while ((ptr - cmd) < length)
S    {
S        /* strip bank and tab */
S        while ((*ptr == ' ' || *ptr == '\t') && (ptr -cmd)< length)
S            *ptr++ = '\0';
S        /* check whether it's the end of line */
S        if ((ptr - cmd)>= length) break;
S
S        /* handle string with quote */
S        if (*ptr == '"')
S        {
S            argv[argc++] = ++ptr;
S
S            /* skip this string */
S            while (*ptr != '"' && (ptr-cmd) < length)
S                if (*ptr ++ == '\\')  ptr ++;
S            if ((ptr - cmd) >= length) break;
S
S            /* skip '"' */
S            *ptr ++ = '\0';
S        }
S        else
S        {
S            argv[argc++] = ptr;
S            while ((*ptr != ' ' && *ptr != '\t') && (ptr - cmd) < length)
S                ptr ++;
S        }
S
S        if (argc >= RT_MODULE_ARG_MAX) break;
S    }
S
S    return argc;
S}
S
S/* module main thread entry */
Sstatic void module_main_entry(void* parameter)
S{
S    int argc;
S    char *argv[RT_MODULE_ARG_MAX];
S    typedef int (*main_func_t)(int argc, char** argv);
S
S    rt_module_t module = (rt_module_t) parameter;
S    if (module == RT_NULL)
S        return;
S
S    if (module->module_cmd_line == RT_NULL && module->module_cmd_size != 0)
S        /* malloc for module_cmd_line failed. */
S        return;
S
S    /* FIXME: we should run some C++ initialize code before jump into the
S     * entry. */
S
S    if (module->module_cmd_line == RT_NULL)
S    {
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("run bare entry: 0x%p\n",
S                                       module->module_entry));
S        ((main_func_t)module->module_entry)(0, RT_NULL);
S        return;
S    }
S
S    rt_memset(argv, 0x00, sizeof(argv));
S    argc = _rt_module_split_arg((char*)module->module_cmd_line,
S                                module->module_cmd_size, argv);
S    if (argc == 0)
S        return;
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("run main entry: 0x%p with %s\n",
S                                   module->module_entry,
S                                   module->module_cmd_line));
S    /* do the main function */
S    ((main_func_t)module->module_entry)(argc, argv);
S    return;
S}
S
S/**
S * This function will load a module with a main function from memory and create a 
S * main thread for it
S *
S * @param name the name of module, which shall be unique
S * @param module_ptr the memory address of module image
S * @argc the count of argument
S * @argd the argument data, which should be a 
S *
S * @return the module object
S */
Srt_module_t rt_module_do_main(const char *name,
S                              void *module_ptr,
S                              const char* cmd_line,
S                              int line_size)
S{
S    rt_module_t module;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_load: %s\n", name));
S
S    /* check ELF header */
S    if (rt_memcmp(elf_module->e_ident, RTMMAG, SELFMAG) != 0 &&
S        rt_memcmp(elf_module->e_ident, ELFMAG, SELFMAG) != 0)
S    {
S        rt_kprintf("Module: magic error\n");
S
S        return RT_NULL;
S    }
S
S    /* check ELF class */
S    if (elf_module->e_ident[EI_CLASS] != ELFCLASS32)
S    {
S        rt_kprintf("Module: ELF class error\n");
S
S        return RT_NULL;
S    }
S
S    if (elf_module->e_type == ET_REL)
S    {
S        module = _load_relocated_object(name, module_ptr);
S    }
S    else if (elf_module->e_type == ET_DYN)
S    {
S        module = _load_shared_object(name, module_ptr);
S    }
S    else
S    {
S        rt_kprintf("Module: unsupported elf type\n");
S
S        return RT_NULL;
S    }
S
S    if (module == RT_NULL)
S        return RT_NULL;
S
S    /* init module object container */
S    rt_module_init_object_container(module);
S
S    if (line_size && cmd_line)
S    {
S        /* set module argument */
S        module->module_cmd_line = (rt_uint8_t*)rt_malloc(line_size + 1);
S        if (module->module_cmd_line)
S        {
S            rt_memcpy(module->module_cmd_line, cmd_line, line_size);
S            module->module_cmd_line[line_size] = '\0';
S        }
S        module->module_cmd_size = line_size;
S    }
S    else
S    {
S        /* initialize an empty command */
S        module->module_cmd_line = RT_NULL;
S        module->module_cmd_size = 0;
S    }
S
S    /* increase module reference count */
S    module->nref ++;
S
S    if (elf_module->e_entry != 0)
S    {
S#ifdef RT_USING_SLAB
S        /* init module memory allocator */
S        module->mem_list = RT_NULL;
S
S        /* create page array */
S        module->page_array =
S            (void *)rt_malloc(PAGE_COUNT_MAX * sizeof(struct rt_page_info));
S        module->page_cnt = 0;
S#endif
S
S        /* create module thread */
S        module->module_thread = rt_thread_create(name,
S                                                 module_main_entry, module,
S                                                 RT_USING_MODULE_STKSZ,
S                                                 RT_USING_MODULE_PRIO, 10);
S
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("thread entry 0x%x\n",
S                                       module->module_entry));
S
S        /* set module id */
S        module->module_thread->module_id = (void *)module;
S        module->parent.flag = RT_MODULE_FLAG_WITHENTRY;
S
S        /* startup module thread */
S        rt_thread_startup(module->module_thread);
S    }
S    else
S    {
S        /* without entry point */
S        module->parent.flag |= RT_MODULE_FLAG_WITHOUTENTRY;
S    }
S
S#ifdef RT_USING_HOOK
S    if (rt_module_load_hook != RT_NULL)
S    {
S        rt_module_load_hook(module);
S    }
S#endif
S
S    return module;
S}
S
S/**
S * This function will load a module from memory and create a thread for it
S *
S * @param name the name of module, which shall be unique
S * @param module_ptr the memory address of module image
S *
S * @return the module object
S */
Srt_module_t rt_module_load(const char *name, void *module_ptr)
S{
S    return rt_module_do_main(name, module_ptr, RT_NULL, 0);
S}
S
S#ifdef RT_USING_DFS
S#include <dfs_posix.h>
S
Sstatic char* _module_name(const char *path)
S{
S    const char *first, *end, *ptr;
S    char *name;
S    int size;
S
S    ptr   = (char *)path;
S    first = ptr;
S    end   = path + rt_strlen(path);
S
S    while (*ptr != '\0')
S    {
S        if (*ptr == '/')
S            first = ptr + 1;
S        if (*ptr == '.')
S            end = ptr - 1;
S
S        ptr ++;
S    }
S
S    size = end - first + 1;
S    name = rt_malloc(size);
S    rt_strncpy(name, first, size);
S    name[size] = '\0';
S
S    return name;
S}
S
S/**
S * This function will load a module from a file
S *
S * @param path the full path of application module
S *
S * @return the module object
S */
Srt_module_t rt_module_open(const char *path)
S{
S    int fd, length;
S    struct rt_module *module;
S    struct stat s;
S    char *buffer, *offset_ptr;
S    char *name;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    /* check parameters */
S    RT_ASSERT(path != RT_NULL);
S
S    if (stat(path, &s) !=0)
S    {
S        rt_kprintf("Module: access %s failed\n", path);
S
S        return RT_NULL;
S    }
S    buffer = (char *)rt_malloc(s.st_size);
S    if (buffer == RT_NULL)
S    {
S        rt_kprintf("Module: out of memory\n");
S
S        return RT_NULL;
S    }
S
S    offset_ptr = buffer;
S    fd = open(path, O_RDONLY, 0);
S    if (fd < 0)
S    {
S        rt_kprintf("Module: open %s failed\n", path);
S        rt_free(buffer);
S
S        return RT_NULL;
S    }
S
S    do
S    {
S        length = read(fd, offset_ptr, 4096);
S        if (length > 0)
S        {
S            offset_ptr += length;
S        }
S    }while (length > 0);
S
S    /* close fd */
S    close(fd);
S
S    if ((rt_uint32_t)offset_ptr - (rt_uint32_t)buffer != s.st_size)
S    {
S        rt_kprintf("Module: read file failed\n");
S        rt_free(buffer);
S
S        return RT_NULL;
S    }
S
S    name   = _module_name(path);
S    module = rt_module_load(name, (void *)buffer);
S    rt_free(buffer);
S    rt_free(name);
S
S    return module;
S}
S
S/**
S * This function will do a excutable program with main function and parameters.
S *
S * @param path the full path of application module
S * @param cmd_line the command line of program
S * @param size the size of command line of program
S *
S * @return the module object
S */
Srt_module_t rt_module_exec_cmd(const char *path, const char* cmd_line, int size)
S{
S    struct stat s;
S    int fd, length;
S    char *name, *buffer, *offset_ptr;
S    struct rt_module *module = RT_NULL;
S
S    name = buffer = RT_NULL;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    /* check parameters */
S    RT_ASSERT(path != RT_NULL);
S
S    /* get file size */
S    if (stat(path, &s) !=0)
S    {
S        rt_kprintf("Module: access %s failed\n", path);
S        goto __exit;
S    }
S
S    /* allocate buffer to save program */
S    offset_ptr = buffer = (char *)rt_malloc(s.st_size);
S    if (buffer == RT_NULL)
S    {
S        rt_kprintf("Module: out of memory\n");
S        goto __exit;
S    }
S
S    fd = open(path, O_RDONLY, 0);
S    if (fd < 0)
S    {
S        rt_kprintf("Module: open %s failed\n", path);
S        goto __exit;
S    }
S
S    do
S    {
S        length = read(fd, offset_ptr, 4096);
S        if (length > 0)
S        {
S            offset_ptr += length;
S        }
S    }while (length > 0);
S    /* close fd */
S    close(fd);
S
S    if ((rt_uint32_t)offset_ptr - (rt_uint32_t)buffer != s.st_size)
S    {
S        rt_kprintf("Module: read file failed\n");
S        goto __exit;
S    }
S
S    /* get module */
S    name   = _module_name(path);
S    /* execute module */
S    module = rt_module_do_main(name, (void *)buffer, cmd_line, size);
S
S__exit:
S    rt_free(buffer);
S    rt_free(name);
S
S    return module;
S}
S
S#if defined(RT_USING_FINSH)
S#include <finsh.h>
SFINSH_FUNCTION_EXPORT_ALIAS(rt_module_open, exec, exec module from a file);
S#endif
S
S#endif
S
S/**
S * This function will destroy a module and release its resource.
S *
S * @param module the module to be destroyed.
S *
S * @return the operation status, RT_EOK on OK; -RT_ERROR on error
S */
Srt_err_t rt_module_destroy(rt_module_t module)
S{
S    int i;
S    struct rt_object *object;
S    struct rt_list_node *list;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    /* check parameter */
S    RT_ASSERT(module != RT_NULL);
S    RT_ASSERT(module->nref == 0);
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_destroy: %8.*s\n",
S                                   RT_NAME_MAX, module->parent.name));
S
S    /* module has entry point */
S    if (!(module->parent.flag & RT_MODULE_FLAG_WITHOUTENTRY))
S    {
S#ifdef RT_USING_SEMAPHORE
S        /* delete semaphores */
S        list = &module->module_object[RT_Object_Class_Semaphore].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_sem_detach((rt_sem_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_sem_delete((rt_sem_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_MUTEX
S        /* delete mutexs*/
S        list = &module->module_object[RT_Object_Class_Mutex].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_mutex_detach((rt_mutex_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_mutex_delete((rt_mutex_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_EVENT
S        /* delete mailboxs */
S        list = &module->module_object[RT_Object_Class_Event].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_event_detach((rt_event_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_event_delete((rt_event_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_MAILBOX
S        /* delete mailboxs */
S        list = &module->module_object[RT_Object_Class_MailBox].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_mb_detach((rt_mailbox_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_mb_delete((rt_mailbox_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_MESSAGEQUEUE
S        /* delete msgqueues */
S        list = &module->module_object[RT_Object_Class_MessageQueue].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_mq_detach((rt_mq_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_mq_delete((rt_mq_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_MEMPOOL
S        /* delete mempools */
S        list = &module->module_object[RT_Object_Class_MemPool].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_mp_detach((rt_mp_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_mp_delete((rt_mp_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_DEVICE
S        /* delete devices */
S        list = &module->module_object[RT_Object_Class_Device].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            rt_device_unregister((rt_device_t)object);
S        }
S#endif
S
S        /* delete timers */
S        list = &module->module_object[RT_Object_Class_Timer].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_timer_detach((rt_timer_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_timer_delete((rt_timer_t)object);
S            }
S        }
S
S        /* delete command line */
S        if (module->module_cmd_line != RT_NULL)
S        {
S            rt_free(module->module_cmd_line);
S        }
S    }
S
S#ifdef RT_USING_SLAB
S    if (module->page_cnt > 0)
S    {
S        struct rt_page_info *page = (struct rt_page_info *)module->page_array;
S
S        rt_kprintf("Module: warning - memory still hasn't been free finished\n");
S
S        while (module->page_cnt != 0)
S        {
S            rt_module_free_page(module, page[0].page_ptr, page[0].npage);
S        }
S    }
S#endif
S
S    /* release module space memory */
S    rt_free(module->module_space);
S
S    /* release module symbol table */
S    for (i = 0; i < module->nsym; i ++)
S    {
S        rt_free((void *)module->symtab[i].name);
S    }
S    if (module->symtab != RT_NULL)
S        rt_free(module->symtab);
S
S#ifdef RT_USING_SLAB
S    if (module->page_array != RT_NULL)
S        rt_free(module->page_array);
S#endif
S
S    /* delete module object */
S    rt_object_delete((rt_object_t)module);
S
S    return RT_EOK;
S}
S
S/**
S * This function will unload a module from memory and release resources
S *
S * @param module the module to be unloaded
S *
S * @return the operation status, RT_EOK on OK; -RT_ERROR on error
S */
Srt_err_t rt_module_unload(rt_module_t module)
S{
S    struct rt_object *object;
S    struct rt_list_node *list;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    /* check parameter */
S    if (module == RT_NULL)
S        return -RT_ERROR;
S
S    rt_enter_critical();
S    if (!(module->parent.flag & RT_MODULE_FLAG_WITHOUTENTRY))
S    {
S        /* delete all sub-threads */
S        list = &module->module_object[RT_Object_Class_Thread].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_thread_detach((rt_thread_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_thread_delete((rt_thread_t)object);
S            }
S        }
S
S        /* delete the main thread of module */
S        if (module->module_thread != RT_NULL)
S        {
S            rt_thread_delete(module->module_thread);
S        }
S    }
S    rt_exit_critical();
S
S#ifdef RT_USING_HOOK
S    if (rt_module_unload_hook != RT_NULL)
S    {
S        rt_module_unload_hook(module);
S    }
S#endif
S
S    return RT_EOK;
S}
S
S/**
S * This function will find the specified module.
S *
S * @param name the name of module finding
S *
S * @return the module
S */
Srt_module_t rt_module_find(const char *name)
S{
S    struct rt_object_information *information;
S    struct rt_object *object;
S    struct rt_list_node *node;
S
S    extern struct rt_object_information rt_object_container[];
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    /* enter critical */
S    rt_enter_critical();
S
S    /* try to find device object */
S    information = &rt_object_container[RT_Object_Class_Module];
S    for (node = information->object_list.next;
S         node != &(information->object_list);
S         node = node->next)
S    {
S        object = rt_list_entry(node, struct rt_object, list);
S        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
S        {
S            /* leave critical */
S            rt_exit_critical();
S
S            return (rt_module_t)object;
S        }
S    }
S
S    /* leave critical */
S    rt_exit_critical();
S
S    /* not found */
S    return RT_NULL;
S}
SRTM_EXPORT(rt_module_find);
S
S#ifdef RT_USING_SLAB
S/*
S * This function will allocate the numbers page with specified size
S * in page memory.
S *
S * @param size the size of memory to be allocated.
S * @note this function is used for RT-Thread Application Module
S */
Sstatic void *rt_module_malloc_page(rt_size_t npages)
S{
S    void *chunk;
S    struct rt_page_info *page;
S    rt_module_t self_module;
S
S    self_module = rt_module_self();
S    RT_ASSERT(self_module != RT_NULL);
S
S    chunk = rt_page_alloc(npages);
S    if (chunk == RT_NULL)
S        return RT_NULL;
S
S    page = (struct rt_page_info *)self_module->page_array;
S    page[self_module->page_cnt].page_ptr = chunk;
S    page[self_module->page_cnt].npage    = npages;
S    self_module->page_cnt ++;
S
S    RT_ASSERT(self_module->page_cnt <= PAGE_COUNT_MAX);
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_malloc_page 0x%x %d\n",
S                                   chunk, npages));
S
S    return chunk;
S}
S
S/*
S * This function will release the previously allocated memory page
S * by rt_malloc_page.
S *
S * @param page_ptr the page address to be released.
S * @param npages the number of page shall be released.
S *
S * @note this function is used for RT-Thread Application Module
S */
Sstatic void rt_module_free_page(rt_module_t module,
S                                void       *page_ptr,
S                                rt_size_t   npages)
S{
S    int i, index;
S    struct rt_page_info *page;
S    rt_module_t self_module;
S
S    self_module = rt_module_self();
S    RT_ASSERT(self_module != RT_NULL);
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_free_page 0x%x %d\n",
S                                   page_ptr, npages));
S    rt_page_free(page_ptr, npages);
S
S    page = (struct rt_page_info *)module->page_array;
S
S    for (i = 0; i < module->page_cnt; i ++)
S    {
S        if (page[i].page_ptr == page_ptr)
S        {
S            if (page[i].npage == npages + 1)
S            {
S                page[i].page_ptr +=
S                    npages * RT_MM_PAGE_SIZE / sizeof(rt_uint32_t);
S                page[i].npage    -= npages;
S            }
S            else if (page[i].npage == npages)
S            {
S                for (index = i; index < module->page_cnt-1; index ++)
S                {
S                    page[index].page_ptr = page[index + 1].page_ptr;
S                    page[index].npage    = page[index + 1].npage;
S                }
S                page[module->page_cnt - 1].page_ptr = RT_NULL;
S                page[module->page_cnt - 1].npage    = 0;
S
S                module->page_cnt --;
S            }
S            else
S                RT_ASSERT(RT_FALSE);
S            self_module->page_cnt --;
S
S            return;
S        }
S    }
S
S    /* should not get here */
S    RT_ASSERT(RT_FALSE);
S}
S
S/**
S * rt_module_malloc - allocate memory block in free list
S */
Svoid *rt_module_malloc(rt_size_t size)
S{
S    struct rt_mem_head *b, *n, *up;
S    struct rt_mem_head **prev;
S    rt_uint32_t npage;
S    rt_size_t nunits;
S    rt_module_t self_module;
S
S    self_module = rt_module_self();
S    RT_ASSERT(self_module != RT_NULL);
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    nunits = (size + sizeof(struct rt_mem_head) - 1) /
S        sizeof(struct rt_mem_head)
S        + 1;
S
S    RT_ASSERT(size != 0);
S    RT_ASSERT(nunits != 0);
S
S    rt_sem_take(&mod_sem, RT_WAITING_FOREVER);
S
S    for (prev = (struct rt_mem_head **)&self_module->mem_list;
S         (b = *prev) != RT_NULL;
S         prev = &(b->next))
S    {
S        if (b->size > nunits)
S        {
S            /* split memory */
S            n       = b + nunits;
S            n->next = b->next;
S            n->size = b->size - nunits;
S            b->size = nunits;
S            *prev   = n;
S
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_malloc 0x%x, %d\n",
S                                           b + 1, size));
S            rt_sem_release(&mod_sem);
S
S            return (void *)(b + 1);
S        }
S
S        if (b->size == nunits)
S        {
S            /* this node fit, remove this node */
S            *prev = b->next;
S
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_malloc 0x%x, %d\n",
S                                           b + 1, size));
S
S            rt_sem_release(&mod_sem);
S
S            return (void *)(b + 1);
S        }
S    }
S
S    /* allocate pages from system heap */
S    npage = (size + sizeof(struct rt_mem_head) + RT_MM_PAGE_SIZE - 1) /
S        RT_MM_PAGE_SIZE;
S    if ((up = (struct rt_mem_head *)rt_module_malloc_page(npage)) == RT_NULL)
S        return RT_NULL;
S
S    up->size = npage * RT_MM_PAGE_SIZE / sizeof(struct rt_mem_head);
S
S    for (prev = (struct rt_mem_head **)&self_module->mem_list;
S         (b = *prev) != RT_NULL;
S         prev = &(b->next))
S    {
S        if (b > up + up->size)
S            break;
S    }
S
S    up->next = b;
S    *prev    = up;
S
S    rt_sem_release(&mod_sem);
S
S    return rt_module_malloc(size);
S}
S
S/**
S * rt_module_free - free memory block in free list
S */
Svoid rt_module_free(rt_module_t module, void *addr)
S{
S    struct rt_mem_head *b, *n, *r;
S    struct rt_mem_head **prev;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    RT_ASSERT(addr);
S    RT_ASSERT((((rt_uint32_t)addr) & (sizeof(struct rt_mem_head) -1)) == 0);
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_free 0x%x\n", addr));
S
S    rt_sem_take(&mod_sem, RT_WAITING_FOREVER);
S
S    n = (struct rt_mem_head *)addr - 1;
S    prev = (struct rt_mem_head **)&module->mem_list;
S
S    while ((b = *prev) != RT_NULL)
S    {
S        RT_ASSERT(b->size > 0);
S        RT_ASSERT(b > n || b + b->size <= n);
S
S        if (b + b->size == n && ((rt_uint32_t)n % RT_MM_PAGE_SIZE != 0))
S        {
S            if (b + (b->size + n->size) == b->next)
S            {
S                b->size += b->next->size + n->size;
S                b->next = b->next->next;
S            }
S            else
S                b->size += n->size;
S
S            if ((rt_uint32_t)b % RT_MM_PAGE_SIZE == 0)
S            {
S                int npage =
S                    b->size * sizeof(struct rt_page_info) / RT_MM_PAGE_SIZE;
S                if (npage > 0)
S                {
S                    if ((b->size * sizeof(struct rt_page_info) % RT_MM_PAGE_SIZE) != 0)
S                    {
S                        rt_size_t nunits = npage *
S                            RT_MM_PAGE_SIZE /
S                            sizeof(struct rt_mem_head);
S                        /* split memory */
S                        r       = b + nunits;
S                        r->next = b->next;
S                        r->size = b->size - nunits;
S                        *prev   = r;
S                    }
S                    else
S                    {
S                        *prev = b->next;
S                    }
S
S                    rt_module_free_page(module, b, npage);
S                }
S            }
S
S            /* unlock */
S            rt_sem_release(&mod_sem);
S
S            return;
S        }
S
S        if (b == n + n->size)
S        {
S            n->size = b->size + n->size;
S            n->next = b->next;
S
S            if ((rt_uint32_t)n % RT_MM_PAGE_SIZE == 0)
S            {
S                int npage =
S                    n->size * sizeof(struct rt_page_info) / RT_MM_PAGE_SIZE;
S                if (npage > 0)
S                {
S                    if ((n->size * sizeof(struct rt_page_info) % RT_MM_PAGE_SIZE) != 0)
S                    {
S                        rt_size_t nunits = npage *
S                            RT_MM_PAGE_SIZE /
S                            sizeof(struct rt_mem_head);
S                        /* split memory */
S                        r       = n + nunits;
S                        r->next = n->next;
S                        r->size = n->size - nunits;
S                        *prev   = r;
S                    }
S                    else
S                        *prev = n->next;
S
S                    rt_module_free_page(module, n, npage);
S                }
S            }
S            else
S            {
S                *prev = n;
S            }
S
S            /* unlock */
S            rt_sem_release(&mod_sem);
S
S            return;
S        }
S        if (b > n + n->size)
S            break;
S
S        prev = &(b->next);
S    }
S
S    if ((rt_uint32_t)n % RT_MM_PAGE_SIZE == 0)
S    {
S        int npage = n->size * sizeof(struct rt_page_info) / RT_MM_PAGE_SIZE;
S        if (npage > 0)
S        {
S            rt_module_free_page(module, n, npage);
S            if (n->size % RT_MM_PAGE_SIZE != 0)
S            {
S                rt_size_t nunits =
S                    npage * RT_MM_PAGE_SIZE / sizeof(struct rt_mem_head);
S                /* split memory */
S                r       = n + nunits;
S                r->next = b;
S                r->size = n->size - nunits;
S                *prev   = r;
S            }
S            else
S            {
S                *prev = b;
S            }
S        }
S    }
S    else
S    {
S        n->next = b;
S        *prev   = n;
S    }
S
S    /* unlock */
S    rt_sem_release(&mod_sem);
S}
S
S/**
S * rt_module_realloc - realloc memory block in free list
S */
Svoid *rt_module_realloc(void *ptr, rt_size_t size)
S{
S    struct rt_mem_head *b, *p, *prev, *tmpp;
S    rt_size_t nunits;
S    rt_module_t self_module;
S
S    self_module = rt_module_self();
S    RT_ASSERT(self_module != RT_NULL);
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    if (!ptr)
S        return rt_module_malloc(size);
S    if (size == 0)
S    {
S        rt_module_free(self_module, ptr);
S
S        return RT_NULL;
S    }
S
S    nunits = (size + sizeof(struct rt_mem_head) - 1) /
S        sizeof(struct rt_mem_head)
S        +1;
S    b = (struct rt_mem_head *)ptr - 1;
S
S    if (nunits <= b->size)
S    {
S        /* new size is smaller or equal then before */
S        if (nunits == b->size)
S            return ptr;
S        else
S        {
S            p       = b + nunits;
S            p->size = b->size - nunits;
S            b->size = nunits;
S            rt_module_free(self_module, (void *)(p + 1));
S
S            return (void *)(b + 1);
S        }
S    }
S    else
S    {
S        /* more space then required */
S        prev = (struct rt_mem_head *)self_module->mem_list;
S        for (p = prev->next;
S             p != (b->size + b) && p != RT_NULL;
S             prev = p, p = p->next)
S        {
S            break;
S        }
S
S        /* available block after ap in freelist */
S        if (p != RT_NULL &&
S            (p->size >= (nunits - (b->size))) &&
S            p == (b + b->size))
S        {
S            /* perfect match */
S            if (p->size == (nunits - (b->size)))
S            {
S                b->size    = nunits;
S                prev->next = p->next;
S            }
S            else  /* more space then required, split block */
S            {
S                /* pointer to old header */
S                tmpp = p;
S                p    = b + nunits;
S
S                /* restoring old pointer */
S                p->next = tmpp->next;
S
S                /* new size for p */
S                p->size    = tmpp->size + b->size - nunits;
S                b->size    = nunits;
S                prev->next = p;
S            }
S            self_module->mem_list = (void *)prev;
S
S            return (void *)(b + 1);
S        }
S        else /* allocate new memory and copy old data */
S        {
S            if ((p = rt_module_malloc(size)) == RT_NULL)
S                return RT_NULL;
S            rt_memmove(p, (b+1), ((b->size) * sizeof(struct rt_mem_head)));
S            rt_module_free(self_module, (void *)(b + 1));
S
S            return (void *)(p);
S        }
S    }
S}
S
S#ifdef RT_USING_FINSH
S#include <finsh.h>
S
Svoid list_memlist(const char *name)
S{
S    rt_module_t module;
S    struct rt_mem_head **prev;
S    struct rt_mem_head *b;
S
S    module = rt_module_find(name);
S    if (module == RT_NULL)
S        return;
S
S    for (prev = (struct rt_mem_head **)&module->mem_list;
S         (b = *prev) != RT_NULL;
S         prev = &(b->next))
S    {
S        rt_kprintf("0x%x--%d\n", b, b->size * sizeof(struct rt_mem_head));
S    }
S}
SFINSH_FUNCTION_EXPORT(list_memlist, list module free memory information)
S
Svoid list_mempage(const char *name)
S{
S    rt_module_t module;
S    struct rt_page_info *page;
S    int i;
S
S    module = rt_module_find(name);
S    if (module == RT_NULL)
S        return;
S
S    page = (struct rt_page_info *)module->page_array;
S
S    for (i = 0; i < module->page_cnt; i ++)
S    {
S        rt_kprintf("0x%x--%d\n", page[i].page_ptr, page[i].npage);
S    }
S}
SFINSH_FUNCTION_EXPORT(list_mempage, list module using memory page information)
S#endif /* RT_USING_FINSH */
S
S#endif /* RT_USING_SLAB */
S
N#endif
