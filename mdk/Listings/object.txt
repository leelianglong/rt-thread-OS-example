; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\object.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\object.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\object.crf ..\rt_thread\kernel\object.c]
                          THUMB

                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
000002  6051              STR      r1,[r2,#4]
;;;65         n->next = l->next;
000004  6802              LDR      r2,[r0,#0]
000006  600a              STR      r2,[r1,#0]
;;;66     
;;;67         l->next = n;
000008  6001              STR      r1,[r0,#0]
;;;68         n->prev = l;
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_remove||, CODE, READONLY, ALIGN=1

                  rt_list_remove PROC
;;;89      */
;;;90     rt_inline void rt_list_remove(rt_list_t *n)
000000  e9d02100          LDRD     r2,r1,[r0,#0]
;;;91     {
;;;92         n->next->prev = n->prev;
000004  6051              STR      r1,[r2,#4]
;;;93         n->prev->next = n->next;
000006  e9d01200          LDRD     r1,r2,[r0,#0]
00000a  6011              STR      r1,[r2,#0]
;;;94     
;;;95         n->next = n->prev = n;
00000c  6040              STR      r0,[r0,#4]
00000e  6000              STR      r0,[r0,#0]
;;;96     }
000010  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.rt_object_allocate||, CODE, READONLY, ALIGN=2

                  rt_object_allocate PROC
;;;273     */
;;;274    rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;275    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;276        struct rt_object *object;
;;;277        register rt_base_t temp;
;;;278        struct rt_object_information *information;
;;;279    
;;;280        RT_DEBUG_NOT_IN_INTERRUPT;
000008  bf00              NOP      
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4681              MOV      r9,r0
000010  f7fffffe          BL       rt_interrupt_get_nest
000014  b148              CBZ      r0,|L3.42|
000016  491b              LDR      r1,|L3.132|
000018  a01b              ADR      r0,|L3.136|
00001a  f7fffffe          BL       rt_kprintf
00001e  f44f728c          MOV      r2,#0x118
000022  4918              LDR      r1,|L3.132|
000024  a021              ADR      r0,|L3.172|
000026  f7fffffe          BL       rt_assert_handler
                  |L3.42|
00002a  4648              MOV      r0,r9
00002c  f7fffffe          BL       rt_hw_interrupt_enable
000030  bf00              NOP      
;;;281    
;;;282    #ifdef RT_USING_MODULE
;;;283        /*
;;;284         * get module object information,
;;;285         * module object should be managed by kernel object container
;;;286         */
;;;287        information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
;;;288                      &rt_module_self()->module_object[type] : &rt_object_container[type];
;;;289    #else
;;;290        /* get object information */
;;;291        information = &rt_object_container[type];
000032  481f              LDR      r0,|L3.176|
000034  eb001605          ADD      r6,r0,r5,LSL #4
;;;292    #endif
;;;293    
;;;294        object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
000038  68f0              LDR      r0,[r6,#0xc]
00003a  f7fffffe          BL       rt_malloc
00003e  4604              MOV      r4,r0
;;;295        if (object == RT_NULL)
000040  b914              CBNZ     r4,|L3.72|
;;;296        {
;;;297            /* no memory can be allocated */
;;;298            return RT_NULL;
000042  2000              MOVS     r0,#0
                  |L3.68|
;;;299        }
;;;300    
;;;301        /* initialize object's parameters */
;;;302    
;;;303        /* set object type */
;;;304        object->type = type;
;;;305    
;;;306        /* set object flag */
;;;307        object->flag = 0;
;;;308    
;;;309    #ifdef RT_USING_MODULE
;;;310        if (rt_module_self() != RT_NULL)
;;;311        {
;;;312            object->flag |= RT_OBJECT_FLAG_MODULE;
;;;313        }
;;;314        object->module_id = (void *)rt_module_self();
;;;315    #endif
;;;316    
;;;317        /* copy name */
;;;318        rt_strncpy(object->name, name, RT_NAME_MAX);
;;;319    
;;;320        RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
;;;321    
;;;322        /* lock interrupt */
;;;323        temp = rt_hw_interrupt_disable();
;;;324    
;;;325        /* insert object into information object list */
;;;326        rt_list_insert_after(&(information->object_list), &(object->list));
;;;327    
;;;328        /* unlock interrupt */
;;;329        rt_hw_interrupt_enable(temp);
;;;330    
;;;331        /* return object */
;;;332        return object;
;;;333    }
000044  e8bd87f0          POP      {r4-r10,pc}
                  |L3.72|
000048  7225              STRB     r5,[r4,#8]            ;304
00004a  2000              MOVS     r0,#0                 ;307
00004c  7260              STRB     r0,[r4,#9]            ;307
00004e  2208              MOVS     r2,#8                 ;318
000050  4639              MOV      r1,r7                 ;318
000052  4620              MOV      r0,r4                 ;318
000054  f7fffffe          BL       rt_strncpy
000058  bf00              NOP                            ;320
00005a  4816              LDR      r0,|L3.180|
00005c  6800              LDR      r0,[r0,#0]            ;320  ; rt_object_attach_hook
00005e  b118              CBZ      r0,|L3.104|
000060  4620              MOV      r0,r4                 ;320
000062  4914              LDR      r1,|L3.180|
000064  6809              LDR      r1,[r1,#0]            ;320  ; rt_object_attach_hook
000066  4788              BLX      r1                    ;320
                  |L3.104|
000068  bf00              NOP                            ;320
00006a  f7fffffe          BL       rt_hw_interrupt_disable
00006e  4680              MOV      r8,r0                 ;323
000070  f104010c          ADD      r1,r4,#0xc            ;326
000074  1d30              ADDS     r0,r6,#4              ;326
000076  f7fffffe          BL       rt_list_insert_after
00007a  4640              MOV      r0,r8                 ;329
00007c  f7fffffe          BL       rt_hw_interrupt_enable
000080  4620              MOV      r0,r4                 ;332
000082  e7df              B        |L3.68|
;;;334    
                          ENDP

                  |L3.132|
                          DCD      |symbol_number.48|
                  |L3.136|
000088  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00008c  74696f6e
000090  5b25735d
000094  20736861
000098  6c6c206e
00009c  6f742075
0000a0  73656420
0000a4  696e2049
0000a8  53520a00
                  |L3.172|
0000ac  3000              DCB      "0",0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L3.176|
                          DCD      rt_object_container
                  |L3.180|
                          DCD      rt_object_attach_hook

                          AREA ||i.rt_object_attach_sethook||, CODE, READONLY, ALIGN=2

                  rt_object_attach_sethook PROC
;;;97      */
;;;98     void rt_object_attach_sethook(void (*hook)(struct rt_object *object))
000000  4901              LDR      r1,|L4.8|
;;;99     {
;;;100        rt_object_attach_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_object_attach_hook
;;;101    }
000004  4770              BX       lr
;;;102    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      rt_object_attach_hook

                          AREA ||i.rt_object_delete||, CODE, READONLY, ALIGN=2

                  rt_object_delete PROC
;;;339     */
;;;340    void rt_object_delete(rt_object_t object)
000000  b570              PUSH     {r4-r6,lr}
;;;341    {
000002  4604              MOV      r4,r0
;;;342        register rt_base_t temp;
;;;343    
;;;344        /* object check */
;;;345        RT_ASSERT(object != RT_NULL);
000004  b92c              CBNZ     r4,|L5.18|
000006  f2401259          MOV      r2,#0x159
00000a  4912              LDR      r1,|L5.84|
00000c  a012              ADR      r0,|L5.88|
00000e  f7fffffe          BL       rt_assert_handler
                  |L5.18|
;;;346        RT_ASSERT(!(object->type & RT_Object_Class_Static));
000012  7a20              LDRB     r0,[r4,#8]
000014  f0000080          AND      r0,r0,#0x80
000018  b128              CBZ      r0,|L5.38|
00001a  f44f72ad          MOV      r2,#0x15a
00001e  490d              LDR      r1,|L5.84|
000020  a012              ADR      r0,|L5.108|
000022  f7fffffe          BL       rt_assert_handler
                  |L5.38|
;;;347    
;;;348        RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
000026  bf00              NOP      
000028  481b              LDR      r0,|L5.152|
00002a  6800              LDR      r0,[r0,#0]  ; rt_object_detach_hook
00002c  b118              CBZ      r0,|L5.54|
00002e  4620              MOV      r0,r4
000030  4919              LDR      r1,|L5.152|
000032  6809              LDR      r1,[r1,#0]  ; rt_object_detach_hook
000034  4788              BLX      r1
                  |L5.54|
000036  bf00              NOP      
;;;349    
;;;350        /* lock interrupt */
;;;351        temp = rt_hw_interrupt_disable();
000038  f7fffffe          BL       rt_hw_interrupt_disable
00003c  4605              MOV      r5,r0
;;;352    
;;;353        /* remove from old list */
;;;354        rt_list_remove(&(object->list));
00003e  f104000c          ADD      r0,r4,#0xc
000042  f7fffffe          BL       rt_list_remove
;;;355    
;;;356        /* unlock interrupt */
;;;357        rt_hw_interrupt_enable(temp);
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       rt_hw_interrupt_enable
;;;358    
;;;359    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;360        if (object->flag & RT_OBJECT_FLAG_MODULE)
;;;361            rt_module_free((rt_module_t)object->module_id, object);
;;;362        else
;;;363    #endif
;;;364    
;;;365        /* free the memory of object */
;;;366        RT_KERNEL_FREE(object);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       rt_free
;;;367    }
000052  bd70              POP      {r4-r6,pc}
;;;368    #endif
                          ENDP

                  |L5.84|
                          DCD      |symbol_number.49|
                  |L5.88|
000058  6f626a65          DCB      "object != RT_NULL",0
00005c  63742021
000060  3d205254
000064  5f4e554c
000068  4c00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L5.108|
00006c  21286f62          DCB      "!(object->type & RT_Object_Class_Static)",0
000070  6a656374
000074  2d3e7479
000078  70652026
00007c  2052545f
000080  4f626a65
000084  63745f43
000088  6c617373
00008c  5f537461
000090  74696329
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L5.152|
                          DCD      rt_object_detach_hook

                          AREA ||i.rt_object_detach||, CODE, READONLY, ALIGN=2

                  rt_object_detach PROC
;;;245     */
;;;246    void rt_object_detach(rt_object_t object)
000000  b570              PUSH     {r4-r6,lr}
;;;247    {
000002  4604              MOV      r4,r0
;;;248        register rt_base_t temp;
;;;249    
;;;250        /* object check */
;;;251        RT_ASSERT(object != RT_NULL);
000004  b924              CBNZ     r4,|L6.16|
000006  22fb              MOVS     r2,#0xfb
000008  490b              LDR      r1,|L6.56|
00000a  a00c              ADR      r0,|L6.60|
00000c  f7fffffe          BL       rt_assert_handler
                  |L6.16|
;;;252    
;;;253        RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
000010  bf00              NOP      
000012  480f              LDR      r0,|L6.80|
000014  6800              LDR      r0,[r0,#0]  ; rt_object_detach_hook
000016  b118              CBZ      r0,|L6.32|
000018  4620              MOV      r0,r4
00001a  490d              LDR      r1,|L6.80|
00001c  6809              LDR      r1,[r1,#0]  ; rt_object_detach_hook
00001e  4788              BLX      r1
                  |L6.32|
000020  bf00              NOP      
;;;254    
;;;255        /* lock interrupt */
;;;256        temp = rt_hw_interrupt_disable();
000022  f7fffffe          BL       rt_hw_interrupt_disable
000026  4605              MOV      r5,r0
;;;257    
;;;258        /* remove from old list */
;;;259        rt_list_remove(&(object->list));
000028  f104000c          ADD      r0,r4,#0xc
00002c  f7fffffe          BL       rt_list_remove
;;;260    
;;;261        /* unlock interrupt */
;;;262        rt_hw_interrupt_enable(temp);
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       rt_hw_interrupt_enable
;;;263    }
000036  bd70              POP      {r4-r6,pc}
;;;264    
                          ENDP

                  |L6.56|
                          DCD      __FUNCTION__
                  |L6.60|
00003c  6f626a65          DCB      "object != RT_NULL",0
000040  63742021
000044  3d205254
000048  5f4e554c
00004c  4c00    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L6.80|
                          DCD      rt_object_detach_hook

                          AREA ||i.rt_object_detach_sethook||, CODE, READONLY, ALIGN=2

                  rt_object_detach_sethook PROC
;;;108     */
;;;109    void rt_object_detach_sethook(void (*hook)(struct rt_object *object))
000000  4901              LDR      r1,|L7.8|
;;;110    {
;;;111        rt_object_detach_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_object_detach_hook
;;;112    }
000004  4770              BX       lr
;;;113    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      rt_object_detach_hook

                          AREA ||i.rt_object_find||, CODE, READONLY, ALIGN=2

                  rt_object_find PROC
;;;401     */
;;;402    rt_object_t rt_object_find(const char *name, rt_uint8_t type)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;403    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;404        struct rt_object *object = RT_NULL;
000008  f04f0800          MOV      r8,#0
;;;405        struct rt_list_node *node = RT_NULL;
00000c  2600              MOVS     r6,#0
;;;406        struct rt_object_information *information = RT_NULL;
00000e  2700              MOVS     r7,#0
;;;407    
;;;408        /* parameter check */
;;;409        if ((name == RT_NULL) || (type > RT_Object_Class_Unknown))
000010  b10c              CBZ      r4,|L8.22|
000012  2d09              CMP      r5,#9
000014  dd02              BLE      |L8.28|
                  |L8.22|
;;;410            return RT_NULL;
000016  2000              MOVS     r0,#0
                  |L8.24|
;;;411    
;;;412        /* which is invoke in interrupt status */
;;;413        RT_DEBUG_NOT_IN_INTERRUPT;
;;;414    
;;;415    #ifdef RT_USING_MODULE
;;;416        /* check whether to find a object inside a module. */
;;;417        {
;;;418            const char *name_ptr;
;;;419            int module_name_length;
;;;420    
;;;421            name_ptr = name;
;;;422            while ((*name_ptr != '\0') && (*name_ptr != '/'))
;;;423                name_ptr ++;
;;;424    
;;;425            if (*name_ptr == '/')
;;;426            {
;;;427                struct rt_module* module = RT_NULL;
;;;428    
;;;429                /* get the name length of module */
;;;430                module_name_length = name_ptr - name;
;;;431    
;;;432                /* enter critical */
;;;433                rt_enter_critical();
;;;434    
;;;435                /* find module */
;;;436                information = &rt_object_container[RT_Object_Class_Module];
;;;437                for (node = information->object_list.next;
;;;438                    node != &(information->object_list);
;;;439                    node  = node->next)
;;;440                {
;;;441                    object = rt_list_entry(node, struct rt_object, list);
;;;442                    if ((rt_strncmp(object->name, name, module_name_length) == 0) &&
;;;443                        (module_name_length == RT_NAME_MAX || object->name[module_name_length] == '\0'))
;;;444                    {
;;;445                        /* get module */
;;;446                        module = (struct rt_module*)object;
;;;447                        break;
;;;448                    }
;;;449                }
;;;450                rt_exit_critical();
;;;451    
;;;452                /* there is no this module inside the system */
;;;453                if (module == RT_NULL) return RT_NULL;
;;;454    
;;;455                /* get the object pool of module */
;;;456                information = &(module->module_object[type]);
;;;457    
;;;458                /* get object name */
;;;459                while ((*name_ptr == '/') && (*name_ptr != '\0')) name_ptr ++;
;;;460                if (*name_ptr == '\0')
;;;461                {
;;;462                    if (type == RT_Object_Class_Module) return object;
;;;463                    return RT_NULL;
;;;464                }
;;;465    
;;;466                /* point to the object name */
;;;467                name = name_ptr;
;;;468            }
;;;469        }
;;;470    #endif
;;;471    
;;;472        /* enter critical */
;;;473        rt_enter_critical();
;;;474    
;;;475        /* try to find object */
;;;476        if (information == RT_NULL) information = &rt_object_container[type];
;;;477        for (node  = information->object_list.next;
;;;478             node != &(information->object_list);
;;;479             node  = node->next)
;;;480        {
;;;481            object = rt_list_entry(node, struct rt_object, list);
;;;482            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
;;;483            {
;;;484                /* leave critical */
;;;485                rt_exit_critical();
;;;486    
;;;487                return object;
;;;488            }
;;;489        }
;;;490    
;;;491        /* leave critical */
;;;492        rt_exit_critical();
;;;493    
;;;494        return RT_NULL;
;;;495    }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L8.28|
00001c  bf00              NOP                            ;413
00001e  f7fffffe          BL       rt_hw_interrupt_disable
000022  4681              MOV      r9,r0                 ;413
000024  f7fffffe          BL       rt_interrupt_get_nest
000028  b148              CBZ      r0,|L8.62|
00002a  4915              LDR      r1,|L8.128|
00002c  a015              ADR      r0,|L8.132|
00002e  f7fffffe          BL       rt_kprintf
000032  f240129d          MOV      r2,#0x19d             ;413
000036  4912              LDR      r1,|L8.128|
000038  a01b              ADR      r0,|L8.168|
00003a  f7fffffe          BL       rt_assert_handler
                  |L8.62|
00003e  4648              MOV      r0,r9                 ;413
000040  f7fffffe          BL       rt_hw_interrupt_enable
000044  bf00              NOP                            ;413
000046  f7fffffe          BL       rt_enter_critical
00004a  b917              CBNZ     r7,|L8.82|
00004c  4817              LDR      r0,|L8.172|
00004e  eb001705          ADD      r7,r0,r5,LSL #4       ;476
                  |L8.82|
000052  687e              LDR      r6,[r7,#4]            ;477
000054  e00c              B        |L8.112|
                  |L8.86|
000056  f1a6080c          SUB      r8,r6,#0xc            ;481
00005a  2208              MOVS     r2,#8                 ;482
00005c  4621              MOV      r1,r4                 ;482
00005e  4640              MOV      r0,r8                 ;482
000060  f7fffffe          BL       rt_strncmp
000064  b918              CBNZ     r0,|L8.110|
000066  f7fffffe          BL       rt_exit_critical
00006a  4640              MOV      r0,r8                 ;487
00006c  e7d4              B        |L8.24|
                  |L8.110|
00006e  6836              LDR      r6,[r6,#0]            ;479
                  |L8.112|
000070  1d38              ADDS     r0,r7,#4              ;478
000072  4286              CMP      r6,r0                 ;478
000074  d1ef              BNE      |L8.86|
000076  f7fffffe          BL       rt_exit_critical
00007a  2000              MOVS     r0,#0                 ;494
00007c  e7cc              B        |L8.24|
;;;496    
                          ENDP

00007e  0000              DCW      0x0000
                  |L8.128|
                          DCD      |symbol_number.51|
                  |L8.132|
000084  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000088  74696f6e
00008c  5b25735d
000090  20736861
000094  6c6c206e
000098  6f742075
00009c  73656420
0000a0  696e2049
0000a4  53520a00
                  |L8.168|
0000a8  3000              DCB      "0",0
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L8.172|
                          DCD      rt_object_container

                          AREA ||i.rt_object_get_information||, CODE, READONLY, ALIGN=2

                  rt_object_get_information PROC
;;;189    struct rt_object_information *
;;;190    rt_object_get_information(enum rt_object_class_type type)
000000  4601              MOV      r1,r0
;;;191    {
;;;192        return &rt_object_container[type];
000002  4802              LDR      r0,|L9.12|
000004  eb001001          ADD      r0,r0,r1,LSL #4
;;;193    }
000008  4770              BX       lr
;;;194    RTM_EXPORT(rt_object_get_information);
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      rt_object_container

                          AREA ||i.rt_object_init||, CODE, READONLY, ALIGN=2

                  rt_object_init PROC
;;;203     */
;;;204    void rt_object_init(struct rt_object         *object,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;205                        enum rt_object_class_type type,
;;;206                        const char               *name)
;;;207    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;208        register rt_base_t temp;
;;;209        struct rt_object_information *information;
;;;210    
;;;211    #ifdef RT_USING_MODULE
;;;212        /* get module object information */
;;;213        information = (rt_module_self() != RT_NULL) ?
;;;214            &rt_module_self()->module_object[type] : &rt_object_container[type];
;;;215    #else
;;;216        /* get object information */
;;;217        information = &rt_object_container[type];
00000a  4810              LDR      r0,|L10.76|
00000c  eb001705          ADD      r7,r0,r5,LSL #4
;;;218    #endif
;;;219    
;;;220        /* initialize object's parameters */
;;;221    
;;;222        /* set object type to static */
;;;223        object->type = type | RT_Object_Class_Static;
000010  f0450080          ORR      r0,r5,#0x80
000014  7220              STRB     r0,[r4,#8]
;;;224    
;;;225        /* copy name */
;;;226        rt_strncpy(object->name, name, RT_NAME_MAX);
000016  2208              MOVS     r2,#8
000018  4631              MOV      r1,r6
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_strncpy
;;;227    
;;;228        RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
000020  bf00              NOP      
000022  480b              LDR      r0,|L10.80|
000024  6800              LDR      r0,[r0,#0]  ; rt_object_attach_hook
000026  b118              CBZ      r0,|L10.48|
000028  4620              MOV      r0,r4
00002a  4909              LDR      r1,|L10.80|
00002c  6809              LDR      r1,[r1,#0]  ; rt_object_attach_hook
00002e  4788              BLX      r1
                  |L10.48|
000030  bf00              NOP      
;;;229    
;;;230        /* lock interrupt */
;;;231        temp = rt_hw_interrupt_disable();
000032  f7fffffe          BL       rt_hw_interrupt_disable
000036  4680              MOV      r8,r0
;;;232    
;;;233        /* insert object into information object list */
;;;234        rt_list_insert_after(&(information->object_list), &(object->list));
000038  f104010c          ADD      r1,r4,#0xc
00003c  1d38              ADDS     r0,r7,#4
00003e  f7fffffe          BL       rt_list_insert_after
;;;235    
;;;236        /* unlock interrupt */
;;;237        rt_hw_interrupt_enable(temp);
000042  4640              MOV      r0,r8
000044  f7fffffe          BL       rt_hw_interrupt_enable
;;;238    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;239    
                          ENDP

                  |L10.76|
                          DCD      rt_object_container
                  |L10.80|
                          DCD      rt_object_attach_hook

                          AREA ||i.rt_object_is_systemobject||, CODE, READONLY, ALIGN=2

                  rt_object_is_systemobject PROC
;;;378     */
;;;379    rt_bool_t rt_object_is_systemobject(rt_object_t object)
000000  b510              PUSH     {r4,lr}
;;;380    {
000002  4604              MOV      r4,r0
;;;381        /* object check */
;;;382        RT_ASSERT(object != RT_NULL);
000004  b92c              CBNZ     r4,|L11.18|
000006  f44f72bf          MOV      r2,#0x17e
00000a  4906              LDR      r1,|L11.36|
00000c  a006              ADR      r0,|L11.40|
00000e  f7fffffe          BL       rt_assert_handler
                  |L11.18|
;;;383    
;;;384        if (object->type & RT_Object_Class_Static)
000012  7a20              LDRB     r0,[r4,#8]
000014  f0000080          AND      r0,r0,#0x80
000018  b108              CBZ      r0,|L11.30|
;;;385            return RT_TRUE;
00001a  2001              MOVS     r0,#1
                  |L11.28|
;;;386    
;;;387        return RT_FALSE;
;;;388    }
00001c  bd10              POP      {r4,pc}
                  |L11.30|
00001e  2000              MOVS     r0,#0                 ;387
000020  e7fc              B        |L11.28|
;;;389    
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      |symbol_number.50|
                  |L11.40|
000028  6f626a65          DCB      "object != RT_NULL",0
00002c  63742021
000030  3d205254
000034  5f4e554c
000038  4c00    
00003a  00                DCB      0
00003b  00                DCB      0

                          AREA ||i.rt_object_put_sethook||, CODE, READONLY, ALIGN=2

                  rt_object_put_sethook PROC
;;;156     */
;;;157    void rt_object_put_sethook(void (*hook)(struct rt_object *object))
000000  4901              LDR      r1,|L12.8|
;;;158    {
;;;159        rt_object_put_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_object_put_hook
;;;160    }
000004  4770              BX       lr
;;;161    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_object_take_sethook||, CODE, READONLY, ALIGN=2

                  rt_object_take_sethook PROC
;;;145     */
;;;146    void rt_object_take_sethook(void (*hook)(struct rt_object *object))
000000  4901              LDR      r1,|L13.8|
;;;147    {
;;;148        rt_object_take_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_object_take_hook
;;;149    }
000004  4770              BX       lr
;;;150    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_object_trytake_sethook||, CODE, READONLY, ALIGN=2

                  rt_object_trytake_sethook PROC
;;;126     */
;;;127    void rt_object_trytake_sethook(void (*hook)(struct rt_object *object))
000000  4901              LDR      r1,|L14.8|
;;;128    {
;;;129        rt_object_trytake_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_object_trytake_hook
;;;130    }
000004  4770              BX       lr
;;;131    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      rt_object_trytake_hook

                          AREA ||i.rt_system_object_init||, CODE, READONLY, ALIGN=1

                  rt_system_object_init PROC
;;;172     */
;;;173    void rt_system_object_init(void)
000000  4770              BX       lr
;;;174    {
;;;175    }
;;;176    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f6f          DCB      0x72,0x74,0x5f,0x6f
000004  626a6563          DCB      0x62,0x6a,0x65,0x63
000008  745f6465          DCB      0x74,0x5f,0x64,0x65
00000c  74616368          DCB      0x74,0x61,0x63,0x68
000010  00                DCB      0x00
                  |symbol_number.48|
000011  72745f            DCB      0x72,0x74,0x5f
000014  6f626a65          DCB      0x6f,0x62,0x6a,0x65
000018  63745f61          DCB      0x63,0x74,0x5f,0x61
00001c  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000020  61746500          DCB      0x61,0x74,0x65,0x00
                  |symbol_number.49|
000024  72745f6f          DCB      0x72,0x74,0x5f,0x6f
000028  626a6563          DCB      0x62,0x6a,0x65,0x63
00002c  745f6465          DCB      0x74,0x5f,0x64,0x65
000030  6c657465          DCB      0x6c,0x65,0x74,0x65
000034  00                DCB      0x00
                  |symbol_number.50|
000035  72745f            DCB      0x72,0x74,0x5f
000038  6f626a65          DCB      0x6f,0x62,0x6a,0x65
00003c  63745f69          DCB      0x63,0x74,0x5f,0x69
000040  735f7379          DCB      0x73,0x5f,0x73,0x79
000044  7374656d          DCB      0x73,0x74,0x65,0x6d
000048  6f626a65          DCB      0x6f,0x62,0x6a,0x65
00004c  637400            DCB      0x63,0x74,0x00
                  |symbol_number.51|
00004f  72                DCB      0x72
000050  745f6f62          DCB      0x74,0x5f,0x6f,0x62
000054  6a656374          DCB      0x6a,0x65,0x63,0x74
000058  5f66696e          DCB      0x5f,0x66,0x69,0x6e
00005c  6400              DCB      0x64,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  rt_object_container
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      rt_object_container+0x4
                          DCD      rt_object_container+0x4
                          DCD      0x00000080
000010  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      rt_object_container+0x14
                          DCD      rt_object_container+0x14
                          DCD      0x00000020
000020  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      rt_object_container+0x24
                          DCD      rt_object_container+0x24
                          DCD      0x00000024
000030  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      rt_object_container+0x34
                          DCD      rt_object_container+0x34
                          DCD      0x00000020
000040  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      rt_object_container+0x44
                          DCD      rt_object_container+0x44
                          DCD      0x00000030
000050  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      rt_object_container+0x54
                          DCD      rt_object_container+0x54
                          DCD      0x00000034
000060  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      rt_object_container+0x64
                          DCD      rt_object_container+0x64
                          DCD      0x00000038
000070  07000000          DCB      0x07,0x00,0x00,0x00
                          DCD      rt_object_container+0x74
                          DCD      rt_object_container+0x74
                          DCD      0x00000040
000080  08000000          DCB      0x08,0x00,0x00,0x00
                          DCD      rt_object_container+0x84
                          DCD      rt_object_container+0x84
                          DCD      0x0000002c
                  rt_object_attach_hook
                          DCD      0x00000000
                  rt_object_detach_hook
                          DCD      0x00000000
                  rt_object_trytake_hook
                          DCD      0x00000000
                  rt_object_take_hook
                          DCD      0x00000000
                  rt_object_put_hook
                          DCD      0x00000000
