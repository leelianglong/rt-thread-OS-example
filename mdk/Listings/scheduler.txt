; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\scheduler.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\scheduler.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\scheduler.crf ..\rt_thread\kernel\scheduler.c]
                          THUMB

                          AREA ||i._rt_scheduler_stack_check||, CODE, READONLY, ALIGN=2

                  _rt_scheduler_stack_check PROC
;;;87     #ifdef RT_USING_OVERFLOW_CHECK
;;;88     static void _rt_scheduler_stack_check(struct rt_thread *thread)
000000  b570              PUSH     {r4-r6,lr}
;;;89     {
000002  4604              MOV      r4,r0
;;;90         RT_ASSERT(thread != RT_NULL);
000004  b924              CBNZ     r4,|L1.16|
000006  225a              MOVS     r2,#0x5a
000008  4913              LDR      r1,|L1.88|
00000a  a014              ADR      r0,|L1.92|
00000c  f7fffffe          BL       rt_assert_handler
                  |L1.16|
;;;91     
;;;92         if (*((rt_uint8_t *)thread->stack_addr) != '#' ||
000010  6aa0              LDR      r0,[r4,#0x28]
000012  7800              LDRB     r0,[r0,#0]
000014  2823              CMP      r0,#0x23
000016  d109              BNE      |L1.44|
;;;93     	(rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
000018  6aa1              LDR      r1,[r4,#0x28]
00001a  69e0              LDR      r0,[r4,#0x1c]
00001c  4288              CMP      r0,r1
00001e  d905              BLS      |L1.44|
;;;94             (rt_uint32_t)thread->sp >
000020  e9d4010a          LDRD     r0,r1,[r4,#0x28]
000024  4408              ADD      r0,r0,r1
000026  69e1              LDR      r1,[r4,#0x1c]
000028  4288              CMP      r0,r1
00002a  d20a              BCS      |L1.66|
                  |L1.44|
;;;95             (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
;;;96         {
;;;97             rt_uint32_t level;
;;;98     
;;;99             rt_kprintf("thread:%s stack overflow\n", thread->name);
00002c  4621              MOV      r1,r4
00002e  a010              ADR      r0,|L1.112|
000030  f7fffffe          BL       rt_kprintf
;;;100            #ifdef RT_USING_FINSH
;;;101            {
;;;102                extern long list_thread(void);
;;;103                list_thread();
;;;104            }
;;;105            #endif
;;;106            level = rt_hw_interrupt_disable();
000034  f7fffffe          BL       rt_hw_interrupt_disable
000038  4605              MOV      r5,r0
;;;107            while (level);
00003a  bf00              NOP      
                  |L1.60|
00003c  2d00              CMP      r5,#0
00003e  d1fd              BNE      |L1.60|
;;;108        }
000040  e008              B        |L1.84|
                  |L1.66|
;;;109        else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
000042  6aa0              LDR      r0,[r4,#0x28]
000044  3020              ADDS     r0,r0,#0x20
000046  69e1              LDR      r1,[r4,#0x1c]
000048  4281              CMP      r1,r0
00004a  d803              BHI      |L1.84|
;;;110        {
;;;111            rt_kprintf("warning: %s stack is close to end of stack address.\n",
00004c  4621              MOV      r1,r4
00004e  a00f              ADR      r0,|L1.140|
000050  f7fffffe          BL       rt_kprintf
                  |L1.84|
;;;112                       thread->name);
;;;113        }
;;;114    }
000054  bd70              POP      {r4-r6,pc}
;;;115    #endif
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      __FUNCTION__
                  |L1.92|
00005c  74687265          DCB      "thread != RT_NULL",0
000060  61642021
000064  3d205254
000068  5f4e554c
00006c  4c00    
00006e  00                DCB      0
00006f  00                DCB      0
                  |L1.112|
000070  74687265          DCB      "thread:%s stack overflow\n",0
000074  61643a25
000078  73207374
00007c  61636b20
000080  6f766572
000084  666c6f77
000088  0a00    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L1.140|
00008c  7761726e          DCB      "warning: %s stack is close to end of stack address.\n",0
000090  696e673a
000094  20257320
000098  73746163
00009c  6b206973
0000a0  20636c6f
0000a4  73652074
0000a8  6f20656e
0000ac  64206f66
0000b0  20737461
0000b4  636b2061
0000b8  64647265
0000bc  73732e0a
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0

                          AREA ||i.rt_critical_level||, CODE, READONLY, ALIGN=2

                  rt_critical_level PROC
;;;409     */
;;;410    rt_uint16_t rt_critical_level(void)
000000  4801              LDR      r0,|L2.8|
;;;411    {
;;;412        return rt_scheduler_lock_nest;
000002  8800              LDRH     r0,[r0,#0]  ; rt_scheduler_lock_nest
000004  b280              UXTH     r0,r0
;;;413    }
000006  4770              BX       lr
;;;414    RTM_EXPORT(rt_critical_level);
                          ENDP

                  |L2.8|
                          DCD      rt_scheduler_lock_nest

                          AREA ||i.rt_enter_critical||, CODE, READONLY, ALIGN=2

                  rt_enter_critical PROC
;;;358     */
;;;359    void rt_enter_critical(void)
000000  b510              PUSH     {r4,lr}
;;;360    {
;;;361        register rt_base_t level;
;;;362    
;;;363        /* disable interrupt */
;;;364        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4604              MOV      r4,r0
;;;365    
;;;366        /*
;;;367         * the maximal number of nest is RT_UINT16_MAX, which is big
;;;368         * enough and does not check here
;;;369         */
;;;370        rt_scheduler_lock_nest ++;
000008  4804              LDR      r0,|L3.28|
00000a  8800              LDRH     r0,[r0,#0]  ; rt_scheduler_lock_nest
00000c  1c40              ADDS     r0,r0,#1
00000e  b200              SXTH     r0,r0
000010  4902              LDR      r1,|L3.28|
000012  8008              STRH     r0,[r1,#0]
;;;371    
;;;372        /* enable interrupt */
;;;373        rt_hw_interrupt_enable(level);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       rt_hw_interrupt_enable
;;;374    }
00001a  bd10              POP      {r4,pc}
;;;375    RTM_EXPORT(rt_enter_critical);
                          ENDP

                  |L3.28|
                          DCD      rt_scheduler_lock_nest

                          AREA ||i.rt_exit_critical||, CODE, READONLY, ALIGN=2

                  rt_exit_critical PROC
;;;379     */
;;;380    void rt_exit_critical(void)
000000  b510              PUSH     {r4,lr}
;;;381    {
;;;382        register rt_base_t level;
;;;383    
;;;384        /* disable interrupt */
;;;385        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4604              MOV      r4,r0
;;;386    
;;;387        rt_scheduler_lock_nest --;
000008  480b              LDR      r0,|L4.56|
00000a  8800              LDRH     r0,[r0,#0]  ; rt_scheduler_lock_nest
00000c  1e40              SUBS     r0,r0,#1
00000e  b200              SXTH     r0,r0
000010  4909              LDR      r1,|L4.56|
000012  8008              STRH     r0,[r1,#0]
;;;388    
;;;389        if (rt_scheduler_lock_nest <= 0)
000014  4608              MOV      r0,r1
000016  f9b00000          LDRSH    r0,[r0,#0]  ; rt_scheduler_lock_nest
00001a  2800              CMP      r0,#0
00001c  dc07              BGT      |L4.46|
;;;390        {
;;;391            rt_scheduler_lock_nest = 0;
00001e  2000              MOVS     r0,#0
000020  8008              STRH     r0,[r1,#0]
;;;392            /* enable interrupt */
;;;393            rt_hw_interrupt_enable(level);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_hw_interrupt_enable
;;;394    
;;;395            rt_schedule();
000028  f7fffffe          BL       rt_schedule
00002c  e002              B        |L4.52|
                  |L4.46|
;;;396        }
;;;397        else
;;;398        {
;;;399            /* enable interrupt */
;;;400            rt_hw_interrupt_enable(level);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       rt_hw_interrupt_enable
                  |L4.52|
;;;401        }
;;;402    }
000034  bd10              POP      {r4,pc}
;;;403    RTM_EXPORT(rt_exit_critical);
                          ENDP

000036  0000              DCW      0x0000
                  |L4.56|
                          DCD      rt_scheduler_lock_nest

                          AREA ||i.rt_list_init||, CODE, READONLY, ALIGN=1

                  rt_list_init PROC
;;;50      */
;;;51     rt_inline void rt_list_init(rt_list_t *l)
000000  6040              STR      r0,[r0,#4]
;;;52     {
;;;53         l->next = l->prev = l;
000002  6000              STR      r0,[r0,#0]
;;;54     }
000004  4770              BX       lr
;;;55     
                          ENDP


                          AREA ||i.rt_schedule||, CODE, READONLY, ALIGN=2

                  rt_schedule PROC
;;;191     */
;;;192    void rt_schedule(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;193    {
;;;194        rt_base_t level;
;;;195        struct rt_thread *to_thread;
;;;196        struct rt_thread *from_thread;
;;;197    
;;;198        /* disable interrupt */
;;;199        level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4607              MOV      r7,r0
;;;200    
;;;201        /* check the scheduler is enabled or not */
;;;202        if (rt_scheduler_lock_nest == 0)
00000a  481f              LDR      r0,|L6.136|
00000c  8800              LDRH     r0,[r0,#0]  ; rt_scheduler_lock_nest
00000e  2800              CMP      r0,#0
000010  d134              BNE      |L6.124|
;;;203        {
;;;204            register rt_ubase_t highest_ready_priority;
;;;205    
;;;206    #if RT_THREAD_PRIORITY_MAX <= 32
;;;207            highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
000012  481e              LDR      r0,|L6.140|
000014  6800              LDR      r0,[r0,#0]  ; rt_thread_ready_priority_group
000016  f7fffffe          BL       __rt_ffs
00001a  1e46              SUBS     r6,r0,#1
;;;208    #else
;;;209            register rt_ubase_t number;
;;;210    
;;;211            number = __rt_ffs(rt_thread_ready_priority_group) - 1;
;;;212            highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
;;;213    #endif
;;;214    
;;;215            /* get switch to thread */
;;;216            to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
00001c  481c              LDR      r0,|L6.144|
00001e  f8500036          LDR      r0,[r0,r6,LSL #3]
000022  f1a00414          SUB      r4,r0,#0x14
;;;217                                      struct rt_thread,
;;;218                                      tlist);
;;;219    
;;;220            /* if the destination thread is not the same as current thread */
;;;221            if (to_thread != rt_current_thread)
000026  481b              LDR      r0,|L6.148|
000028  6800              LDR      r0,[r0,#0]  ; rt_current_thread
00002a  4284              CMP      r4,r0
00002c  d025              BEQ      |L6.122|
;;;222            {
;;;223                rt_current_priority = (rt_uint8_t)highest_ready_priority;
00002e  491a              LDR      r1,|L6.152|
000030  700e              STRB     r6,[r1,#0]
;;;224                from_thread         = rt_current_thread;
000032  4818              LDR      r0,|L6.148|
000034  6805              LDR      r5,[r0,#0]  ; rt_current_thread
;;;225                rt_current_thread   = to_thread;
000036  6004              STR      r4,[r0,#0]  ; rt_current_thread
;;;226    
;;;227                RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
000038  bf00              NOP      
00003a  4818              LDR      r0,|L6.156|
00003c  6800              LDR      r0,[r0,#0]  ; rt_scheduler_hook
00003e  b120              CBZ      r0,|L6.74|
000040  4621              MOV      r1,r4
000042  4628              MOV      r0,r5
000044  4a15              LDR      r2,|L6.156|
000046  6812              LDR      r2,[r2,#0]  ; rt_scheduler_hook
000048  4790              BLX      r2
                  |L6.74|
00004a  bf00              NOP      
;;;228    
;;;229                /* switch to new thread */
;;;230                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
00004c  bf00              NOP      
00004e  bf00              NOP      
;;;231                             ("[%d]switch to priority#%d "
;;;232                              "thread:%.*s(sp:0x%p), "
;;;233                              "from thread:%.*s(sp: 0x%p)\n",
;;;234                              rt_interrupt_nest, highest_ready_priority,
;;;235                              RT_NAME_MAX, to_thread->name, to_thread->sp,
;;;236                              RT_NAME_MAX, from_thread->name, from_thread->sp));
;;;237    
;;;238    #ifdef RT_USING_OVERFLOW_CHECK //ÓÃÓÚÒç³ö¼ì²â
;;;239                _rt_scheduler_stack_check(to_thread);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       _rt_scheduler_stack_check
;;;240    #endif
;;;241    
;;;242                if (rt_interrupt_nest == 0)
000056  4812              LDR      r0,|L6.160|
000058  7800              LDRB     r0,[r0,#0]  ; rt_interrupt_nest
00005a  b930              CBNZ     r0,|L6.106|
;;;243                {
;;;244                    rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
00005c  f104011c          ADD      r1,r4,#0x1c
000060  f105001c          ADD      r0,r5,#0x1c
000064  f7fffffe          BL       rt_hw_context_switch
000068  e007              B        |L6.122|
                  |L6.106|
;;;245                                         (rt_uint32_t)&to_thread->sp);
;;;246                }
;;;247                else
;;;248                {
;;;249                    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));
00006a  bf00              NOP      
00006c  bf00              NOP      
;;;250    
;;;251                    rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
00006e  f104011c          ADD      r1,r4,#0x1c
000072  f105001c          ADD      r0,r5,#0x1c
000076  f7fffffe          BL       rt_hw_context_switch_interrupt
                  |L6.122|
;;;252                                                   (rt_uint32_t)&to_thread->sp);
;;;253                }
;;;254            }
;;;255        }
00007a  bf00              NOP      
                  |L6.124|
;;;256    
;;;257        /* enable interrupt */
;;;258        rt_hw_interrupt_enable(level);
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       rt_hw_interrupt_enable
;;;259    }
000082  e8bd81f0          POP      {r4-r8,pc}
;;;260    
                          ENDP

000086  0000              DCW      0x0000
                  |L6.136|
                          DCD      rt_scheduler_lock_nest
                  |L6.140|
                          DCD      rt_thread_ready_priority_group
                  |L6.144|
                          DCD      rt_thread_priority_table
                  |L6.148|
                          DCD      rt_current_thread
                  |L6.152|
                          DCD      rt_current_priority
                  |L6.156|
                          DCD      rt_scheduler_hook
                  |L6.160|
                          DCD      rt_interrupt_nest

                          AREA ||i.rt_schedule_insert_thread||, CODE, READONLY, ALIGN=2

                  rt_schedule_insert_thread PROC
;;;267     */
;;;268    void rt_schedule_insert_thread(struct rt_thread *thread)
000000  b570              PUSH     {r4-r6,lr}
;;;269    {
000002  4604              MOV      r4,r0
;;;270        register rt_base_t temp;
;;;271    
;;;272        RT_ASSERT(thread != RT_NULL);
000004  b92c              CBNZ     r4,|L7.18|
000006  f44f7288          MOV      r2,#0x110
00000a  4912              LDR      r1,|L7.84|
00000c  a012              ADR      r0,|L7.88|
00000e  f7fffffe          BL       rt_assert_handler
                  |L7.18|
;;;273    
;;;274        /* disable interrupt */
;;;275        temp = rt_hw_interrupt_disable();
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4605              MOV      r5,r0
;;;276    
;;;277        /* change stat */
;;;278        thread->stat = RT_THREAD_READY;
000018  2001              MOVS     r0,#1
00001a  f8840034          STRB     r0,[r4,#0x34]
;;;279    
;;;280        /* insert thread to ready list */
;;;281        rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
00001e  f8942035          LDRB     r2,[r4,#0x35]
000022  4b12              LDR      r3,|L7.108|
000024  eb0300c2          ADD      r0,r3,r2,LSL #3
000028  f1040114          ADD      r1,r4,#0x14
00002c  6842              LDR      r2,[r0,#4]
00002e  6011              STR      r1,[r2,#0]
000030  6842              LDR      r2,[r0,#4]
000032  604a              STR      r2,[r1,#4]
000034  6041              STR      r1,[r0,#4]
000036  6008              STR      r0,[r1,#0]
000038  bf00              NOP      
;;;282                              &(thread->tlist));
;;;283    
;;;284        /* set priority mask */
;;;285    #if RT_THREAD_PRIORITY_MAX <= 32
;;;286        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("insert thread[%.*s], the priority: %d\n",
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;287                                          RT_NAME_MAX, thread->name, thread->current_priority));
;;;288    #else
;;;289        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
;;;290                     ("insert thread[%.*s], the priority: %d 0x%x %d\n",
;;;291                      RT_NAME_MAX,
;;;292                      thread->name,
;;;293                      thread->number,
;;;294                      thread->number_mask,
;;;295                      thread->high_mask));
;;;296    #endif
;;;297    
;;;298    #if RT_THREAD_PRIORITY_MAX > 32
;;;299        rt_thread_ready_table[thread->number] |= thread->high_mask;
;;;300    #endif
;;;301        rt_thread_ready_priority_group |= thread->number_mask;
00003e  490c              LDR      r1,|L7.112|
000040  6ba0              LDR      r0,[r4,#0x38]
000042  6809              LDR      r1,[r1,#0]  ; rt_thread_ready_priority_group
000044  4308              ORRS     r0,r0,r1
000046  490a              LDR      r1,|L7.112|
000048  6008              STR      r0,[r1,#0]  ; rt_thread_ready_priority_group
;;;302    
;;;303        /* enable interrupt */
;;;304        rt_hw_interrupt_enable(temp);
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       rt_hw_interrupt_enable
;;;305    }
000050  bd70              POP      {r4-r6,pc}
;;;306    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      |symbol_number.39|
                  |L7.88|
000058  74687265          DCB      "thread != RT_NULL",0
00005c  61642021
000060  3d205254
000064  5f4e554c
000068  4c00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L7.108|
                          DCD      rt_thread_priority_table
                  |L7.112|
                          DCD      rt_thread_ready_priority_group

                          AREA ||i.rt_schedule_remove_thread||, CODE, READONLY, ALIGN=2

                  rt_schedule_remove_thread PROC
;;;313     */
;;;314    void rt_schedule_remove_thread(struct rt_thread *thread)
000000  b570              PUSH     {r4-r6,lr}
;;;315    {
000002  4604              MOV      r4,r0
;;;316        register rt_base_t temp;
;;;317    
;;;318        RT_ASSERT(thread != RT_NULL);
000004  b92c              CBNZ     r4,|L8.18|
000006  f44f729f          MOV      r2,#0x13e
00000a  4915              LDR      r1,|L8.96|
00000c  a015              ADR      r0,|L8.100|
00000e  f7fffffe          BL       rt_assert_handler
                  |L8.18|
;;;319    
;;;320        /* disable interrupt */
;;;321        temp = rt_hw_interrupt_disable();
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4605              MOV      r5,r0
;;;322    
;;;323    #if RT_THREAD_PRIORITY_MAX <= 32
;;;324        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("remove thread[%.*s], the priority: %d\n",
000018  bf00              NOP      
00001a  bf00              NOP      
;;;325                                          RT_NAME_MAX, thread->name,
;;;326                                          thread->current_priority));
;;;327    #else
;;;328        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
;;;329                     ("remove thread[%.*s], the priority: %d 0x%x %d\n",
;;;330                      RT_NAME_MAX,
;;;331                      thread->name,
;;;332                      thread->number,
;;;333                      thread->number_mask,
;;;334                      thread->high_mask));
;;;335    #endif
;;;336    
;;;337        /* remove thread from ready list */
;;;338        rt_list_remove(&(thread->tlist));
00001c  f1040014          ADD      r0,r4,#0x14
000020  e9d02100          LDRD     r2,r1,[r0,#0]
000024  6051              STR      r1,[r2,#4]
000026  e9d01200          LDRD     r1,r2,[r0,#0]
00002a  6011              STR      r1,[r2,#0]
00002c  6040              STR      r0,[r0,#4]
00002e  6000              STR      r0,[r0,#0]
000030  bf00              NOP      
;;;339        if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
000032  f8941035          LDRB     r1,[r4,#0x35]
000036  4a10              LDR      r2,|L8.120|
000038  eb0200c1          ADD      r0,r2,r1,LSL #3
00003c  6801              LDR      r1,[r0,#0]
00003e  4281              CMP      r1,r0
000040  d101              BNE      |L8.70|
000042  2101              MOVS     r1,#1
000044  e000              B        |L8.72|
                  |L8.70|
000046  2100              MOVS     r1,#0
                  |L8.72|
000048  b129              CBZ      r1,|L8.86|
;;;340        {
;;;341    #if RT_THREAD_PRIORITY_MAX > 32
;;;342            rt_thread_ready_table[thread->number] &= ~thread->high_mask;
;;;343            if (rt_thread_ready_table[thread->number] == 0)
;;;344            {
;;;345                rt_thread_ready_priority_group &= ~thread->number_mask;
;;;346            }
;;;347    #else
;;;348            rt_thread_ready_priority_group &= ~thread->number_mask;
00004a  480c              LDR      r0,|L8.124|
00004c  6ba1              LDR      r1,[r4,#0x38]
00004e  6800              LDR      r0,[r0,#0]  ; rt_thread_ready_priority_group
000050  4388              BICS     r0,r0,r1
000052  490a              LDR      r1,|L8.124|
000054  6008              STR      r0,[r1,#0]  ; rt_thread_ready_priority_group
                  |L8.86|
;;;349    #endif
;;;350        }
;;;351    
;;;352        /* enable interrupt */
;;;353        rt_hw_interrupt_enable(temp);
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       rt_hw_interrupt_enable
;;;354    }
00005c  bd70              POP      {r4-r6,pc}
;;;355    
                          ENDP

00005e  0000              DCW      0x0000
                  |L8.96|
                          DCD      |symbol_number.40|
                  |L8.100|
000064  74687265          DCB      "thread != RT_NULL",0
000068  61642021
00006c  3d205254
000070  5f4e554c
000074  4c00    
000076  00                DCB      0
000077  00                DCB      0
                  |L8.120|
                          DCD      rt_thread_priority_table
                  |L8.124|
                          DCD      rt_thread_ready_priority_group

                          AREA ||i.rt_scheduler_sethook||, CODE, READONLY, ALIGN=2

                  rt_scheduler_sethook PROC
;;;78     void
;;;79     rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread *to))
000000  4901              LDR      r1,|L9.8|
;;;80     {
;;;81         rt_scheduler_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_scheduler_hook
;;;82     }
000004  4770              BX       lr
;;;83     
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      rt_scheduler_hook

                          AREA ||i.rt_system_scheduler_init||, CODE, READONLY, ALIGN=2

                  rt_system_scheduler_init PROC
;;;120     */
;;;121    void rt_system_scheduler_init(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123        register rt_base_t offset;
;;;124    
;;;125        rt_scheduler_lock_nest = 0;
000002  2000              MOVS     r0,#0
000004  490c              LDR      r1,|L10.56|
000006  8008              STRH     r0,[r1,#0]
;;;126    
;;;127        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
000008  bf00              NOP      
00000a  bf00              NOP      
;;;128                                          RT_THREAD_PRIORITY_MAX));
;;;129    
;;;130        for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
00000c  2400              MOVS     r4,#0
00000e  e005              B        |L10.28|
                  |L10.16|
;;;131        {
;;;132            rt_list_init(&rt_thread_priority_table[offset]);
000010  490a              LDR      r1,|L10.60|
000012  eb0100c4          ADD      r0,r1,r4,LSL #3
000016  f7fffffe          BL       rt_list_init
00001a  1c64              ADDS     r4,r4,#1              ;130
                  |L10.28|
00001c  2c20              CMP      r4,#0x20              ;130
00001e  dbf7              BLT      |L10.16|
;;;133        }
;;;134    
;;;135        rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
000020  201f              MOVS     r0,#0x1f
000022  4907              LDR      r1,|L10.64|
000024  7008              STRB     r0,[r1,#0]
;;;136        rt_current_thread = RT_NULL;
000026  2000              MOVS     r0,#0
000028  4906              LDR      r1,|L10.68|
00002a  6008              STR      r0,[r1,#0]  ; rt_current_thread
;;;137    
;;;138        /* initialize ready priority group */
;;;139        rt_thread_ready_priority_group = 0;
00002c  4906              LDR      r1,|L10.72|
00002e  6008              STR      r0,[r1,#0]  ; rt_thread_ready_priority_group
;;;140    
;;;141    #if RT_THREAD_PRIORITY_MAX > 32
;;;142        /* initialize ready table */
;;;143        rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
;;;144    #endif
;;;145    
;;;146        /* initialize thread defunct */
;;;147        rt_list_init(&rt_thread_defunct);
000030  4806              LDR      r0,|L10.76|
000032  f7fffffe          BL       rt_list_init
;;;148    }
000036  bd10              POP      {r4,pc}
;;;149    
                          ENDP

                  |L10.56|
                          DCD      rt_scheduler_lock_nest
                  |L10.60|
                          DCD      rt_thread_priority_table
                  |L10.64|
                          DCD      rt_current_priority
                  |L10.68|
                          DCD      rt_current_thread
                  |L10.72|
                          DCD      rt_thread_ready_priority_group
                  |L10.76|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_system_scheduler_start||, CODE, READONLY, ALIGN=2

                  rt_system_scheduler_start PROC
;;;154     */
;;;155    void rt_system_scheduler_start(void)
000000  b570              PUSH     {r4-r6,lr}
;;;156    {
;;;157        register struct rt_thread *to_thread;
;;;158        register rt_ubase_t highest_ready_priority;
;;;159    
;;;160    #if RT_THREAD_PRIORITY_MAX > 32
;;;161        register rt_ubase_t number;
;;;162    
;;;163        number = __rt_ffs(rt_thread_ready_priority_group) - 1;
;;;164        highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
;;;165    #else
;;;166        highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
000002  4808              LDR      r0,|L11.36|
000004  6800              LDR      r0,[r0,#0]  ; rt_thread_ready_priority_group
000006  f7fffffe          BL       __rt_ffs
00000a  1e45              SUBS     r5,r0,#1
;;;167    #endif
;;;168    
;;;169        /* get switch to thread */
;;;170        to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
00000c  4806              LDR      r0,|L11.40|
00000e  f8500035          LDR      r0,[r0,r5,LSL #3]
000012  f1a00414          SUB      r4,r0,#0x14
;;;171                                  struct rt_thread,
;;;172                                  tlist);
;;;173    
;;;174        rt_current_thread = to_thread;
000016  4805              LDR      r0,|L11.44|
000018  6004              STR      r4,[r0,#0]  ; rt_current_thread
;;;175    
;;;176        /* switch to new thread */
;;;177        rt_hw_context_switch_to((rt_uint32_t)&to_thread->sp);
00001a  f104001c          ADD      r0,r4,#0x1c
00001e  f7fffffe          BL       rt_hw_context_switch_to
;;;178    
;;;179        /* never come back */
;;;180    }
000022  bd70              POP      {r4-r6,pc}
;;;181    
                          ENDP

                  |L11.36|
                          DCD      rt_thread_ready_priority_group
                  |L11.40|
                          DCD      rt_thread_priority_table
                  |L11.44|
                          DCD      rt_current_thread

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  rt_thread_priority_table
                          %        256

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  5f72745f          DCB      0x5f,0x72,0x74,0x5f
000004  73636865          DCB      0x73,0x63,0x68,0x65
000008  64756c65          DCB      0x64,0x75,0x6c,0x65
00000c  725f7374          DCB      0x72,0x5f,0x73,0x74
000010  61636b5f          DCB      0x61,0x63,0x6b,0x5f
000014  63686563          DCB      0x63,0x68,0x65,0x63
000018  6b00              DCB      0x6b,0x00
                  |symbol_number.39|
00001a  7274              DCB      0x72,0x74
00001c  5f736368          DCB      0x5f,0x73,0x63,0x68
000020  6564756c          DCB      0x65,0x64,0x75,0x6c
000024  655f696e          DCB      0x65,0x5f,0x69,0x6e
000028  73657274          DCB      0x73,0x65,0x72,0x74
00002c  5f746872          DCB      0x5f,0x74,0x68,0x72
000030  65616400          DCB      0x65,0x61,0x64,0x00
                  |symbol_number.40|
000034  72745f73          DCB      0x72,0x74,0x5f,0x73
000038  63686564          DCB      0x63,0x68,0x65,0x64
00003c  756c655f          DCB      0x75,0x6c,0x65,0x5f
000040  72656d6f          DCB      0x72,0x65,0x6d,0x6f
000044  76655f74          DCB      0x76,0x65,0x5f,0x74
000048  68726561          DCB      0x68,0x72,0x65,0x61
00004c  6400              DCB      0x64,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  rt_scheduler_lock_nest
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  rt_current_thread
                          DCD      0x00000000
                  rt_current_priority
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  rt_thread_ready_priority_group
                          DCD      0x00000000
                  rt_thread_defunct
                          %        8
                  rt_scheduler_hook
                          DCD      0x00000000
