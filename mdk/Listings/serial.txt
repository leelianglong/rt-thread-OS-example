; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\serial.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\serial.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\serial.crf ..\bsp\serial.c]
                          THUMB

                          AREA ||i._serial_dma_rx||, CODE, READONLY, ALIGN=2

                  _serial_dma_rx PROC
;;;239     */
;;;240    rt_inline int _serial_dma_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;241    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;242        rt_base_t level;
;;;243    
;;;244        RT_ASSERT((serial != RT_NULL) && (data != RT_NULL));
00000a  b104              CBZ      r4,|L1.14|
00000c  b927              CBNZ     r7,|L1.24|
                  |L1.14|
00000e  22f4              MOVS     r2,#0xf4
000010  493f              LDR      r1,|L1.272|
000012  a040              ADR      r0,|L1.276|
000014  f7fffffe          BL       rt_assert_handler
                  |L1.24|
;;;245    
;;;246        level = rt_hw_interrupt_disable();
000018  f7fffffe          BL       rt_hw_interrupt_disable
00001c  4682              MOV      r10,r0
;;;247    
;;;248        if (serial->config.bufsz == 0) {
00001e  6ca0              LDR      r0,[r4,#0x48]
000020  f3c0208f          UBFX     r0,r0,#10,#16
000024  2800              CMP      r0,#0
000026  d12c              BNE      |L1.130|
;;;249            int result = RT_EOK;
000028  2600              MOVS     r6,#0
;;;250            struct rt_serial_rx_dma *rx_dma;
;;;251    
;;;252            rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
00002a  6ce5              LDR      r5,[r4,#0x4c]
;;;253            RT_ASSERT(rx_dma != RT_NULL);
00002c  b925              CBNZ     r5,|L1.56|
00002e  22fd              MOVS     r2,#0xfd
000030  4937              LDR      r1,|L1.272|
000032  a043              ADR      r0,|L1.320|
000034  f7fffffe          BL       rt_assert_handler
                  |L1.56|
;;;254    
;;;255            if (rx_dma->activated != RT_TRUE)
000038  6828              LDR      r0,[r5,#0]
00003a  2801              CMP      r0,#1
00003c  d013              BEQ      |L1.102|
;;;256            {
;;;257                rx_dma->activated = RT_TRUE;
00003e  2001              MOVS     r0,#1
000040  6028              STR      r0,[r5,#0]
;;;258                RT_ASSERT(serial->ops->dma_transmit != RT_NULL);
000042  6c20              LDR      r0,[r4,#0x40]
000044  6900              LDR      r0,[r0,#0x10]
000046  b928              CBNZ     r0,|L1.84|
000048  f44f7281          MOV      r2,#0x102
00004c  4930              LDR      r1,|L1.272|
00004e  a041              ADR      r0,|L1.340|
000050  f7fffffe          BL       rt_assert_handler
                  |L1.84|
;;;259                serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_RX);
000054  6c20              LDR      r0,[r4,#0x40]
000056  2301              MOVS     r3,#1
000058  4642              MOV      r2,r8
00005a  4639              MOV      r1,r7
00005c  f8d0c010          LDR      r12,[r0,#0x10]
000060  4620              MOV      r0,r4
000062  47e0              BLX      r12
000064  e001              B        |L1.106|
                  |L1.102|
;;;260            }
;;;261            else result = -RT_EBUSY;
000066  f06f0606          MVN      r6,#6
                  |L1.106|
;;;262            rt_hw_interrupt_enable(level);
00006a  4650              MOV      r0,r10
00006c  f7fffffe          BL       rt_hw_interrupt_enable
;;;263    
;;;264            if (result == RT_EOK) return length;
000070  b916              CBNZ     r6,|L1.120|
000072  4640              MOV      r0,r8
                  |L1.116|
;;;265    
;;;266            rt_set_errno(result);
;;;267            return 0;
;;;268        } else {
;;;269            struct rt_serial_rx_fifo *rx_fifo = (struct rt_serial_rx_fifo *) serial->serial_rx;
;;;270            rt_size_t recv_len = 0, fifo_recved_len = rt_dma_calc_recved_len(serial);
;;;271    
;;;272            RT_ASSERT(rx_fifo != RT_NULL);
;;;273    
;;;274            if (length < fifo_recved_len) {
;;;275                recv_len = length;
;;;276            } else {
;;;277                recv_len = fifo_recved_len;
;;;278            }
;;;279    
;;;280            if (rx_fifo->get_index + recv_len < serial->config.bufsz) {
;;;281                rt_memcpy(data, rx_fifo->buffer + rx_fifo->get_index, recv_len);
;;;282            } else {
;;;283                rt_memcpy(data, rx_fifo->buffer + rx_fifo->get_index,
;;;284                        serial->config.bufsz - rx_fifo->get_index);
;;;285                rt_memcpy(data + serial->config.bufsz - rx_fifo->get_index, rx_fifo->buffer,
;;;286                        recv_len + rx_fifo->get_index - serial->config.bufsz);
;;;287            }
;;;288            rt_dma_recv_update_get_index(serial, recv_len);
;;;289            rt_hw_interrupt_enable(level);
;;;290            return recv_len;
;;;291        }
;;;292    }
000074  e8bd87f0          POP      {r4-r10,pc}
                  |L1.120|
000078  4630              MOV      r0,r6                 ;266
00007a  f7fffffe          BL       rt_set_errno
00007e  2000              MOVS     r0,#0                 ;267
000080  e7f8              B        |L1.116|
                  |L1.130|
000082  6ce5              LDR      r5,[r4,#0x4c]         ;269
000084  2600              MOVS     r6,#0                 ;270
000086  4620              MOV      r0,r4                 ;270
000088  f7fffffe          BL       rt_dma_calc_recved_len
00008c  4681              MOV      r9,r0                 ;270
00008e  b92d              CBNZ     r5,|L1.156|
000090  f44f7288          MOV      r2,#0x110             ;272
000094  491e              LDR      r1,|L1.272|
000096  a039              ADR      r0,|L1.380|
000098  f7fffffe          BL       rt_assert_handler
                  |L1.156|
00009c  45c8              CMP      r8,r9                 ;274
00009e  d201              BCS      |L1.164|
0000a0  4646              MOV      r6,r8                 ;275
0000a2  e000              B        |L1.166|
                  |L1.164|
0000a4  464e              MOV      r6,r9                 ;277
                  |L1.166|
0000a6  88e8              LDRH     r0,[r5,#6]            ;280
0000a8  1981              ADDS     r1,r0,r6              ;280
0000aa  6ca0              LDR      r0,[r4,#0x48]         ;280
0000ac  f3c0208f          UBFX     r0,r0,#10,#16         ;280
0000b0  4281              CMP      r1,r0                 ;280
0000b2  d207              BCS      |L1.196|
0000b4  88ea              LDRH     r2,[r5,#6]            ;281
0000b6  6828              LDR      r0,[r5,#0]            ;281
0000b8  1881              ADDS     r1,r0,r2              ;281
0000ba  4632              MOV      r2,r6                 ;281
0000bc  4638              MOV      r0,r7                 ;281
0000be  f7fffffe          BL       rt_memcpy
0000c2  e01c              B        |L1.254|
                  |L1.196|
0000c4  6ca0              LDR      r0,[r4,#0x48]         ;283
0000c6  f3c0208f          UBFX     r0,r0,#10,#16         ;283
0000ca  88eb              LDRH     r3,[r5,#6]            ;283
0000cc  1ac2              SUBS     r2,r0,r3              ;283
0000ce  6828              LDR      r0,[r5,#0]            ;283
0000d0  18c1              ADDS     r1,r0,r3              ;283
0000d2  4638              MOV      r0,r7                 ;283
0000d4  f7fffffe          BL       rt_memcpy
0000d8  88eb              LDRH     r3,[r5,#6]            ;285
0000da  eb030c06          ADD      r12,r3,r6             ;285
0000de  6ca3              LDR      r3,[r4,#0x48]         ;285
0000e0  f3c3238f          UBFX     r3,r3,#10,#16         ;285
0000e4  ebac0203          SUB      r2,r12,r3             ;285
0000e8  6ca3              LDR      r3,[r4,#0x48]         ;285
0000ea  f3c3238f          UBFX     r3,r3,#10,#16         ;285
0000ee  443b              ADD      r3,r3,r7              ;285
0000f0  f8b5c006          LDRH     r12,[r5,#6]           ;285
0000f4  eba3000c          SUB      r0,r3,r12             ;285
0000f8  6829              LDR      r1,[r5,#0]            ;285
0000fa  f7fffffe          BL       rt_memcpy
                  |L1.254|
0000fe  4631              MOV      r1,r6                 ;288
000100  4620              MOV      r0,r4                 ;288
000102  f7fffffe          BL       rt_dma_recv_update_get_index
000106  4650              MOV      r0,r10                ;289
000108  f7fffffe          BL       rt_hw_interrupt_enable
00010c  4630              MOV      r0,r6                 ;290
00010e  e7b1              B        |L1.116|
;;;293    
                          ENDP

                  |L1.272|
                          DCD      |symbol_number.62|
                  |L1.276|
000114  28736572          DCB      "(serial != RT_NULL) && (data != RT_NULL)",0
000118  69616c20
00011c  213d2052
000120  545f4e55
000124  4c4c2920
000128  26262028
00012c  64617461
000130  20213d20
000134  52545f4e
000138  554c4c29
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L1.320|
000140  72785f64          DCB      "rx_dma != RT_NULL",0
000144  6d612021
000148  3d205254
00014c  5f4e554c
000150  4c00    
000152  00                DCB      0
000153  00                DCB      0
                  |L1.340|
000154  73657269          DCB      "serial->ops->dma_transmit != RT_NULL",0
000158  616c2d3e
00015c  6f70732d
000160  3e646d61
000164  5f747261
000168  6e736d69
00016c  7420213d
000170  2052545f
000174  4e554c4c
000178  00      
000179  00                DCB      0
00017a  00                DCB      0
00017b  00                DCB      0
                  |L1.380|
00017c  72785f66          DCB      "rx_fifo != RT_NULL",0
000180  69666f20
000184  213d2052
000188  545f4e55
00018c  4c4c00  
00018f  00                DCB      0

                          AREA ||i._serial_dma_tx||, CODE, READONLY, ALIGN=1

                  _serial_dma_tx PROC
;;;293    
;;;294    rt_inline int _serial_dma_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;295    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;296        rt_base_t level;
;;;297        rt_err_t result;
;;;298        struct rt_serial_tx_dma *tx_dma;
;;;299    
;;;300        tx_dma = (struct rt_serial_tx_dma*)(serial->serial_tx);
00000a  6d25              LDR      r5,[r4,#0x50]
;;;301    
;;;302        result = rt_data_queue_push(&(tx_dma->data_queue), data, length, RT_WAITING_FOREVER);
00000c  f04f33ff          MOV      r3,#0xffffffff
000010  4632              MOV      r2,r6
000012  4641              MOV      r1,r8
000014  1d28              ADDS     r0,r5,#4
000016  f7fffffe          BL       rt_data_queue_push
00001a  4607              MOV      r7,r0
;;;303        if (result == RT_EOK)
00001c  b9cf              CBNZ     r7,|L2.82|
;;;304        {
;;;305            level = rt_hw_interrupt_disable();
00001e  f7fffffe          BL       rt_hw_interrupt_disable
000022  4681              MOV      r9,r0
;;;306            if (tx_dma->activated != RT_TRUE)
000024  6828              LDR      r0,[r5,#0]
000026  2801              CMP      r0,#1
000028  d00d              BEQ      |L2.70|
;;;307            {
;;;308                tx_dma->activated = RT_TRUE;
00002a  2001              MOVS     r0,#1
00002c  6028              STR      r0,[r5,#0]
;;;309                rt_hw_interrupt_enable(level);
00002e  4648              MOV      r0,r9
000030  f7fffffe          BL       rt_hw_interrupt_enable
;;;310    
;;;311                /* make a DMA transfer */
;;;312                serial->ops->dma_transmit(serial, (rt_uint8_t *)data, length, RT_SERIAL_DMA_TX);
000034  6c20              LDR      r0,[r4,#0x40]
000036  2302              MOVS     r3,#2
000038  4632              MOV      r2,r6
00003a  4641              MOV      r1,r8
00003c  f8d0c010          LDR      r12,[r0,#0x10]
000040  4620              MOV      r0,r4
000042  47e0              BLX      r12
000044  e002              B        |L2.76|
                  |L2.70|
;;;313            }
;;;314            else
;;;315            {
;;;316                rt_hw_interrupt_enable(level);
000046  4648              MOV      r0,r9
000048  f7fffffe          BL       rt_hw_interrupt_enable
                  |L2.76|
;;;317            }
;;;318    
;;;319            return length;
00004c  4630              MOV      r0,r6
                  |L2.78|
;;;320        }
;;;321        else
;;;322        {
;;;323            rt_set_errno(result);
;;;324            return 0;
;;;325        }
;;;326    }
00004e  e8bd87f0          POP      {r4-r10,pc}
                  |L2.82|
000052  4638              MOV      r0,r7                 ;323
000054  f7fffffe          BL       rt_set_errno
000058  2000              MOVS     r0,#0                 ;324
00005a  e7f8              B        |L2.78|
;;;327    
                          ENDP


                          AREA ||i._serial_int_rx||, CODE, READONLY, ALIGN=2

                  _serial_int_rx PROC
;;;94      */
;;;95     rt_inline int _serial_int_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;96     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;97         int size;
;;;98         struct rt_serial_rx_fifo* rx_fifo;
;;;99     
;;;100        RT_ASSERT(serial != RT_NULL);
00000a  b926              CBNZ     r6,|L3.22|
00000c  2264              MOVS     r2,#0x64
00000e  491b              LDR      r1,|L3.124|
000010  481b              LDR      r0,|L3.128|
000012  f7fffffe          BL       rt_assert_handler
                  |L3.22|
;;;101        size = length;
000016  46a8              MOV      r8,r5
;;;102    
;;;103        rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
000018  6cf4              LDR      r4,[r6,#0x4c]
;;;104        RT_ASSERT(rx_fifo != RT_NULL);
00001a  b924              CBNZ     r4,|L3.38|
00001c  2268              MOVS     r2,#0x68
00001e  4917              LDR      r1,|L3.124|
000020  a018              ADR      r0,|L3.132|
000022  f7fffffe          BL       rt_assert_handler
                  |L3.38|
;;;105    
;;;106        /* read from software FIFO */
;;;107        while (length)
000026  e022              B        |L3.110|
                  |L3.40|
;;;108        {
;;;109            int ch;
;;;110            rt_base_t level;
;;;111    
;;;112            /* disable interrupt */
;;;113            level = rt_hw_interrupt_disable();
000028  f7fffffe          BL       rt_hw_interrupt_disable
00002c  4682              MOV      r10,r0
;;;114            if (rx_fifo->get_index != rx_fifo->put_index)
00002e  88e0              LDRH     r0,[r4,#6]
000030  88a1              LDRH     r1,[r4,#4]
000032  4288              CMP      r0,r1
000034  d00f              BEQ      |L3.86|
;;;115            {
;;;116                ch = rx_fifo->buffer[rx_fifo->get_index];
000036  88e1              LDRH     r1,[r4,#6]
000038  6820              LDR      r0,[r4,#0]
00003a  f8109001          LDRB     r9,[r0,r1]
;;;117                rx_fifo->get_index += 1;
00003e  88e0              LDRH     r0,[r4,#6]
000040  1c40              ADDS     r0,r0,#1
000042  80e0              STRH     r0,[r4,#6]
;;;118                if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
000044  88e1              LDRH     r1,[r4,#6]
000046  6cb0              LDR      r0,[r6,#0x48]
000048  f3c0208f          UBFX     r0,r0,#10,#16
00004c  4281              CMP      r1,r0
00004e  db06              BLT      |L3.94|
000050  2000              MOVS     r0,#0
000052  80e0              STRH     r0,[r4,#6]
000054  e003              B        |L3.94|
                  |L3.86|
;;;119            }
;;;120            else
;;;121            {
;;;122                /* no data, enable interrupt and break out */
;;;123                rt_hw_interrupt_enable(level);
000056  4650              MOV      r0,r10
000058  f7fffffe          BL       rt_hw_interrupt_enable
;;;124                break;
00005c  e009              B        |L3.114|
                  |L3.94|
;;;125            }
;;;126    
;;;127            /* enable interrupt */
;;;128            rt_hw_interrupt_enable(level);
00005e  4650              MOV      r0,r10
000060  f7fffffe          BL       rt_hw_interrupt_enable
;;;129    
;;;130            *data = ch & 0xff;
000064  f8879000          STRB     r9,[r7,#0]
;;;131            data ++; length --;
000068  1c7f              ADDS     r7,r7,#1
00006a  1e6d              SUBS     r5,r5,#1
;;;132        }
00006c  bf00              NOP      
                  |L3.110|
00006e  2d00              CMP      r5,#0                 ;107
000070  d1da              BNE      |L3.40|
                  |L3.114|
000072  bf00              NOP                            ;124
;;;133    
;;;134        return size - length;
000074  eba80005          SUB      r0,r8,r5
;;;135    }
000078  e8bd87f0          POP      {r4-r10,pc}
;;;136    
                          ENDP

                  |L3.124|
                          DCD      |symbol_number.57|
                  |L3.128|
                          DCD      ||i._serial_poll_rx||+0x48
                  |L3.132|
000084  72785f66          DCB      "rx_fifo != RT_NULL",0
000088  69666f20
00008c  213d2052
000090  545f4e55
000094  4c4c00  
000097  00                DCB      0

                          AREA ||i._serial_int_tx||, CODE, READONLY, ALIGN=2

                  _serial_int_tx PROC
;;;136    
;;;137    rt_inline int _serial_int_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;138    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;139        int size;
;;;140        struct rt_serial_tx_fifo *tx;
;;;141    
;;;142        RT_ASSERT(serial != RT_NULL);
00000a  b925              CBNZ     r5,|L4.22|
00000c  228e              MOVS     r2,#0x8e
00000e  4911              LDR      r1,|L4.84|
000010  4811              LDR      r0,|L4.88|
000012  f7fffffe          BL       rt_assert_handler
                  |L4.22|
;;;143    
;;;144        size = length;
000016  46a0              MOV      r8,r4
;;;145        tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
000018  6d2f              LDR      r7,[r5,#0x50]
;;;146        RT_ASSERT(tx != RT_NULL);
00001a  b927              CBNZ     r7,|L4.38|
00001c  2292              MOVS     r2,#0x92
00001e  490d              LDR      r1,|L4.84|
000020  a00e              ADR      r0,|L4.92|
000022  f7fffffe          BL       rt_assert_handler
                  |L4.38|
;;;147    
;;;148        while (length)
000026  e00f              B        |L4.72|
                  |L4.40|
;;;149        {
;;;150            if (serial->ops->putc(serial, *(char*)data) == -1)
000028  7831              LDRB     r1,[r6,#0]
00002a  6c28              LDR      r0,[r5,#0x40]
00002c  6882              LDR      r2,[r0,#8]
00002e  4628              MOV      r0,r5
000030  4790              BLX      r2
000032  1c40              ADDS     r0,r0,#1
000034  b928              CBNZ     r0,|L4.66|
;;;151            {
;;;152                rt_completion_wait(&(tx->completion), RT_WAITING_FOREVER);
000036  f04f31ff          MOV      r1,#0xffffffff
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       rt_completion_wait
;;;153                continue;
000040  e002              B        |L4.72|
                  |L4.66|
;;;154            }
;;;155    
;;;156            data ++; length --;
000042  1c76              ADDS     r6,r6,#1
000044  1e64              SUBS     r4,r4,#1
000046  bf00              NOP                            ;153
                  |L4.72|
000048  2c00              CMP      r4,#0                 ;148
00004a  d1ed              BNE      |L4.40|
;;;157        }
;;;158    
;;;159        return size - length;
00004c  eba80004          SUB      r0,r8,r4
;;;160    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;161    
                          ENDP

                  |L4.84|
                          DCD      |symbol_number.58|
                  |L4.88|
                          DCD      ||i._serial_poll_rx||+0x48
                  |L4.92|
00005c  74782021          DCB      "tx != RT_NULL",0
000060  3d205254
000064  5f4e554c
000068  4c00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i._serial_poll_rx||, CODE, READONLY, ALIGN=2

                  _serial_poll_rx PROC
;;;43      */
;;;44     rt_inline int _serial_poll_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;45     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;46         int ch;
;;;47         int size;
;;;48     
;;;49         RT_ASSERT(serial != RT_NULL);
00000a  b926              CBNZ     r6,|L5.22|
00000c  2231              MOVS     r2,#0x31
00000e  490d              LDR      r1,|L5.68|
000010  a00d              ADR      r0,|L5.72|
000012  f7fffffe          BL       rt_assert_handler
                  |L5.22|
;;;50         size = length;
000016  46a0              MOV      r8,r4
;;;51     
;;;52         while (length)
000018  e00d              B        |L5.54|
                  |L5.26|
;;;53         {
;;;54             ch = serial->ops->getc(serial);
00001a  6c30              LDR      r0,[r6,#0x40]
00001c  68c1              LDR      r1,[r0,#0xc]
00001e  4630              MOV      r0,r6
000020  4788              BLX      r1
000022  4605              MOV      r5,r0
;;;55             if (ch == -1) break;
000024  1c68              ADDS     r0,r5,#1
000026  b900              CBNZ     r0,|L5.42|
000028  e007              B        |L5.58|
                  |L5.42|
;;;56     
;;;57             *data = ch;
00002a  703d              STRB     r5,[r7,#0]
;;;58             data ++; length --;
00002c  1c7f              ADDS     r7,r7,#1
00002e  1e64              SUBS     r4,r4,#1
;;;59     
;;;60             if (ch == '\n') break;
000030  2d0a              CMP      r5,#0xa
000032  d100              BNE      |L5.54|
000034  e001              B        |L5.58|
                  |L5.54|
000036  2c00              CMP      r4,#0                 ;52
000038  d1ef              BNE      |L5.26|
                  |L5.58|
00003a  bf00              NOP                            ;55
;;;61         }
;;;62     
;;;63         return size - length;
00003c  eba80004          SUB      r0,r8,r4
;;;64     }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;65     
                          ENDP

                  |L5.68|
                          DCD      __FUNCTION__
                  |L5.72|
000048  73657269          DCB      "serial != RT_NULL",0
00004c  616c2021
000050  3d205254
000054  5f4e554c
000058  4c00    
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i._serial_poll_tx||, CODE, READONLY, ALIGN=2

                  _serial_poll_tx PROC
;;;65     
;;;66     rt_inline int _serial_poll_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;67     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;68         int size;
;;;69         RT_ASSERT(serial != RT_NULL);
00000a  b924              CBNZ     r4,|L6.22|
00000c  2245              MOVS     r2,#0x45
00000e  490f              LDR      r1,|L6.76|
000010  480f              LDR      r0,|L6.80|
000012  f7fffffe          BL       rt_assert_handler
                  |L6.22|
;;;70     
;;;71         size = length;
000016  462f              MOV      r7,r5
;;;72         while (length)
000018  e012              B        |L6.64|
                  |L6.26|
;;;73         {
;;;74             /*
;;;75              * to be polite with serial console add a line feed
;;;76              * to the carriage return character
;;;77              */
;;;78             if (*data == '\n' && (serial->parent.open_flag & RT_DEVICE_FLAG_STREAM))
00001a  7830              LDRB     r0,[r6,#0]
00001c  280a              CMP      r0,#0xa
00001e  d108              BNE      |L6.50|
000020  7e20              LDRB     r0,[r4,#0x18]
000022  f0000040          AND      r0,r0,#0x40
000026  b120              CBZ      r0,|L6.50|
;;;79             {
;;;80                 serial->ops->putc(serial, '\r');
000028  6c20              LDR      r0,[r4,#0x40]
00002a  210d              MOVS     r1,#0xd
00002c  6882              LDR      r2,[r0,#8]
00002e  4620              MOV      r0,r4
000030  4790              BLX      r2
                  |L6.50|
;;;81             }
;;;82     
;;;83             serial->ops->putc(serial, *data);
000032  7831              LDRB     r1,[r6,#0]
000034  6c20              LDR      r0,[r4,#0x40]
000036  6882              LDR      r2,[r0,#8]
000038  4620              MOV      r0,r4
00003a  4790              BLX      r2
;;;84     
;;;85             ++ data;
00003c  1c76              ADDS     r6,r6,#1
;;;86             -- length;
00003e  1e6d              SUBS     r5,r5,#1
                  |L6.64|
000040  2d00              CMP      r5,#0                 ;72
000042  d1ea              BNE      |L6.26|
;;;87         }
;;;88     
;;;89         return size - length;
000044  1b78              SUBS     r0,r7,r5
;;;90     }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;91     
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      |symbol_number.56|
                  |L6.80|
                          DCD      ||i._serial_poll_rx||+0x48

                          AREA ||i.rt_dma_calc_recved_len||, CODE, READONLY, ALIGN=2

                  rt_dma_calc_recved_len PROC
;;;168     */
;;;169    static rt_size_t rt_dma_calc_recved_len(struct rt_serial_device *serial) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;170        static rt_size_t rx_length;
;;;171        struct rt_serial_rx_fifo *rx_fifo = (struct rt_serial_rx_fifo *)serial->serial_rx;
000004  6cec              LDR      r4,[r5,#0x4c]
;;;172    
;;;173        RT_ASSERT(rx_fifo != RT_NULL);
000006  b924              CBNZ     r4,|L7.18|
000008  22ad              MOVS     r2,#0xad
00000a  490c              LDR      r1,|L7.60|
00000c  a00c              ADR      r0,|L7.64|
00000e  f7fffffe          BL       rt_assert_handler
                  |L7.18|
;;;174    
;;;175        rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
000012  88a0              LDRH     r0,[r4,#4]
000014  88e1              LDRH     r1,[r4,#6]
000016  4288              CMP      r0,r1
000018  db03              BLT      |L7.34|
00001a  88a0              LDRH     r0,[r4,#4]
00001c  88e1              LDRH     r1,[r4,#6]
00001e  1a40              SUBS     r0,r0,r1
000020  e006              B        |L7.48|
                  |L7.34|
;;;176                            (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
000022  88e0              LDRH     r0,[r4,#6]
000024  88a1              LDRH     r1,[r4,#4]
000026  1a41              SUBS     r1,r0,r1
000028  6ca8              LDR      r0,[r5,#0x48]
00002a  f3c0208f          UBFX     r0,r0,#10,#16
00002e  1a40              SUBS     r0,r0,r1
                  |L7.48|
000030  4908              LDR      r1,|L7.84|
000032  6008              STR      r0,[r1,#0]  ; rx_length
;;;177        return rx_length;
000034  4608              MOV      r0,r1
000036  6800              LDR      r0,[r0,#0]  ; rx_length
;;;178    }
000038  bd70              POP      {r4-r6,pc}
;;;179    
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      |symbol_number.59|
                  |L7.64|
000040  72785f66          DCB      "rx_fifo != RT_NULL",0
000044  69666f20
000048  213d2052
00004c  545f4e55
000050  4c4c00  
000053  00                DCB      0
                  |L7.84|
                          DCD      rx_length

                          AREA ||i.rt_dma_recv_update_get_index||, CODE, READONLY, ALIGN=2

                  rt_dma_recv_update_get_index PROC
;;;185     */
;;;186    static void rt_dma_recv_update_get_index(struct rt_serial_device *serial, rt_size_t len) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;187        struct rt_serial_rx_fifo *rx_fifo = (struct rt_serial_rx_fifo *)serial->serial_rx;
000006  6cec              LDR      r4,[r5,#0x4c]
;;;188    
;;;189        RT_ASSERT(rx_fifo != RT_NULL);
000008  b924              CBNZ     r4,|L8.20|
00000a  22bd              MOVS     r2,#0xbd
00000c  490e              LDR      r1,|L8.72|
00000e  a00f              ADR      r0,|L8.76|
000010  f7fffffe          BL       rt_assert_handler
                  |L8.20|
;;;190        RT_ASSERT(len <= rt_dma_calc_recved_len(serial));
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       rt_dma_calc_recved_len
00001a  42b0              CMP      r0,r6
00001c  d204              BCS      |L8.40|
00001e  22be              MOVS     r2,#0xbe
000020  4909              LDR      r1,|L8.72|
000022  a00f              ADR      r0,|L8.96|
000024  f7fffffe          BL       rt_assert_handler
                  |L8.40|
;;;191    
;;;192        rx_fifo->get_index += len;
000028  88e0              LDRH     r0,[r4,#6]
00002a  4430              ADD      r0,r0,r6
00002c  80e0              STRH     r0,[r4,#6]
;;;193        if (rx_fifo->get_index > serial->config.bufsz ) {
00002e  88e1              LDRH     r1,[r4,#6]
000030  6ca8              LDR      r0,[r5,#0x48]
000032  f3c0208f          UBFX     r0,r0,#10,#16
000036  4281              CMP      r1,r0
000038  dd04              BLE      |L8.68|
;;;194            rx_fifo->get_index -= serial->config.bufsz;
00003a  88e1              LDRH     r1,[r4,#6]
00003c  6ca8              LDR      r0,[r5,#0x48]
00003e  eba12090          SUB      r0,r1,r0,LSR #10
000042  80e0              STRH     r0,[r4,#6]
                  |L8.68|
;;;195        }
;;;196    }
000044  bd70              POP      {r4-r6,pc}
;;;197    
                          ENDP

000046  0000              DCW      0x0000
                  |L8.72|
                          DCD      |symbol_number.60|
                  |L8.76|
00004c  72785f66          DCB      "rx_fifo != RT_NULL",0
000050  69666f20
000054  213d2052
000058  545f4e55
00005c  4c4c00  
00005f  00                DCB      0
                  |L8.96|
000060  6c656e20          DCB      "len <= rt_dma_calc_recved_len(serial)",0
000064  3c3d2072
000068  745f646d
00006c  615f6361
000070  6c635f72
000074  65637665
000078  645f6c65
00007c  6e287365
000080  7269616c
000084  2900    
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.rt_dma_recv_update_put_index||, CODE, READONLY, ALIGN=2

                  rt_dma_recv_update_put_index PROC
;;;203     */
;;;204    static void rt_dma_recv_update_put_index(struct rt_serial_device *serial, rt_size_t len) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;205        struct rt_serial_rx_fifo *rx_fifo = (struct rt_serial_rx_fifo *)serial->serial_rx;
000008  6cec              LDR      r4,[r5,#0x4c]
;;;206        rt_size_t i;
;;;207    
;;;208        RT_ASSERT(rx_fifo != RT_NULL);
00000a  b924              CBNZ     r4,|L9.22|
00000c  22d0              MOVS     r2,#0xd0
00000e  4924              LDR      r1,|L9.160|
000010  a024              ADR      r0,|L9.164|
000012  f7fffffe          BL       rt_assert_handler
                  |L9.22|
;;;209    
;;;210        if (rx_fifo->get_index <= rx_fifo->put_index) {
000016  88e0              LDRH     r0,[r4,#6]
000018  88a1              LDRH     r1,[r4,#4]
00001a  4288              CMP      r0,r1
00001c  dc1f              BGT      |L9.94|
;;;211            rx_fifo->put_index += len;
00001e  88a0              LDRH     r0,[r4,#4]
000020  4438              ADD      r0,r0,r7
000022  80a0              STRH     r0,[r4,#4]
;;;212            /* beyond the fifo end */
;;;213            if (rx_fifo->put_index >= serial->config.bufsz) {
000024  88a1              LDRH     r1,[r4,#4]
000026  6ca8              LDR      r0,[r5,#0x48]
000028  f3c0208f          UBFX     r0,r0,#10,#16
00002c  4281              CMP      r1,r0
00002e  db35              BLT      |L9.156|
;;;214                for (i = 0; i <= len / serial->config.bufsz; i++) {
000030  2600              MOVS     r6,#0
000032  e005              B        |L9.64|
                  |L9.52|
;;;215                    rx_fifo->put_index -= serial->config.bufsz;
000034  88a1              LDRH     r1,[r4,#4]
000036  6ca8              LDR      r0,[r5,#0x48]
000038  eba12090          SUB      r0,r1,r0,LSR #10
00003c  80a0              STRH     r0,[r4,#4]
00003e  1c76              ADDS     r6,r6,#1              ;214
                  |L9.64|
000040  6ca8              LDR      r0,[r5,#0x48]         ;214
000042  f3c0208f          UBFX     r0,r0,#10,#16         ;214
000046  fbb7f0f0          UDIV     r0,r7,r0              ;214
00004a  42b0              CMP      r0,r6                 ;214
00004c  d2f2              BCS      |L9.52|
;;;216                }
;;;217                /* force overwrite get index */
;;;218                if (rx_fifo->put_index >= rx_fifo->get_index) {
00004e  88a0              LDRH     r0,[r4,#4]
000050  88e1              LDRH     r1,[r4,#6]
000052  4288              CMP      r0,r1
000054  db22              BLT      |L9.156|
;;;219                    rx_fifo->get_index = rx_fifo->put_index + 1;
000056  88a0              LDRH     r0,[r4,#4]
000058  1c40              ADDS     r0,r0,#1
00005a  80e0              STRH     r0,[r4,#6]
00005c  e01e              B        |L9.156|
                  |L9.94|
;;;220                }
;;;221            }
;;;222        } else {
;;;223            rx_fifo->put_index += len;
00005e  88a0              LDRH     r0,[r4,#4]
000060  4438              ADD      r0,r0,r7
000062  80a0              STRH     r0,[r4,#4]
;;;224            if(rx_fifo->put_index >= rx_fifo->get_index) {
000064  88a0              LDRH     r0,[r4,#4]
000066  88e1              LDRH     r1,[r4,#6]
000068  4288              CMP      r0,r1
00006a  db17              BLT      |L9.156|
;;;225                /* beyond the fifo end */
;;;226                if(rx_fifo->put_index >= serial->config.bufsz) {
00006c  88a1              LDRH     r1,[r4,#4]
00006e  6ca8              LDR      r0,[r5,#0x48]
000070  f3c0208f          UBFX     r0,r0,#10,#16
000074  4281              CMP      r1,r0
000076  db0e              BLT      |L9.150|
;;;227                    for (i = 0; i <= len / serial->config.bufsz; i++) {
000078  2600              MOVS     r6,#0
00007a  e005              B        |L9.136|
                  |L9.124|
;;;228                        rx_fifo->put_index -= serial->config.bufsz;
00007c  88a1              LDRH     r1,[r4,#4]
00007e  6ca8              LDR      r0,[r5,#0x48]
000080  eba12090          SUB      r0,r1,r0,LSR #10
000084  80a0              STRH     r0,[r4,#4]
000086  1c76              ADDS     r6,r6,#1              ;227
                  |L9.136|
000088  6ca8              LDR      r0,[r5,#0x48]         ;227
00008a  f3c0208f          UBFX     r0,r0,#10,#16         ;227
00008e  fbb7f0f0          UDIV     r0,r7,r0              ;227
000092  42b0              CMP      r0,r6                 ;227
000094  d2f2              BCS      |L9.124|
                  |L9.150|
;;;229                    }
;;;230                }
;;;231                /* force overwrite get index */
;;;232                rx_fifo->get_index = rx_fifo->put_index + 1;
000096  88a0              LDRH     r0,[r4,#4]
000098  1c40              ADDS     r0,r0,#1
00009a  80e0              STRH     r0,[r4,#6]
                  |L9.156|
;;;233            }
;;;234        }
;;;235    }
00009c  e8bd81f0          POP      {r4-r8,pc}
;;;236    
                          ENDP

                  |L9.160|
                          DCD      |symbol_number.61|
                  |L9.164|
0000a4  72785f66          DCB      "rx_fifo != RT_NULL",0
0000a8  69666f20
0000ac  213d2052
0000b0  545f4e55
0000b4  4c4c00  
0000b7  00                DCB      0

                          AREA ||i.rt_hw_serial_isr||, CODE, READONLY, ALIGN=2

                  rt_hw_serial_isr PROC
;;;659    /* ISR for serial interrupt */
;;;660    void rt_hw_serial_isr(struct rt_serial_device *serial, int event)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;661    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;662        switch (event & 0xff)
000008  b2f0              UXTB     r0,r6
00000a  2801              CMP      r0,#1
00000c  d006              BEQ      |L10.28|
00000e  2802              CMP      r0,#2
000010  d05a              BEQ      |L10.200|
000012  2803              CMP      r0,#3
000014  d07e              BEQ      |L10.276|
000016  2804              CMP      r0,#4
000018  d155              BNE      |L10.198|
00001a  e05a              B        |L10.210|
                  |L10.28|
;;;663        {
;;;664            case RT_SERIAL_EVENT_RX_IND:
;;;665            {
;;;666                int ch = -1;
00001c  f04f37ff          MOV      r7,#0xffffffff
;;;667                rt_base_t level;
;;;668                struct rt_serial_rx_fifo* rx_fifo;
;;;669    
;;;670                /* interrupt mode receive */
;;;671                rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
000020  6ce5              LDR      r5,[r4,#0x4c]
;;;672                RT_ASSERT(rx_fifo != RT_NULL);
000022  b92d              CBNZ     r5,|L10.48|
000024  f44f7228          MOV      r2,#0x2a0
000028  4951              LDR      r1,|L10.368|
00002a  a052              ADR      r0,|L10.372|
00002c  f7fffffe          BL       rt_assert_handler
                  |L10.48|
;;;673    
;;;674                while (1)
000030  e02a              B        |L10.136|
                  |L10.50|
;;;675                {
;;;676                    ch = serial->ops->getc(serial);
000032  6c20              LDR      r0,[r4,#0x40]
000034  68c1              LDR      r1,[r0,#0xc]
000036  4620              MOV      r0,r4
000038  4788              BLX      r1
00003a  4607              MOV      r7,r0
;;;677                    if (ch == -1) break;
00003c  1c78              ADDS     r0,r7,#1
00003e  b900              CBNZ     r0,|L10.66|
000040  e023              B        |L10.138|
                  |L10.66|
;;;678    
;;;679    
;;;680                    /* disable interrupt */
;;;681                    level = rt_hw_interrupt_disable();
000042  f7fffffe          BL       rt_hw_interrupt_disable
000046  4681              MOV      r9,r0
;;;682    
;;;683                    rx_fifo->buffer[rx_fifo->put_index] = ch;
000048  88aa              LDRH     r2,[r5,#4]
00004a  6829              LDR      r1,[r5,#0]
00004c  548f              STRB     r7,[r1,r2]
;;;684                    rx_fifo->put_index += 1;
00004e  88a8              LDRH     r0,[r5,#4]
000050  1c40              ADDS     r0,r0,#1
000052  80a8              STRH     r0,[r5,#4]
;;;685                    if (rx_fifo->put_index >= serial->config.bufsz) rx_fifo->put_index = 0;
000054  88a9              LDRH     r1,[r5,#4]
000056  6ca0              LDR      r0,[r4,#0x48]
000058  f3c0208f          UBFX     r0,r0,#10,#16
00005c  4281              CMP      r1,r0
00005e  db01              BLT      |L10.100|
000060  2000              MOVS     r0,#0
000062  80a8              STRH     r0,[r5,#4]
                  |L10.100|
;;;686    
;;;687                    /* if the next position is read index, discard this 'read char' */
;;;688                    if (rx_fifo->put_index == rx_fifo->get_index)
000064  88a8              LDRH     r0,[r5,#4]
000066  88e9              LDRH     r1,[r5,#6]
000068  4288              CMP      r0,r1
00006a  d10a              BNE      |L10.130|
;;;689                    {
;;;690                        rx_fifo->get_index += 1;
00006c  88e8              LDRH     r0,[r5,#6]
00006e  1c40              ADDS     r0,r0,#1
000070  80e8              STRH     r0,[r5,#6]
;;;691                        if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
000072  88e9              LDRH     r1,[r5,#6]
000074  6ca0              LDR      r0,[r4,#0x48]
000076  f3c0208f          UBFX     r0,r0,#10,#16
00007a  4281              CMP      r1,r0
00007c  db01              BLT      |L10.130|
00007e  2000              MOVS     r0,#0
000080  80e8              STRH     r0,[r5,#6]
                  |L10.130|
;;;692                    }
;;;693    
;;;694                    /* enable interrupt */
;;;695                    rt_hw_interrupt_enable(level);
000082  4648              MOV      r0,r9
000084  f7fffffe          BL       rt_hw_interrupt_enable
                  |L10.136|
000088  e7d3              B        |L10.50|
                  |L10.138|
00008a  bf00              NOP                            ;677
;;;696                }
;;;697    
;;;698                /* invoke callback */
;;;699                if (serial->parent.rx_indicate != RT_NULL)
00008c  69e0              LDR      r0,[r4,#0x1c]
00008e  b1d0              CBZ      r0,|L10.198|
;;;700                {
;;;701                    rt_size_t rx_length;
;;;702    
;;;703                    /* get rx length */
;;;704                    level = rt_hw_interrupt_disable();
000090  f7fffffe          BL       rt_hw_interrupt_disable
000094  4681              MOV      r9,r0
;;;705                    rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
000096  88a8              LDRH     r0,[r5,#4]
000098  88e9              LDRH     r1,[r5,#6]
00009a  4288              CMP      r0,r1
00009c  db03              BLT      |L10.166|
00009e  88a8              LDRH     r0,[r5,#4]
0000a0  88e9              LDRH     r1,[r5,#6]
0000a2  1a40              SUBS     r0,r0,r1
0000a4  e006              B        |L10.180|
                  |L10.166|
;;;706                        (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
0000a6  88e8              LDRH     r0,[r5,#6]
0000a8  88a9              LDRH     r1,[r5,#4]
0000aa  1a41              SUBS     r1,r0,r1
0000ac  6ca0              LDR      r0,[r4,#0x48]
0000ae  f3c0208f          UBFX     r0,r0,#10,#16
0000b2  1a40              SUBS     r0,r0,r1
                  |L10.180|
0000b4  4680              MOV      r8,r0
;;;707                    rt_hw_interrupt_enable(level);
0000b6  4648              MOV      r0,r9
0000b8  f7fffffe          BL       rt_hw_interrupt_enable
;;;708    
;;;709                    serial->parent.rx_indicate(&serial->parent, rx_length);
0000bc  4641              MOV      r1,r8
0000be  4620              MOV      r0,r4
0000c0  69e2              LDR      r2,[r4,#0x1c]
0000c2  4790              BLX      r2
;;;710                }
0000c4  bf00              NOP      
                  |L10.198|
;;;711                break;
0000c6  e050              B        |L10.362|
                  |L10.200|
;;;712            }
;;;713            case RT_SERIAL_EVENT_TX_DONE:
;;;714            {
;;;715                struct rt_serial_tx_fifo* tx_fifo;
;;;716    
;;;717                tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_tx;
0000c8  6d25              LDR      r5,[r4,#0x50]
;;;718                rt_completion_done(&(tx_fifo->completion));
0000ca  4628              MOV      r0,r5
0000cc  f7fffffe          BL       rt_completion_done
;;;719                break;
0000d0  e04b              B        |L10.362|
                  |L10.210|
;;;720            }
;;;721            case RT_SERIAL_EVENT_TX_DMADONE:
;;;722            {
;;;723                const void *data_ptr;
;;;724                rt_size_t data_size;
;;;725                const void *last_data_ptr;
;;;726                struct rt_serial_tx_dma* tx_dma;
;;;727    
;;;728                tx_dma = (struct rt_serial_tx_dma*) serial->serial_tx;
0000d2  6d25              LDR      r5,[r4,#0x50]
;;;729    
;;;730                rt_data_queue_pop(&(tx_dma->data_queue), &last_data_ptr, &data_size, 0);
0000d4  2300              MOVS     r3,#0
0000d6  aa01              ADD      r2,sp,#4
0000d8  4669              MOV      r1,sp
0000da  1d28              ADDS     r0,r5,#4
0000dc  f7fffffe          BL       rt_data_queue_pop
;;;731                if (rt_data_queue_peak(&(tx_dma->data_queue), &data_ptr, &data_size) == RT_EOK)
0000e0  aa01              ADD      r2,sp,#4
0000e2  a902              ADD      r1,sp,#8
0000e4  1d28              ADDS     r0,r5,#4
0000e6  f7fffffe          BL       rt_data_queue_peak
0000ea  b950              CBNZ     r0,|L10.258|
;;;732                {
;;;733                    /* transmit next data node */
;;;734                    tx_dma->activated = RT_TRUE;
0000ec  2001              MOVS     r0,#1
0000ee  6028              STR      r0,[r5,#0]
;;;735                    serial->ops->dma_transmit(serial, (rt_uint8_t *)data_ptr, data_size, RT_SERIAL_DMA_TX);
0000f0  6c20              LDR      r0,[r4,#0x40]
0000f2  2302              MOVS     r3,#2
0000f4  6907              LDR      r7,[r0,#0x10]
0000f6  4620              MOV      r0,r4
0000f8  e9dd2101          LDRD     r2,r1,[sp,#4]
0000fc  47b8              BLX      r7
0000fe  e002              B        |L10.262|
000100  e008              B        |L10.276|
                  |L10.258|
;;;736                }
;;;737                else
;;;738                {
;;;739                    tx_dma->activated = RT_FALSE;
000102  2000              MOVS     r0,#0
000104  6028              STR      r0,[r5,#0]
                  |L10.262|
;;;740                }
;;;741    
;;;742                /* invoke callback */
;;;743                if (serial->parent.tx_complete != RT_NULL)
000106  6a20              LDR      r0,[r4,#0x20]
000108  b118              CBZ      r0,|L10.274|
;;;744                {
;;;745                    serial->parent.tx_complete(&serial->parent, (void*)last_data_ptr);
00010a  6a22              LDR      r2,[r4,#0x20]
00010c  4620              MOV      r0,r4
00010e  9900              LDR      r1,[sp,#0]
000110  4790              BLX      r2
                  |L10.274|
;;;746                }
;;;747                break;
000112  e02a              B        |L10.362|
                  |L10.276|
;;;748            }
;;;749            case RT_SERIAL_EVENT_RX_DMADONE:
;;;750            {
;;;751                int length;
;;;752    
;;;753                /* get DMA rx length */
;;;754                length = (event & (~0xff)) >> 8;
000114  1237              ASRS     r7,r6,#8
;;;755    
;;;756                if (serial->config.bufsz == 0) {
000116  6ca0              LDR      r0,[r4,#0x48]
000118  f3c0208f          UBFX     r0,r0,#10,#16
00011c  b9b0              CBNZ     r0,|L10.332|
;;;757                    struct rt_serial_rx_dma* rx_dma;
;;;758    
;;;759                    rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
00011e  6ce5              LDR      r5,[r4,#0x4c]
;;;760                    RT_ASSERT(rx_dma != RT_NULL);
000120  b92d              CBNZ     r5,|L10.302|
000122  f44f723e          MOV      r2,#0x2f8
000126  4912              LDR      r1,|L10.368|
000128  a017              ADR      r0,|L10.392|
00012a  f7fffffe          BL       rt_assert_handler
                  |L10.302|
;;;761    
;;;762                    RT_ASSERT(serial->parent.rx_indicate != RT_NULL);
00012e  69e0              LDR      r0,[r4,#0x1c]
000130  b928              CBNZ     r0,|L10.318|
000132  f24022fa          MOV      r2,#0x2fa
000136  490e              LDR      r1,|L10.368|
000138  a018              ADR      r0,|L10.412|
00013a  f7fffffe          BL       rt_assert_handler
                  |L10.318|
;;;763                    serial->parent.rx_indicate(&(serial->parent), length);
00013e  4639              MOV      r1,r7
000140  4620              MOV      r0,r4
000142  69e2              LDR      r2,[r4,#0x1c]
000144  4790              BLX      r2
;;;764                    rx_dma->activated = RT_FALSE;
000146  2000              MOVS     r0,#0
000148  6028              STR      r0,[r5,#0]
;;;765                } else {
00014a  e00d              B        |L10.360|
                  |L10.332|
;;;766                    /* update fifo put index */
;;;767                    rt_dma_recv_update_put_index(serial, length);
00014c  4639              MOV      r1,r7
00014e  4620              MOV      r0,r4
000150  f7fffffe          BL       rt_dma_recv_update_put_index
;;;768                    /* invoke callback */
;;;769                    if (serial->parent.rx_indicate != RT_NULL) {
000154  69e0              LDR      r0,[r4,#0x1c]
000156  b138              CBZ      r0,|L10.360|
;;;770                        serial->parent.rx_indicate(&(serial->parent), rt_dma_calc_recved_len(serial));
000158  4620              MOV      r0,r4
00015a  f7fffffe          BL       rt_dma_calc_recved_len
00015e  4605              MOV      r5,r0
000160  4629              MOV      r1,r5
000162  4620              MOV      r0,r4
000164  69e2              LDR      r2,[r4,#0x1c]
000166  4790              BLX      r2
                  |L10.360|
;;;771                    }
;;;772                }
;;;773                break;
000168  bf00              NOP      
                  |L10.362|
00016a  bf00              NOP                            ;711
;;;774            }
;;;775        }
;;;776    }
00016c  e8bd83fe          POP      {r1-r9,pc}
                          ENDP

                  |L10.368|
                          DCD      |symbol_number.70|
                  |L10.372|
000174  72785f66          DCB      "rx_fifo != RT_NULL",0
000178  69666f20
00017c  213d2052
000180  545f4e55
000184  4c4c00  
000187  00                DCB      0
                  |L10.392|
000188  72785f64          DCB      "rx_dma != RT_NULL",0
00018c  6d612021
000190  3d205254
000194  5f4e554c
000198  4c00    
00019a  00                DCB      0
00019b  00                DCB      0
                  |L10.412|
00019c  73657269          DCB      "serial->parent.rx_indicate != RT_NULL",0
0001a0  616c2d3e
0001a4  70617265
0001a8  6e742e72
0001ac  785f696e
0001b0  64696361
0001b4  74652021
0001b8  3d205254
0001bc  5f4e554c
0001c0  4c00    
0001c2  00                DCB      0
0001c3  00                DCB      0

                          AREA ||i.rt_hw_serial_register||, CODE, READONLY, ALIGN=2

                  rt_hw_serial_register PROC
;;;632     */
;;;633    rt_err_t rt_hw_serial_register(struct rt_serial_device *serial,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;634                                   const char              *name,
;;;635                                   rt_uint32_t              flag,
;;;636                                   void                    *data)
;;;637    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;638        struct rt_device *device;
;;;639        RT_ASSERT(serial != RT_NULL);
00000c  b92c              CBNZ     r4,|L11.26|
00000e  f240227f          MOV      r2,#0x27f
000012  490e              LDR      r1,|L11.76|
000014  a00e              ADR      r0,|L11.80|
000016  f7fffffe          BL       rt_assert_handler
                  |L11.26|
;;;640    
;;;641        device = &(serial->parent);
00001a  4625              MOV      r5,r4
;;;642    
;;;643        device->type        = RT_Device_Class_Char;//.
00001c  2000              MOVS     r0,#0
00001e  7528              STRB     r0,[r5,#0x14]
;;;644        device->rx_indicate = RT_NULL;
000020  61e8              STR      r0,[r5,#0x1c]
;;;645        device->tx_complete = RT_NULL;
000022  6228              STR      r0,[r5,#0x20]
;;;646    
;;;647        device->init        = rt_serial_init;
000024  480f              LDR      r0,|L11.100|
000026  6268              STR      r0,[r5,#0x24]
;;;648        device->open        = rt_serial_open;
000028  480f              LDR      r0,|L11.104|
00002a  62a8              STR      r0,[r5,#0x28]
;;;649        device->close       = rt_serial_close;
00002c  480f              LDR      r0,|L11.108|
00002e  62e8              STR      r0,[r5,#0x2c]
;;;650        device->read        = rt_serial_read;
000030  480f              LDR      r0,|L11.112|
000032  6328              STR      r0,[r5,#0x30]
;;;651        device->write       = rt_serial_write;
000034  480f              LDR      r0,|L11.116|
000036  6368              STR      r0,[r5,#0x34]
;;;652        device->control     = rt_serial_control;
000038  480f              LDR      r0,|L11.120|
00003a  63a8              STR      r0,[r5,#0x38]
;;;653        device->user_data   = data;
00003c  63ef              STR      r7,[r5,#0x3c]
;;;654    
;;;655        /* register a character device */
;;;656        return rt_device_register(device, name, flag);
00003e  b2b2              UXTH     r2,r6
000040  4641              MOV      r1,r8
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       rt_device_register
;;;657    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;658    
                          ENDP

                  |L11.76|
                          DCD      |symbol_number.69|
                  |L11.80|
000050  73657269          DCB      "serial != RT_NULL",0
000054  616c2021
000058  3d205254
00005c  5f4e554c
000060  4c00    
000062  00                DCB      0
000063  00                DCB      0
                  |L11.100|
                          DCD      rt_serial_init
                  |L11.104|
                          DCD      rt_serial_open
                  |L11.108|
                          DCD      rt_serial_close
                  |L11.112|
                          DCD      rt_serial_read
                  |L11.116|
                          DCD      rt_serial_write
                  |L11.120|
                          DCD      rt_serial_control

                          AREA ||i.rt_serial_close||, CODE, READONLY, ALIGN=2

                  rt_serial_close PROC
;;;460    
;;;461    static rt_err_t rt_serial_close(struct rt_device *dev)
000000  b570              PUSH     {r4-r6,lr}
;;;462    {
000002  4604              MOV      r4,r0
;;;463        struct rt_serial_device *serial;
;;;464    
;;;465        RT_ASSERT(dev != RT_NULL);
000004  b92c              CBNZ     r4,|L12.18|
000006  f24012d1          MOV      r2,#0x1d1
00000a  4945              LDR      r1,|L12.288|
00000c  a045              ADR      r0,|L12.292|
00000e  f7fffffe          BL       rt_assert_handler
                  |L12.18|
;;;466        serial = (struct rt_serial_device *)dev;
000012  4625              MOV      r5,r4
;;;467    
;;;468        /* this device has more reference count */
;;;469        if (dev->ref_count > 1) return RT_EOK;
000014  7ea0              LDRB     r0,[r4,#0x1a]
000016  2801              CMP      r0,#1
000018  dd01              BLE      |L12.30|
00001a  2000              MOVS     r0,#0
                  |L12.28|
;;;470    
;;;471        if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
;;;472        {
;;;473            struct rt_serial_rx_fifo* rx_fifo;
;;;474    
;;;475            rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
;;;476            RT_ASSERT(rx_fifo != RT_NULL);
;;;477    
;;;478            rt_free(rx_fifo);
;;;479            serial->serial_rx = RT_NULL;
;;;480            dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
;;;481            /* configure low level device */
;;;482            serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_RX);
;;;483        }
;;;484        else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
;;;485        {
;;;486            if (serial->config.bufsz == 0) {
;;;487                struct rt_serial_rx_dma* rx_dma;
;;;488    
;;;489                rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
;;;490                RT_ASSERT(rx_dma != RT_NULL);
;;;491    
;;;492                rt_free(rx_dma);
;;;493            } else {
;;;494                struct rt_serial_rx_fifo* rx_fifo;
;;;495    
;;;496                rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
;;;497                RT_ASSERT(rx_fifo != RT_NULL);
;;;498    
;;;499                rt_free(rx_fifo);
;;;500            }
;;;501            /* configure low level device */
;;;502            serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void *) RT_DEVICE_FLAG_DMA_RX);
;;;503            serial->serial_rx = RT_NULL;
;;;504            dev->open_flag &= ~RT_DEVICE_FLAG_DMA_RX;
;;;505        }
;;;506    
;;;507        if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
;;;508        {
;;;509            struct rt_serial_tx_fifo* tx_fifo;
;;;510    
;;;511            tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_tx;
;;;512            RT_ASSERT(tx_fifo != RT_NULL);
;;;513    
;;;514            rt_free(tx_fifo);
;;;515            serial->serial_tx = RT_NULL;
;;;516            dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
;;;517            /* configure low level device */
;;;518            serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
;;;519        }
;;;520        else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
;;;521        {
;;;522            struct rt_serial_tx_dma* tx_dma;
;;;523    
;;;524            tx_dma = (struct rt_serial_tx_dma*)serial->serial_tx;
;;;525            RT_ASSERT(tx_dma != RT_NULL);
;;;526    
;;;527            rt_free(tx_dma);
;;;528            serial->serial_tx = RT_NULL;
;;;529            dev->open_flag &= ~RT_DEVICE_FLAG_DMA_TX;
;;;530        }
;;;531    
;;;532        return RT_EOK;
;;;533    }
00001c  bd70              POP      {r4-r6,pc}
                  |L12.30|
00001e  8b20              LDRH     r0,[r4,#0x18]         ;471
000020  f4007080          AND      r0,r0,#0x100          ;471
000024  b1c0              CBZ      r0,|L12.88|
000026  6cee              LDR      r6,[r5,#0x4c]         ;475
000028  b92e              CBNZ     r6,|L12.54|
00002a  f44f72ee          MOV      r2,#0x1dc             ;476
00002e  493c              LDR      r1,|L12.288|
000030  a040              ADR      r0,|L12.308|
000032  f7fffffe          BL       rt_assert_handler
                  |L12.54|
000036  4630              MOV      r0,r6                 ;478
000038  f7fffffe          BL       rt_free
00003c  2000              MOVS     r0,#0                 ;479
00003e  64e8              STR      r0,[r5,#0x4c]         ;479
000040  8b20              LDRH     r0,[r4,#0x18]         ;480
000042  f4207080          BIC      r0,r0,#0x100          ;480
000046  8320              STRH     r0,[r4,#0x18]         ;480
000048  6c28              LDR      r0,[r5,#0x40]         ;482
00004a  f44f7280          MOV      r2,#0x100             ;482
00004e  2111              MOVS     r1,#0x11              ;482
000050  6843              LDR      r3,[r0,#4]            ;482
000052  4628              MOV      r0,r5                 ;482
000054  4798              BLX      r3                    ;482
000056  e02d              B        |L12.180|
                  |L12.88|
000058  8b20              LDRH     r0,[r4,#0x18]         ;484
00005a  f4007000          AND      r0,r0,#0x200          ;484
00005e  2800              CMP      r0,#0                 ;484
000060  d028              BEQ      |L12.180|
000062  6ca8              LDR      r0,[r5,#0x48]         ;486
000064  f3c0208f          UBFX     r0,r0,#10,#16         ;486
000068  b958              CBNZ     r0,|L12.130|
00006a  6cee              LDR      r6,[r5,#0x4c]         ;489
00006c  b92e              CBNZ     r6,|L12.122|
00006e  f44f72f5          MOV      r2,#0x1ea             ;490
000072  492b              LDR      r1,|L12.288|
000074  a034              ADR      r0,|L12.328|
000076  f7fffffe          BL       rt_assert_handler
                  |L12.122|
00007a  4630              MOV      r0,r6                 ;492
00007c  f7fffffe          BL       rt_free
000080  e00b              B        |L12.154|
                  |L12.130|
000082  6cee              LDR      r6,[r5,#0x4c]         ;496
000084  b92e              CBNZ     r6,|L12.146|
000086  f24012f1          MOV      r2,#0x1f1             ;497
00008a  4925              LDR      r1,|L12.288|
00008c  a029              ADR      r0,|L12.308|
00008e  f7fffffe          BL       rt_assert_handler
                  |L12.146|
000092  4630              MOV      r0,r6                 ;499
000094  f7fffffe          BL       rt_free
000098  bf00              NOP                            ;500
                  |L12.154|
00009a  6c28              LDR      r0,[r5,#0x40]         ;502
00009c  f44f7200          MOV      r2,#0x200             ;502
0000a0  2111              MOVS     r1,#0x11              ;502
0000a2  6843              LDR      r3,[r0,#4]            ;502
0000a4  4628              MOV      r0,r5                 ;502
0000a6  4798              BLX      r3                    ;502
0000a8  2000              MOVS     r0,#0                 ;503
0000aa  64e8              STR      r0,[r5,#0x4c]         ;503
0000ac  8b20              LDRH     r0,[r4,#0x18]         ;504
0000ae  f4207000          BIC      r0,r0,#0x200          ;504
0000b2  8320              STRH     r0,[r4,#0x18]         ;504
                  |L12.180|
0000b4  8b20              LDRH     r0,[r4,#0x18]         ;507
0000b6  f4006080          AND      r0,r0,#0x400          ;507
0000ba  b1c0              CBZ      r0,|L12.238|
0000bc  6d2e              LDR      r6,[r5,#0x50]         ;511
0000be  b92e              CBNZ     r6,|L12.204|
0000c0  f44f7200          MOV      r2,#0x200             ;512
0000c4  4916              LDR      r1,|L12.288|
0000c6  a025              ADR      r0,|L12.348|
0000c8  f7fffffe          BL       rt_assert_handler
                  |L12.204|
0000cc  4630              MOV      r0,r6                 ;514
0000ce  f7fffffe          BL       rt_free
0000d2  2000              MOVS     r0,#0                 ;515
0000d4  6528              STR      r0,[r5,#0x50]         ;515
0000d6  8b20              LDRH     r0,[r4,#0x18]         ;516
0000d8  f4206080          BIC      r0,r0,#0x400          ;516
0000dc  8320              STRH     r0,[r4,#0x18]         ;516
0000de  6c28              LDR      r0,[r5,#0x40]         ;518
0000e0  f44f6280          MOV      r2,#0x400             ;518
0000e4  2111              MOVS     r1,#0x11              ;518
0000e6  6843              LDR      r3,[r0,#4]            ;518
0000e8  4628              MOV      r0,r5                 ;518
0000ea  4798              BLX      r3                    ;518
0000ec  e015              B        |L12.282|
                  |L12.238|
0000ee  8b20              LDRH     r0,[r4,#0x18]         ;520
0000f0  f4006000          AND      r0,r0,#0x800          ;520
0000f4  b188              CBZ      r0,|L12.282|
0000f6  6d2e              LDR      r6,[r5,#0x50]         ;524
0000f8  b92e              CBNZ     r6,|L12.262|
0000fa  f240220d          MOV      r2,#0x20d             ;525
0000fe  4908              LDR      r1,|L12.288|
000100  a01b              ADR      r0,|L12.368|
000102  f7fffffe          BL       rt_assert_handler
                  |L12.262|
000106  4630              MOV      r0,r6                 ;527
000108  f7fffffe          BL       rt_free
00010c  2000              MOVS     r0,#0                 ;528
00010e  6528              STR      r0,[r5,#0x50]         ;528
000110  8b20              LDRH     r0,[r4,#0x18]         ;529
000112  f4206000          BIC      r0,r0,#0x800          ;529
000116  8320              STRH     r0,[r4,#0x18]         ;529
000118  bf00              NOP                            ;530
                  |L12.282|
00011a  2000              MOVS     r0,#0                 ;532
00011c  e77e              B        |L12.28|
;;;534    
                          ENDP

00011e  0000              DCW      0x0000
                  |L12.288|
                          DCD      |symbol_number.65|
                  |L12.292|
000124  64657620          DCB      "dev != RT_NULL",0
000128  213d2052
00012c  545f4e55
000130  4c4c00  
000133  00                DCB      0
                  |L12.308|
000134  72785f66          DCB      "rx_fifo != RT_NULL",0
000138  69666f20
00013c  213d2052
000140  545f4e55
000144  4c4c00  
000147  00                DCB      0
                  |L12.328|
000148  72785f64          DCB      "rx_dma != RT_NULL",0
00014c  6d612021
000150  3d205254
000154  5f4e554c
000158  4c00    
00015a  00                DCB      0
00015b  00                DCB      0
                  |L12.348|
00015c  74785f66          DCB      "tx_fifo != RT_NULL",0
000160  69666f20
000164  213d2052
000168  545f4e55
00016c  4c4c00  
00016f  00                DCB      0
                  |L12.368|
000170  74785f64          DCB      "tx_dma != RT_NULL",0
000174  6d612021
000178  3d205254
00017c  5f4e554c
000180  4c00    
000182  00                DCB      0
000183  00                DCB      0

                          AREA ||i.rt_serial_control||, CODE, READONLY, ALIGN=2

                  rt_serial_control PROC
;;;584    
;;;585    static rt_err_t rt_serial_control(struct rt_device *dev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;586                                      rt_uint8_t        cmd,
;;;587                                      void             *args)
;;;588    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;589        struct rt_serial_device *serial;
;;;590    
;;;591        RT_ASSERT(dev != RT_NULL);
00000a  b92c              CBNZ     r4,|L13.24|
00000c  f240224f          MOV      r2,#0x24f
000010  4916              LDR      r1,|L13.108|
000012  a017              ADR      r0,|L13.112|
000014  f7fffffe          BL       rt_assert_handler
                  |L13.24|
;;;592        serial = (struct rt_serial_device *)dev;
000018  4625              MOV      r5,r4
;;;593    
;;;594        switch (cmd)
00001a  2f01              CMP      r7,#1
00001c  d009              BEQ      |L13.50|
00001e  2f02              CMP      r7,#2
000020  d002              BEQ      |L13.40|
000022  2f03              CMP      r7,#3
000024  d117              BNE      |L13.86|
000026  e009              B        |L13.60|
                  |L13.40|
;;;595        {
;;;596            case RT_DEVICE_CTRL_SUSPEND:
;;;597                /* suspend device */
;;;598                dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
000028  8ae0              LDRH     r0,[r4,#0x16]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  82e0              STRH     r0,[r4,#0x16]
;;;599                break;
000030  e018              B        |L13.100|
                  |L13.50|
;;;600    
;;;601            case RT_DEVICE_CTRL_RESUME:
;;;602                /* resume device */
;;;603                dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
000032  8ae0              LDRH     r0,[r4,#0x16]
000034  f0200020          BIC      r0,r0,#0x20
000038  82e0              STRH     r0,[r4,#0x16]
;;;604                break;
00003a  e013              B        |L13.100|
                  |L13.60|
;;;605    
;;;606            case RT_DEVICE_CTRL_CONFIG:
;;;607    			if (args)
00003c  b156              CBZ      r6,|L13.84|
;;;608    			{
;;;609    				/* set serial configure */
;;;610    				serial->config = *(struct serial_configure *)args;
00003e  e9d60100          LDRD     r0,r1,[r6,#0]
000042  e9c50111          STRD     r0,r1,[r5,#0x44]
;;;611    
;;;612    				if (dev->ref_count)
000046  7ea0              LDRB     r0,[r4,#0x1a]
000048  b120              CBZ      r0,|L13.84|
;;;613    				{
;;;614    		            /* serial device has been opened, to configure it */
;;;615    		            serial->ops->configure(serial, (struct serial_configure *)args);
00004a  6c28              LDR      r0,[r5,#0x40]
00004c  4631              MOV      r1,r6
00004e  6802              LDR      r2,[r0,#0]
000050  4628              MOV      r0,r5
000052  4790              BLX      r2
                  |L13.84|
;;;616    				}
;;;617    			}
;;;618    			
;;;619                break;
000054  e006              B        |L13.100|
                  |L13.86|
;;;620    
;;;621            default :
;;;622                /* control device */
;;;623                serial->ops->control(serial, cmd, args);
000056  6c28              LDR      r0,[r5,#0x40]
000058  4632              MOV      r2,r6
00005a  4639              MOV      r1,r7
00005c  6843              LDR      r3,[r0,#4]
00005e  4628              MOV      r0,r5
000060  4798              BLX      r3
;;;624                break;
000062  bf00              NOP      
                  |L13.100|
000064  bf00              NOP                            ;599
;;;625        }
;;;626    
;;;627        return RT_EOK;
000066  2000              MOVS     r0,#0
;;;628    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;629    
                          ENDP

                  |L13.108|
                          DCD      |symbol_number.68|
                  |L13.112|
000070  64657620          DCB      "dev != RT_NULL",0
000074  213d2052
000078  545f4e55
00007c  4c4c00  
00007f  00                DCB      0

                          AREA ||i.rt_serial_init||, CODE, READONLY, ALIGN=2

                  rt_serial_init PROC
;;;331     */
;;;332    static rt_err_t rt_serial_init(struct rt_device *dev)
000000  b570              PUSH     {r4-r6,lr}
;;;333    {
000002  4605              MOV      r5,r0
;;;334        rt_err_t result = RT_EOK;
000004  2600              MOVS     r6,#0
;;;335        struct rt_serial_device *serial;
;;;336    
;;;337        RT_ASSERT(dev != RT_NULL);
000006  b92d              CBNZ     r5,|L14.20|
000008  f2401251          MOV      r2,#0x151
00000c  4909              LDR      r1,|L14.52|
00000e  a00a              ADR      r0,|L14.56|
000010  f7fffffe          BL       rt_assert_handler
                  |L14.20|
;;;338        serial = (struct rt_serial_device *)dev;
000014  462c              MOV      r4,r5
;;;339    
;;;340        /* initialize rx/tx */
;;;341        serial->serial_rx = RT_NULL;
000016  2000              MOVS     r0,#0
000018  64e0              STR      r0,[r4,#0x4c]
;;;342        serial->serial_tx = RT_NULL;
00001a  6520              STR      r0,[r4,#0x50]
;;;343    
;;;344        /* apply configuration */
;;;345        if (serial->ops->configure)
00001c  6c20              LDR      r0,[r4,#0x40]
00001e  6800              LDR      r0,[r0,#0]
000020  b130              CBZ      r0,|L14.48|
;;;346            result = serial->ops->configure(serial, &serial->config);
000022  6c20              LDR      r0,[r4,#0x40]
000024  f1040144          ADD      r1,r4,#0x44
000028  6802              LDR      r2,[r0,#0]
00002a  4620              MOV      r0,r4
00002c  4790              BLX      r2
00002e  4606              MOV      r6,r0
                  |L14.48|
;;;347    
;;;348        return result;
000030  4630              MOV      r0,r6
;;;349    }
000032  bd70              POP      {r4-r6,pc}
;;;350    
                          ENDP

                  |L14.52|
                          DCD      |symbol_number.63|
                  |L14.56|
000038  64657620          DCB      "dev != RT_NULL",0
00003c  213d2052
000040  545f4e55
000044  4c4c00  
000047  00                DCB      0

                          AREA ||i.rt_serial_open||, CODE, READONLY, ALIGN=2

                  rt_serial_open PROC
;;;350    
;;;351    static rt_err_t rt_serial_open(struct rt_device *dev, rt_uint16_t oflag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;352    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;353        struct rt_serial_device *serial;
;;;354    
;;;355        RT_ASSERT(dev != RT_NULL);
000008  b92d              CBNZ     r5,|L15.22|
00000a  f2401263          MOV      r2,#0x163
00000e  4971              LDR      r1,|L15.468|
000010  a071              ADR      r0,|L15.472|
000012  f7fffffe          BL       rt_assert_handler
                  |L15.22|
;;;356        serial = (struct rt_serial_device *)dev;
000016  462c              MOV      r4,r5
;;;357    
;;;358        /* check device flag with the open flag */
;;;359        if ((oflag & RT_DEVICE_FLAG_DMA_RX) && !(dev->flag & RT_DEVICE_FLAG_DMA_RX))
000018  f4067000          AND      r0,r6,#0x200
00001c  b138              CBZ      r0,|L15.46|
00001e  8ae8              LDRH     r0,[r5,#0x16]
000020  f4007000          AND      r0,r0,#0x200
000024  b918              CBNZ     r0,|L15.46|
;;;360            return -RT_EIO;
000026  f06f0007          MVN      r0,#7
                  |L15.42|
;;;361        if ((oflag & RT_DEVICE_FLAG_DMA_TX) && !(dev->flag & RT_DEVICE_FLAG_DMA_TX))
;;;362            return -RT_EIO;
;;;363        if ((oflag & RT_DEVICE_FLAG_INT_RX) && !(dev->flag & RT_DEVICE_FLAG_INT_RX))
;;;364            return -RT_EIO;
;;;365        if ((oflag & RT_DEVICE_FLAG_INT_TX) && !(dev->flag & RT_DEVICE_FLAG_INT_TX))
;;;366            return -RT_EIO;
;;;367    
;;;368        /* get open flags */
;;;369        dev->open_flag = oflag & 0xff;
;;;370    
;;;371        /* initialize the Rx/Tx structure according to open flag */
;;;372        if (serial->serial_rx == RT_NULL)
;;;373        {
;;;374            if (oflag & RT_DEVICE_FLAG_DMA_RX)
;;;375            {
;;;376                if (serial->config.bufsz == 0) {
;;;377                    struct rt_serial_rx_dma* rx_dma;
;;;378    
;;;379                    rx_dma = (struct rt_serial_rx_dma*) rt_malloc (sizeof(struct rt_serial_rx_dma));
;;;380                    RT_ASSERT(rx_dma != RT_NULL);
;;;381                    rx_dma->activated = RT_FALSE;
;;;382    
;;;383                    serial->serial_rx = rx_dma;
;;;384                } else {
;;;385                    struct rt_serial_rx_fifo* rx_fifo;
;;;386    
;;;387                    rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) +
;;;388                        serial->config.bufsz);
;;;389                    RT_ASSERT(rx_fifo != RT_NULL);
;;;390                    rx_fifo->buffer = (rt_uint8_t*) (rx_fifo + 1);
;;;391                    rt_memset(rx_fifo->buffer, 0, serial->config.bufsz);
;;;392                    rx_fifo->put_index = 0;
;;;393                    rx_fifo->get_index = 0;
;;;394                    serial->serial_rx = rx_fifo;
;;;395                    /* configure fifo address and length to low level device */
;;;396                    serial->ops->control(serial, RT_DEVICE_CTRL_CONFIG, (void *) RT_DEVICE_FLAG_DMA_RX);
;;;397                }
;;;398                dev->open_flag |= RT_DEVICE_FLAG_DMA_RX;
;;;399            }
;;;400            else if (oflag & RT_DEVICE_FLAG_INT_RX)
;;;401            {
;;;402                struct rt_serial_rx_fifo* rx_fifo;
;;;403    
;;;404                rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) +
;;;405                    serial->config.bufsz);
;;;406                RT_ASSERT(rx_fifo != RT_NULL);
;;;407                rx_fifo->buffer = (rt_uint8_t*) (rx_fifo + 1);
;;;408                rt_memset(rx_fifo->buffer, 0, serial->config.bufsz);
;;;409                rx_fifo->put_index = 0;
;;;410                rx_fifo->get_index = 0;
;;;411    
;;;412                serial->serial_rx = rx_fifo;
;;;413                dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
;;;414                /* configure low level device */
;;;415                serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
;;;416            }
;;;417            else
;;;418            {
;;;419                serial->serial_rx = RT_NULL;
;;;420            }
;;;421        }
;;;422    
;;;423        if (serial->serial_tx == RT_NULL)
;;;424        {
;;;425            if (oflag & RT_DEVICE_FLAG_DMA_TX)
;;;426            {
;;;427                struct rt_serial_tx_dma* tx_dma;
;;;428    
;;;429                tx_dma = (struct rt_serial_tx_dma*) rt_malloc (sizeof(struct rt_serial_tx_dma));
;;;430                RT_ASSERT(tx_dma != RT_NULL);
;;;431                tx_dma->activated = RT_FALSE;
;;;432    
;;;433                rt_data_queue_init(&(tx_dma->data_queue), 8, 4, RT_NULL);
;;;434                serial->serial_tx = tx_dma;
;;;435    
;;;436                dev->open_flag |= RT_DEVICE_FLAG_DMA_TX;
;;;437            }
;;;438            else if (oflag & RT_DEVICE_FLAG_INT_TX)
;;;439            {
;;;440                struct rt_serial_tx_fifo *tx_fifo;
;;;441    
;;;442                tx_fifo = (struct rt_serial_tx_fifo*) rt_malloc(sizeof(struct rt_serial_tx_fifo));
;;;443                RT_ASSERT(tx_fifo != RT_NULL);
;;;444    
;;;445                rt_completion_init(&(tx_fifo->completion));
;;;446                serial->serial_tx = tx_fifo;
;;;447    
;;;448                dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
;;;449                /* configure low level device */
;;;450                serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
;;;451            }
;;;452            else
;;;453            {
;;;454                serial->serial_tx = RT_NULL;
;;;455            }
;;;456        }
;;;457    
;;;458        return RT_EOK;
;;;459    }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L15.46|
00002e  f4066000          AND      r0,r6,#0x800          ;361
000032  b130              CBZ      r0,|L15.66|
000034  8ae8              LDRH     r0,[r5,#0x16]         ;361
000036  f4006000          AND      r0,r0,#0x800          ;361
00003a  b910              CBNZ     r0,|L15.66|
00003c  f06f0007          MVN      r0,#7                 ;362
000040  e7f3              B        |L15.42|
                  |L15.66|
000042  f4067080          AND      r0,r6,#0x100          ;363
000046  b130              CBZ      r0,|L15.86|
000048  8ae8              LDRH     r0,[r5,#0x16]         ;363
00004a  f4007080          AND      r0,r0,#0x100          ;363
00004e  b910              CBNZ     r0,|L15.86|
000050  f06f0007          MVN      r0,#7                 ;364
000054  e7e9              B        |L15.42|
                  |L15.86|
000056  f4066080          AND      r0,r6,#0x400          ;365
00005a  b130              CBZ      r0,|L15.106|
00005c  8ae8              LDRH     r0,[r5,#0x16]         ;365
00005e  f4006080          AND      r0,r0,#0x400          ;365
000062  b910              CBNZ     r0,|L15.106|
000064  f06f0007          MVN      r0,#7                 ;366
000068  e7df              B        |L15.42|
                  |L15.106|
00006a  b2f0              UXTB     r0,r6                 ;369
00006c  8328              STRH     r0,[r5,#0x18]         ;369
00006e  6ce0              LDR      r0,[r4,#0x4c]         ;372
000070  2800              CMP      r0,#0                 ;372
000072  d16e              BNE      |L15.338|
000074  f4067000          AND      r0,r6,#0x200          ;374
000078  2800              CMP      r0,#0                 ;374
00007a  d03c              BEQ      |L15.246|
00007c  6ca0              LDR      r0,[r4,#0x48]         ;376
00007e  f3c0208f          UBFX     r0,r0,#10,#16         ;376
000082  b970              CBNZ     r0,|L15.162|
000084  2004              MOVS     r0,#4                 ;379
000086  f7fffffe          BL       rt_malloc
00008a  4607              MOV      r7,r0                 ;379
00008c  b92f              CBNZ     r7,|L15.154|
00008e  f44f72be          MOV      r2,#0x17c             ;380
000092  4950              LDR      r1,|L15.468|
000094  a054              ADR      r0,|L15.488|
000096  f7fffffe          BL       rt_assert_handler
                  |L15.154|
00009a  2000              MOVS     r0,#0                 ;381
00009c  6038              STR      r0,[r7,#0]            ;381
00009e  64e7              STR      r7,[r4,#0x4c]         ;383
0000a0  e024              B        |L15.236|
                  |L15.162|
0000a2  6ca1              LDR      r1,[r4,#0x48]         ;387
0000a4  f3c1218f          UBFX     r1,r1,#10,#16         ;387
0000a8  f1010008          ADD      r0,r1,#8              ;387
0000ac  f7fffffe          BL       rt_malloc
0000b0  4607              MOV      r7,r0                 ;387
0000b2  b92f              CBNZ     r7,|L15.192|
0000b4  f2401285          MOV      r2,#0x185             ;389
0000b8  4946              LDR      r1,|L15.468|
0000ba  a050              ADR      r0,|L15.508|
0000bc  f7fffffe          BL       rt_assert_handler
                  |L15.192|
0000c0  f1070008          ADD      r0,r7,#8              ;390
0000c4  6038              STR      r0,[r7,#0]            ;390
0000c6  6ca1              LDR      r1,[r4,#0x48]         ;391
0000c8  f3c1228f          UBFX     r2,r1,#10,#16         ;391
0000cc  2100              MOVS     r1,#0                 ;391
0000ce  6838              LDR      r0,[r7,#0]            ;391
0000d0  f7fffffe          BL       rt_memset
0000d4  2000              MOVS     r0,#0                 ;392
0000d6  80b8              STRH     r0,[r7,#4]            ;392
0000d8  80f8              STRH     r0,[r7,#6]            ;393
0000da  64e7              STR      r7,[r4,#0x4c]         ;394
0000dc  6c20              LDR      r0,[r4,#0x40]         ;396
0000de  f44f7200          MOV      r2,#0x200             ;396
0000e2  2103              MOVS     r1,#3                 ;396
0000e4  6843              LDR      r3,[r0,#4]            ;396
0000e6  4620              MOV      r0,r4                 ;396
0000e8  4798              BLX      r3                    ;396
0000ea  bf00              NOP                            ;397
                  |L15.236|
0000ec  8b28              LDRH     r0,[r5,#0x18]         ;398
0000ee  f4407000          ORR      r0,r0,#0x200          ;398
0000f2  8328              STRH     r0,[r5,#0x18]         ;398
0000f4  e02d              B        |L15.338|
                  |L15.246|
0000f6  f4067080          AND      r0,r6,#0x100          ;400
0000fa  b340              CBZ      r0,|L15.334|
0000fc  6ca1              LDR      r1,[r4,#0x48]         ;404
0000fe  f3c1218f          UBFX     r1,r1,#10,#16         ;404
000102  f1010008          ADD      r0,r1,#8              ;404
000106  f7fffffe          BL       rt_malloc
00010a  4607              MOV      r7,r0                 ;404
00010c  b92f              CBNZ     r7,|L15.282|
00010e  f44f72cb          MOV      r2,#0x196             ;406
000112  4930              LDR      r1,|L15.468|
000114  a039              ADR      r0,|L15.508|
000116  f7fffffe          BL       rt_assert_handler
                  |L15.282|
00011a  f1070008          ADD      r0,r7,#8              ;407
00011e  6038              STR      r0,[r7,#0]            ;407
000120  6ca1              LDR      r1,[r4,#0x48]         ;408
000122  f3c1228f          UBFX     r2,r1,#10,#16         ;408
000126  2100              MOVS     r1,#0                 ;408
000128  6838              LDR      r0,[r7,#0]            ;408
00012a  f7fffffe          BL       rt_memset
00012e  2000              MOVS     r0,#0                 ;409
000130  80b8              STRH     r0,[r7,#4]            ;409
000132  80f8              STRH     r0,[r7,#6]            ;410
000134  64e7              STR      r7,[r4,#0x4c]         ;412
000136  8b28              LDRH     r0,[r5,#0x18]         ;413
000138  f4407080          ORR      r0,r0,#0x100          ;413
00013c  8328              STRH     r0,[r5,#0x18]         ;413
00013e  6c20              LDR      r0,[r4,#0x40]         ;415
000140  f44f7280          MOV      r2,#0x100             ;415
000144  2110              MOVS     r1,#0x10              ;415
000146  6843              LDR      r3,[r0,#4]            ;415
000148  4620              MOV      r0,r4                 ;415
00014a  4798              BLX      r3                    ;415
00014c  e001              B        |L15.338|
                  |L15.334|
00014e  2000              MOVS     r0,#0                 ;419
000150  64e0              STR      r0,[r4,#0x4c]         ;419
                  |L15.338|
000152  6d20              LDR      r0,[r4,#0x50]         ;423
000154  2800              CMP      r0,#0                 ;423
000156  d13b              BNE      |L15.464|
000158  f4066000          AND      r0,r6,#0x800          ;425
00015c  b1c0              CBZ      r0,|L15.400|
00015e  2028              MOVS     r0,#0x28              ;429
000160  f7fffffe          BL       rt_malloc
000164  4607              MOV      r7,r0                 ;429
000166  b92f              CBNZ     r7,|L15.372|
000168  f44f72d7          MOV      r2,#0x1ae             ;430
00016c  4919              LDR      r1,|L15.468|
00016e  a028              ADR      r0,|L15.528|
000170  f7fffffe          BL       rt_assert_handler
                  |L15.372|
000174  2000              MOVS     r0,#0                 ;431
000176  6038              STR      r0,[r7,#0]            ;431
000178  2300              MOVS     r3,#0                 ;433
00017a  2204              MOVS     r2,#4                 ;433
00017c  2108              MOVS     r1,#8                 ;433
00017e  1d38              ADDS     r0,r7,#4              ;433
000180  f7fffffe          BL       rt_data_queue_init
000184  6527              STR      r7,[r4,#0x50]         ;434
000186  8b28              LDRH     r0,[r5,#0x18]         ;436
000188  f4406000          ORR      r0,r0,#0x800          ;436
00018c  8328              STRH     r0,[r5,#0x18]         ;436
00018e  e01f              B        |L15.464|
                  |L15.400|
000190  f4066080          AND      r0,r6,#0x400          ;438
000194  b1d0              CBZ      r0,|L15.460|
000196  200c              MOVS     r0,#0xc               ;442
000198  f7fffffe          BL       rt_malloc
00019c  4607              MOV      r7,r0                 ;442
00019e  b92f              CBNZ     r7,|L15.428|
0001a0  f24012bb          MOV      r2,#0x1bb             ;443
0001a4  490b              LDR      r1,|L15.468|
0001a6  a01f              ADR      r0,|L15.548|
0001a8  f7fffffe          BL       rt_assert_handler
                  |L15.428|
0001ac  4638              MOV      r0,r7                 ;445
0001ae  f7fffffe          BL       rt_completion_init
0001b2  6527              STR      r7,[r4,#0x50]         ;446
0001b4  8b28              LDRH     r0,[r5,#0x18]         ;448
0001b6  f4406080          ORR      r0,r0,#0x400          ;448
0001ba  8328              STRH     r0,[r5,#0x18]         ;448
0001bc  6c20              LDR      r0,[r4,#0x40]         ;450
0001be  f44f6280          MOV      r2,#0x400             ;450
0001c2  2110              MOVS     r1,#0x10              ;450
0001c4  6843              LDR      r3,[r0,#4]            ;450
0001c6  4620              MOV      r0,r4                 ;450
0001c8  4798              BLX      r3                    ;450
0001ca  e001              B        |L15.464|
                  |L15.460|
0001cc  2000              MOVS     r0,#0                 ;454
0001ce  6520              STR      r0,[r4,#0x50]         ;454
                  |L15.464|
0001d0  2000              MOVS     r0,#0                 ;458
0001d2  e72a              B        |L15.42|
;;;460    
                          ENDP

                  |L15.468|
                          DCD      |symbol_number.64|
                  |L15.472|
0001d8  64657620          DCB      "dev != RT_NULL",0
0001dc  213d2052
0001e0  545f4e55
0001e4  4c4c00  
0001e7  00                DCB      0
                  |L15.488|
0001e8  72785f64          DCB      "rx_dma != RT_NULL",0
0001ec  6d612021
0001f0  3d205254
0001f4  5f4e554c
0001f8  4c00    
0001fa  00                DCB      0
0001fb  00                DCB      0
                  |L15.508|
0001fc  72785f66          DCB      "rx_fifo != RT_NULL",0
000200  69666f20
000204  213d2052
000208  545f4e55
00020c  4c4c00  
00020f  00                DCB      0
                  |L15.528|
000210  74785f64          DCB      "tx_dma != RT_NULL",0
000214  6d612021
000218  3d205254
00021c  5f4e554c
000220  4c00    
000222  00                DCB      0
000223  00                DCB      0
                  |L15.548|
000224  74785f66          DCB      "tx_fifo != RT_NULL",0
000228  69666f20
00022c  213d2052
000230  545f4e55
000234  4c4c00  
000237  00                DCB      0

                          AREA ||i.rt_serial_read||, CODE, READONLY, ALIGN=2

                  rt_serial_read PROC
;;;534    
;;;535    static rt_size_t rt_serial_read(struct rt_device *dev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;536                                    rt_off_t          pos,
;;;537                                    void             *buffer,
;;;538                                    rt_size_t         size)
;;;539    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;540        struct rt_serial_device *serial;
;;;541    
;;;542        RT_ASSERT(dev != RT_NULL);
00000c  b92c              CBNZ     r4,|L16.26|
00000e  f240221e          MOV      r2,#0x21e
000012  4911              LDR      r1,|L16.88|
000014  a011              ADR      r0,|L16.92|
000016  f7fffffe          BL       rt_assert_handler
                  |L16.26|
;;;543        if (size == 0) return 0;
00001a  b915              CBNZ     r5,|L16.34|
00001c  2000              MOVS     r0,#0
                  |L16.30|
;;;544    
;;;545        serial = (struct rt_serial_device *)dev;
;;;546    
;;;547        if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
;;;548        {
;;;549            return _serial_int_rx(serial, buffer, size);
;;;550        }
;;;551        else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
;;;552        {
;;;553            return _serial_dma_rx(serial, buffer, size);
;;;554        }
;;;555    
;;;556        return _serial_poll_rx(serial, buffer, size);
;;;557    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L16.34|
000022  4626              MOV      r6,r4                 ;545
000024  8b20              LDRH     r0,[r4,#0x18]         ;547
000026  f4007080          AND      r0,r0,#0x100          ;547
00002a  b128              CBZ      r0,|L16.56|
00002c  462a              MOV      r2,r5                 ;549
00002e  4639              MOV      r1,r7                 ;549
000030  4630              MOV      r0,r6                 ;549
000032  f7fffffe          BL       _serial_int_rx
000036  e7f2              B        |L16.30|
                  |L16.56|
000038  8b20              LDRH     r0,[r4,#0x18]         ;551
00003a  f4007000          AND      r0,r0,#0x200          ;551
00003e  b128              CBZ      r0,|L16.76|
000040  462a              MOV      r2,r5                 ;553
000042  4639              MOV      r1,r7                 ;553
000044  4630              MOV      r0,r6                 ;553
000046  f7fffffe          BL       _serial_dma_rx
00004a  e7e8              B        |L16.30|
                  |L16.76|
00004c  462a              MOV      r2,r5                 ;556
00004e  4639              MOV      r1,r7                 ;556
000050  4630              MOV      r0,r6                 ;556
000052  f7fffffe          BL       _serial_poll_rx
000056  e7e2              B        |L16.30|
;;;558    
                          ENDP

                  |L16.88|
                          DCD      |symbol_number.66|
                  |L16.92|
00005c  64657620          DCB      "dev != RT_NULL",0
000060  213d2052
000064  545f4e55
000068  4c4c00  
00006b  00                DCB      0

                          AREA ||i.rt_serial_write||, CODE, READONLY, ALIGN=2

                  rt_serial_write PROC
;;;558    
;;;559    static rt_size_t rt_serial_write(struct rt_device *dev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;560                                     rt_off_t          pos,
;;;561                                     const void       *buffer,
;;;562                                     rt_size_t         size)
;;;563    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;564        struct rt_serial_device *serial;
;;;565    
;;;566        RT_ASSERT(dev != RT_NULL);
00000c  b92c              CBNZ     r4,|L17.26|
00000e  f2402236          MOV      r2,#0x236
000012  4911              LDR      r1,|L17.88|
000014  a011              ADR      r0,|L17.92|
000016  f7fffffe          BL       rt_assert_handler
                  |L17.26|
;;;567        if (size == 0) return 0;
00001a  b915              CBNZ     r5,|L17.34|
00001c  2000              MOVS     r0,#0
                  |L17.30|
;;;568    
;;;569        serial = (struct rt_serial_device *)dev;
;;;570    
;;;571        if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
;;;572        {
;;;573            return _serial_int_tx(serial, buffer, size);
;;;574        }
;;;575        else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
;;;576        {
;;;577            return _serial_dma_tx(serial, buffer, size);
;;;578        }
;;;579        else
;;;580        {
;;;581            return _serial_poll_tx(serial, buffer, size);
;;;582        }
;;;583    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L17.34|
000022  4626              MOV      r6,r4                 ;569
000024  8b20              LDRH     r0,[r4,#0x18]         ;571
000026  f4006080          AND      r0,r0,#0x400          ;571
00002a  b128              CBZ      r0,|L17.56|
00002c  462a              MOV      r2,r5                 ;573
00002e  4639              MOV      r1,r7                 ;573
000030  4630              MOV      r0,r6                 ;573
000032  f7fffffe          BL       _serial_int_tx
000036  e7f2              B        |L17.30|
                  |L17.56|
000038  8b20              LDRH     r0,[r4,#0x18]         ;575
00003a  f4006000          AND      r0,r0,#0x800          ;575
00003e  b128              CBZ      r0,|L17.76|
000040  462a              MOV      r2,r5                 ;577
000042  4639              MOV      r1,r7                 ;577
000044  4630              MOV      r0,r6                 ;577
000046  f7fffffe          BL       _serial_dma_tx
00004a  e7e8              B        |L17.30|
                  |L17.76|
00004c  462a              MOV      r2,r5                 ;581
00004e  4639              MOV      r1,r7                 ;581
000050  4630              MOV      r0,r6                 ;581
000052  f7fffffe          BL       _serial_poll_tx
000056  e7e2              B        |L17.30|
;;;584    
                          ENDP

                  |L17.88|
                          DCD      |symbol_number.67|
                  |L17.92|
00005c  64657620          DCB      "dev != RT_NULL",0
000060  213d2052
000064  545f4e55
000068  4c4c00  
00006b  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  5f736572          DCB      0x5f,0x73,0x65,0x72
000004  69616c5f          DCB      0x69,0x61,0x6c,0x5f
000008  706f6c6c          DCB      0x70,0x6f,0x6c,0x6c
00000c  5f727800          DCB      0x5f,0x72,0x78,0x00
                  |symbol_number.56|
000010  5f736572          DCB      0x5f,0x73,0x65,0x72
000014  69616c5f          DCB      0x69,0x61,0x6c,0x5f
000018  706f6c6c          DCB      0x70,0x6f,0x6c,0x6c
00001c  5f747800          DCB      0x5f,0x74,0x78,0x00
                  |symbol_number.57|
000020  5f736572          DCB      0x5f,0x73,0x65,0x72
000024  69616c5f          DCB      0x69,0x61,0x6c,0x5f
000028  696e745f          DCB      0x69,0x6e,0x74,0x5f
00002c  727800            DCB      0x72,0x78,0x00
                  |symbol_number.58|
00002f  5f                DCB      0x5f
000030  73657269          DCB      0x73,0x65,0x72,0x69
000034  616c5f69          DCB      0x61,0x6c,0x5f,0x69
000038  6e745f74          DCB      0x6e,0x74,0x5f,0x74
00003c  7800              DCB      0x78,0x00
                  |symbol_number.59|
00003e  7274              DCB      0x72,0x74
000040  5f646d61          DCB      0x5f,0x64,0x6d,0x61
000044  5f63616c          DCB      0x5f,0x63,0x61,0x6c
000048  635f7265          DCB      0x63,0x5f,0x72,0x65
00004c  63766564          DCB      0x63,0x76,0x65,0x64
000050  5f6c656e          DCB      0x5f,0x6c,0x65,0x6e
000054  00                DCB      0x00
                  |symbol_number.60|
000055  72745f            DCB      0x72,0x74,0x5f
000058  646d615f          DCB      0x64,0x6d,0x61,0x5f
00005c  72656376          DCB      0x72,0x65,0x63,0x76
000060  5f757064          DCB      0x5f,0x75,0x70,0x64
000064  6174655f          DCB      0x61,0x74,0x65,0x5f
000068  6765745f          DCB      0x67,0x65,0x74,0x5f
00006c  696e6465          DCB      0x69,0x6e,0x64,0x65
000070  7800              DCB      0x78,0x00
                  |symbol_number.61|
000072  7274              DCB      0x72,0x74
000074  5f646d61          DCB      0x5f,0x64,0x6d,0x61
000078  5f726563          DCB      0x5f,0x72,0x65,0x63
00007c  765f7570          DCB      0x76,0x5f,0x75,0x70
000080  64617465          DCB      0x64,0x61,0x74,0x65
000084  5f707574          DCB      0x5f,0x70,0x75,0x74
000088  5f696e64          DCB      0x5f,0x69,0x6e,0x64
00008c  657800            DCB      0x65,0x78,0x00
                  |symbol_number.62|
00008f  5f                DCB      0x5f
000090  73657269          DCB      0x73,0x65,0x72,0x69
000094  616c5f64          DCB      0x61,0x6c,0x5f,0x64
000098  6d615f72          DCB      0x6d,0x61,0x5f,0x72
00009c  7800              DCB      0x78,0x00
                  |symbol_number.63|
00009e  7274              DCB      0x72,0x74
0000a0  5f736572          DCB      0x5f,0x73,0x65,0x72
0000a4  69616c5f          DCB      0x69,0x61,0x6c,0x5f
0000a8  696e6974          DCB      0x69,0x6e,0x69,0x74
0000ac  00                DCB      0x00
                  |symbol_number.64|
0000ad  72745f            DCB      0x72,0x74,0x5f
0000b0  73657269          DCB      0x73,0x65,0x72,0x69
0000b4  616c5f6f          DCB      0x61,0x6c,0x5f,0x6f
0000b8  70656e00          DCB      0x70,0x65,0x6e,0x00
                  |symbol_number.65|
0000bc  72745f73          DCB      0x72,0x74,0x5f,0x73
0000c0  65726961          DCB      0x65,0x72,0x69,0x61
0000c4  6c5f636c          DCB      0x6c,0x5f,0x63,0x6c
0000c8  6f736500          DCB      0x6f,0x73,0x65,0x00
                  |symbol_number.66|
0000cc  72745f73          DCB      0x72,0x74,0x5f,0x73
0000d0  65726961          DCB      0x65,0x72,0x69,0x61
0000d4  6c5f7265          DCB      0x6c,0x5f,0x72,0x65
0000d8  616400            DCB      0x61,0x64,0x00
                  |symbol_number.67|
0000db  72                DCB      0x72
0000dc  745f7365          DCB      0x74,0x5f,0x73,0x65
0000e0  7269616c          DCB      0x72,0x69,0x61,0x6c
0000e4  5f777269          DCB      0x5f,0x77,0x72,0x69
0000e8  746500            DCB      0x74,0x65,0x00
                  |symbol_number.68|
0000eb  72                DCB      0x72
0000ec  745f7365          DCB      0x74,0x5f,0x73,0x65
0000f0  7269616c          DCB      0x72,0x69,0x61,0x6c
0000f4  5f636f6e          DCB      0x5f,0x63,0x6f,0x6e
0000f8  74726f6c          DCB      0x74,0x72,0x6f,0x6c
0000fc  00                DCB      0x00
                  |symbol_number.69|
0000fd  72745f            DCB      0x72,0x74,0x5f
000100  68775f73          DCB      0x68,0x77,0x5f,0x73
000104  65726961          DCB      0x65,0x72,0x69,0x61
000108  6c5f7265          DCB      0x6c,0x5f,0x72,0x65
00010c  67697374          DCB      0x67,0x69,0x73,0x74
000110  657200            DCB      0x65,0x72,0x00
                  |symbol_number.70|
000113  72                DCB      0x72
000114  745f6877          DCB      0x74,0x5f,0x68,0x77
000118  5f736572          DCB      0x5f,0x73,0x65,0x72
00011c  69616c5f          DCB      0x69,0x61,0x6c,0x5f
000120  69737200          DCB      0x69,0x73,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  rx_length
                          DCD      0x00000000
