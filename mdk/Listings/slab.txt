; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\slab.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\slab.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\slab.crf ..\rt_thread\kernel\slab.c]
                          THUMB

                          AREA ||i.rt_calloc||, CODE, READONLY, ALIGN=1

                  rt_calloc PROC
;;;771     */
;;;772    void *rt_calloc(rt_size_t count, rt_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;773    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;774        void *p;
;;;775    
;;;776        /* allocate 'count' objects of size 'size' */
;;;777        p = rt_malloc(count * size);
000006  fb04f005          MUL      r0,r4,r5
00000a  f7fffffe          BL       rt_malloc
00000e  4606              MOV      r6,r0
;;;778    
;;;779        /* zero the memory */
;;;780        if (p)
000010  b12e              CBZ      r6,|L1.30|
;;;781            rt_memset(p, 0, count * size);
000012  fb04f205          MUL      r2,r4,r5
000016  2100              MOVS     r1,#0
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       rt_memset
                  |L1.30|
;;;782    
;;;783        return p;
00001e  4630              MOV      r0,r6
;;;784    }
000020  bd70              POP      {r4-r6,pc}
;;;785    RTM_EXPORT(rt_calloc);
                          ENDP


                          AREA ||i.rt_free||, CODE, READONLY, ALIGN=2

                  rt_free PROC
;;;792     */
;;;793    void rt_free(void *ptr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;794    {
000004  4606              MOV      r6,r0
;;;795        slab_zone *z;
;;;796        slab_chunk *chunk;
;;;797        struct memusage *kup;
;;;798    
;;;799        /* free a RT_NULL pointer */
;;;800        if (ptr == RT_NULL)
000006  b90e              CBNZ     r6,|L2.12|
                  |L2.8|
;;;801            return ;
;;;802    
;;;803        RT_OBJECT_HOOK_CALL(rt_free_hook, (ptr));
;;;804    
;;;805    #ifdef RT_USING_MODULE
;;;806        if(rt_module_self() != RT_NULL)
;;;807        {
;;;808            rt_module_free(rt_module_self(), ptr);
;;;809    
;;;810            return;
;;;811        }
;;;812    #endif
;;;813    
;;;814        /* get memory usage */
;;;815    #if RT_DEBUG_SLAB
;;;816        {
;;;817            rt_uint32_t addr = ((rt_uint32_t)ptr & ~RT_MM_PAGE_MASK);
;;;818            RT_DEBUG_LOG(RT_DEBUG_SLAB,
;;;819                         ("free a memory 0x%x and align to 0x%x, kup index %d\n",
;;;820                          (rt_uint32_t)ptr,
;;;821                          (rt_uint32_t)addr,
;;;822                          ((rt_uint32_t)(addr) - heap_start) >> RT_MM_PAGE_BITS));
;;;823        }
;;;824    #endif
;;;825    
;;;826        kup = btokup((rt_uint32_t)ptr & ~RT_MM_PAGE_MASK);
;;;827        /* release large allocation */
;;;828        if (kup->type == PAGE_TYPE_LARGE)
;;;829        {
;;;830            rt_uint32_t size;
;;;831    
;;;832            /* lock heap */
;;;833            rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;834            /* clear page counter */
;;;835            size = kup->size;
;;;836            kup->size = 0;
;;;837    
;;;838    #ifdef RT_MEM_STATS
;;;839            used_mem -= size * RT_MM_PAGE_SIZE;
;;;840    #endif
;;;841            rt_sem_release(&heap_sem);
;;;842    
;;;843            RT_DEBUG_LOG(RT_DEBUG_SLAB,
;;;844                         ("free large memory block 0x%x, page count %d\n",
;;;845                          (rt_uint32_t)ptr, size));
;;;846    
;;;847            /* free this page */
;;;848            rt_page_free(ptr, size);
;;;849    
;;;850            return;
;;;851        }
;;;852    
;;;853        /* lock heap */
;;;854        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;855    
;;;856        /* zone case. get out zone. */
;;;857        z = (slab_zone *)(((rt_uint32_t)ptr & ~RT_MM_PAGE_MASK) -
;;;858                          kup->size * RT_MM_PAGE_SIZE);
;;;859        RT_ASSERT(z->z_magic == ZALLOC_SLAB_MAGIC);
;;;860    
;;;861        chunk          = (slab_chunk *)ptr;
;;;862        chunk->c_next  = z->z_freechunk;
;;;863        z->z_freechunk = chunk;
;;;864    
;;;865    #ifdef RT_MEM_STATS
;;;866        used_mem -= z->z_chunksize;
;;;867    #endif
;;;868    
;;;869        /*
;;;870         * Bump the number of free chunks.  If it becomes non-zero the zone
;;;871         * must be added back onto the appropriate list.
;;;872         */
;;;873        if (z->z_nfree++ == 0)
;;;874        {
;;;875            z->z_next = zone_array[z->z_zoneindex];
;;;876            zone_array[z->z_zoneindex] = z;
;;;877        }
;;;878    
;;;879        /*
;;;880         * If the zone becomes totally free, and there are other zones we
;;;881         * can allocate from, move this zone to the FreeZones list.  Since
;;;882         * this code can be called from an IPI callback, do *NOT* try to mess
;;;883         * with kernel_map here.  Hysteresis will be performed at malloc() time.
;;;884         */
;;;885        if (z->z_nfree == z->z_nmax &&
;;;886            (z->z_next || zone_array[z->z_zoneindex] != z))
;;;887        {
;;;888            slab_zone **pz;
;;;889    
;;;890            RT_DEBUG_LOG(RT_DEBUG_SLAB, ("free zone 0x%x\n",
;;;891                                         (rt_uint32_t)z, z->z_zoneindex));
;;;892    
;;;893            /* remove zone from zone array list */
;;;894            for (pz = &zone_array[z->z_zoneindex]; z != *pz; pz = &(*pz)->z_next)
;;;895                ;
;;;896            *pz = z->z_next;
;;;897    
;;;898            /* reset zone */
;;;899            z->z_magic = -1;
;;;900    
;;;901            /* insert to free zone list */
;;;902            z->z_next = zone_free;
;;;903            zone_free = z;
;;;904    
;;;905            ++ zone_free_cnt;
;;;906    
;;;907            /* release zone to page allocator */
;;;908            if (zone_free_cnt > ZONE_RELEASE_THRESH)
;;;909            {
;;;910                register rt_base_t i;
;;;911    
;;;912                z         = zone_free;
;;;913                zone_free = z->z_next;
;;;914                -- zone_free_cnt;
;;;915    
;;;916                /* set message usage */
;;;917                for (i = 0, kup = btokup(z); i < zone_page_cnt; i ++)
;;;918                {
;;;919                    kup->type = PAGE_TYPE_FREE;
;;;920                    kup->size = 0;
;;;921                    kup ++;
;;;922                }
;;;923    
;;;924                /* unlock heap */
;;;925                rt_sem_release(&heap_sem);
;;;926    
;;;927                /* release pages */
;;;928                rt_page_free(z, zone_size / RT_MM_PAGE_SIZE);
;;;929    
;;;930                return;
;;;931            }
;;;932        }
;;;933        /* unlock heap */
;;;934        rt_sem_release(&heap_sem);
;;;935    }
000008  e8bd87f0          POP      {r4-r10,pc}
                  |L2.12|
00000c  bf00              NOP                            ;803
00000e  4862              LDR      r0,|L2.408|
000010  6800              LDR      r0,[r0,#0]            ;803  ; rt_free_hook
000012  b118              CBZ      r0,|L2.28|
000014  4630              MOV      r0,r6                 ;803
000016  4960              LDR      r1,|L2.408|
000018  6809              LDR      r1,[r1,#0]            ;803  ; rt_free_hook
00001a  4788              BLX      r1                    ;803
                  |L2.28|
00001c  bf00              NOP                            ;803
00001e  0b30              LSRS     r0,r6,#12             ;826
000020  0300              LSLS     r0,r0,#12             ;826
000022  495e              LDR      r1,|L2.412|
000024  6809              LDR      r1,[r1,#0]            ;826  ; heap_start
000026  1a40              SUBS     r0,r0,r1              ;826
000028  0b00              LSRS     r0,r0,#12             ;826
00002a  495d              LDR      r1,|L2.416|
00002c  6809              LDR      r1,[r1,#0]            ;826  ; memusage
00002e  eb010580          ADD      r5,r1,r0,LSL #2       ;826
000032  7828              LDRB     r0,[r5,#0]            ;828
000034  f0000003          AND      r0,r0,#3              ;828
000038  2802              CMP      r0,#2                 ;828
00003a  d119              BNE      |L2.112|
00003c  1ec1              SUBS     r1,r0,#3              ;833
00003e  4859              LDR      r0,|L2.420|
000040  f7fffffe          BL       rt_sem_take
000044  6828              LDR      r0,[r5,#0]            ;835
000046  0887              LSRS     r7,r0,#2              ;835
000048  7828              LDRB     r0,[r5,#0]            ;836
00004a  f0000003          AND      r0,r0,#3              ;836
00004e  6028              STR      r0,[r5,#0]            ;836
000050  4855              LDR      r0,|L2.424|
000052  6800              LDR      r0,[r0,#0]            ;839  ; used_mem
000054  eba03007          SUB      r0,r0,r7,LSL #12      ;839
000058  4953              LDR      r1,|L2.424|
00005a  6008              STR      r0,[r1,#0]            ;839  ; used_mem
00005c  4851              LDR      r0,|L2.420|
00005e  f7fffffe          BL       rt_sem_release
000062  bf00              NOP                            ;843
000064  bf00              NOP                            ;843
000066  4639              MOV      r1,r7                 ;848
000068  4630              MOV      r0,r6                 ;848
00006a  f7fffffe          BL       rt_page_free
00006e  e7cb              B        |L2.8|
                  |L2.112|
000070  f04f31ff          MOV      r1,#0xffffffff        ;854
000074  484b              LDR      r0,|L2.420|
000076  f7fffffe          BL       rt_sem_take
00007a  0b31              LSRS     r1,r6,#12             ;857
00007c  0309              LSLS     r1,r1,#12             ;857
00007e  6828              LDR      r0,[r5,#0]            ;857
000080  0880              LSRS     r0,r0,#2              ;857
000082  eba13400          SUB      r4,r1,r0,LSL #12      ;857
000086  4949              LDR      r1,|L2.428|
000088  6820              LDR      r0,[r4,#0]            ;859
00008a  4288              CMP      r0,r1                 ;859
00008c  d005              BEQ      |L2.154|
00008e  f240325b          MOV      r2,#0x35b             ;859
000092  4947              LDR      r1,|L2.432|
000094  a047              ADR      r0,|L2.436|
000096  f7fffffe          BL       rt_assert_handler
                  |L2.154|
00009a  46b0              MOV      r8,r6                 ;861
00009c  4646              MOV      r6,r8                 ;862
00009e  6a20              LDR      r0,[r4,#0x20]         ;862
0000a0  f8c80000          STR      r0,[r8,#0]            ;862
0000a4  f8c48020          STR      r8,[r4,#0x20]         ;863
0000a8  493f              LDR      r1,|L2.424|
0000aa  69a0              LDR      r0,[r4,#0x18]         ;866
0000ac  6809              LDR      r1,[r1,#0]            ;866  ; used_mem
0000ae  1a08              SUBS     r0,r1,r0              ;866
0000b0  493d              LDR      r1,|L2.424|
0000b2  6008              STR      r0,[r1,#0]            ;866  ; used_mem
0000b4  6861              LDR      r1,[r4,#4]            ;873
0000b6  1c48              ADDS     r0,r1,#1              ;873
0000b8  6060              STR      r0,[r4,#4]            ;873
0000ba  b939              CBNZ     r1,|L2.204|
0000bc  4945              LDR      r1,|L2.468|
0000be  69e0              LDR      r0,[r4,#0x1c]         ;875
0000c0  f8510020          LDR      r0,[r1,r0,LSL #2]     ;875
0000c4  60e0              STR      r0,[r4,#0xc]          ;875
0000c6  69e0              LDR      r0,[r4,#0x1c]         ;876
0000c8  f8414020          STR      r4,[r1,r0,LSL #2]     ;876
                  |L2.204|
0000cc  e9d40101          LDRD     r0,r1,[r4,#4]         ;885
0000d0  4288              CMP      r0,r1                 ;885
0000d2  d15b              BNE      |L2.396|
0000d4  68e0              LDR      r0,[r4,#0xc]          ;886
0000d6  b928              CBNZ     r0,|L2.228|
0000d8  493e              LDR      r1,|L2.468|
0000da  69e0              LDR      r0,[r4,#0x1c]         ;886
0000dc  f8510020          LDR      r0,[r1,r0,LSL #2]     ;886
0000e0  42a0              CMP      r0,r4                 ;886
0000e2  d053              BEQ      |L2.396|
                  |L2.228|
0000e4  bf00              NOP                            ;890
0000e6  bf00              NOP                            ;890
0000e8  493a              LDR      r1,|L2.468|
0000ea  69e0              LDR      r0,[r4,#0x1c]         ;894
0000ec  eb010780          ADD      r7,r1,r0,LSL #2       ;894
0000f0  e002              B        |L2.248|
                  |L2.242|
0000f2  6838              LDR      r0,[r7,#0]            ;894
0000f4  f100070c          ADD      r7,r0,#0xc            ;894
                  |L2.248|
0000f8  6838              LDR      r0,[r7,#0]            ;894
0000fa  42a0              CMP      r0,r4                 ;894
0000fc  d1f9              BNE      |L2.242|
0000fe  68e0              LDR      r0,[r4,#0xc]          ;896
000100  6038              STR      r0,[r7,#0]            ;896
000102  f04f30ff          MOV      r0,#0xffffffff        ;899
000106  6020              STR      r0,[r4,#0]            ;899
000108  4833              LDR      r0,|L2.472|
00010a  6800              LDR      r0,[r0,#0]            ;902  ; zone_free
00010c  60e0              STR      r0,[r4,#0xc]          ;902
00010e  4832              LDR      r0,|L2.472|
000110  6004              STR      r4,[r0,#0]            ;903  ; zone_free
000112  4832              LDR      r0,|L2.476|
000114  6800              LDR      r0,[r0,#0]            ;905  ; zone_free_cnt
000116  1c40              ADDS     r0,r0,#1              ;905
000118  4930              LDR      r1,|L2.476|
00011a  6008              STR      r0,[r1,#0]            ;905  ; zone_free_cnt
00011c  4608              MOV      r0,r1                 ;908
00011e  6800              LDR      r0,[r0,#0]            ;908  ; zone_free_cnt
000120  2802              CMP      r0,#2                 ;908
000122  dd32              BLE      |L2.394|
000124  482c              LDR      r0,|L2.472|
000126  6804              LDR      r4,[r0,#0]            ;912  ; zone_free
000128  492b              LDR      r1,|L2.472|
00012a  68e0              LDR      r0,[r4,#0xc]          ;913
00012c  6008              STR      r0,[r1,#0]            ;913  ; zone_free
00012e  482b              LDR      r0,|L2.476|
000130  6800              LDR      r0,[r0,#0]            ;914  ; zone_free_cnt
000132  1e40              SUBS     r0,r0,#1              ;914
000134  4929              LDR      r1,|L2.476|
000136  6008              STR      r0,[r1,#0]            ;914  ; zone_free_cnt
000138  f04f0900          MOV      r9,#0                 ;917
00013c  4817              LDR      r0,|L2.412|
00013e  6800              LDR      r0,[r0,#0]            ;917  ; heap_start
000140  1a20              SUBS     r0,r4,r0              ;917
000142  0b00              LSRS     r0,r0,#12             ;917
000144  4916              LDR      r1,|L2.416|
000146  6809              LDR      r1,[r1,#0]            ;917  ; memusage
000148  eb010580          ADD      r5,r1,r0,LSL #2       ;917
00014c  e00a              B        |L2.356|
                  |L2.334|
00014e  6828              LDR      r0,[r5,#0]            ;919
000150  f0200003          BIC      r0,r0,#3              ;919
000154  6028              STR      r0,[r5,#0]            ;919
000156  7828              LDRB     r0,[r5,#0]            ;920
000158  f0000003          AND      r0,r0,#3              ;920
00015c  6028              STR      r0,[r5,#0]            ;920
00015e  1d2d              ADDS     r5,r5,#4              ;921
000160  f1090901          ADD      r9,r9,#1              ;917
                  |L2.356|
000164  481e              LDR      r0,|L2.480|
000166  6800              LDR      r0,[r0,#0]            ;917  ; zone_page_cnt
000168  4581              CMP      r9,r0                 ;917
00016a  dbf0              BLT      |L2.334|
00016c  480d              LDR      r0,|L2.420|
00016e  f7fffffe          BL       rt_sem_release
000172  481c              LDR      r0,|L2.484|
000174  f8d0a000          LDR      r10,[r0,#0]           ;928  ; zone_size
000178  ea4f70ea          ASR      r0,r10,#31            ;928
00017c  eb0a5010          ADD      r0,r10,r0,LSR #20     ;928
000180  1301              ASRS     r1,r0,#12             ;928
000182  4620              MOV      r0,r4                 ;928
000184  f7fffffe          BL       rt_page_free
000188  e73e              B        |L2.8|
                  |L2.394|
00018a  bf00              NOP                            ;932
                  |L2.396|
00018c  4805              LDR      r0,|L2.420|
00018e  f7fffffe          BL       rt_sem_release
000192  bf00              NOP      
000194  e738              B        |L2.8|
;;;936    RTM_EXPORT(rt_free);
                          ENDP

000196  0000              DCW      0x0000
                  |L2.408|
                          DCD      rt_free_hook
                  |L2.412|
                          DCD      heap_start
                  |L2.416|
                          DCD      memusage
                  |L2.420|
                          DCD      heap_sem
                  |L2.424|
                          DCD      used_mem
                  |L2.428|
                          DCD      0x51ab51ab
                  |L2.432|
                          DCD      |symbol_number.48|
                  |L2.436|
0001b4  7a2d3e7a          DCB      "z->z_magic == ZALLOC_SLAB_MAGIC",0
0001b8  5f6d6167
0001bc  6963203d
0001c0  3d205a41
0001c4  4c4c4f43
0001c8  5f534c41
0001cc  425f4d41
0001d0  47494300
                  |L2.468|
                          DCD      zone_array
                  |L2.472|
                          DCD      zone_free
                  |L2.476|
                          DCD      zone_free_cnt
                  |L2.480|
                          DCD      zone_page_cnt
                  |L2.484|
                          DCD      zone_size

                          AREA ||i.rt_free_sethook||, CODE, READONLY, ALIGN=2

                  rt_free_sethook PROC
;;;103     */
;;;104    void rt_free_sethook(void (*hook)(void *ptr))
000000  4901              LDR      r1,|L3.8|
;;;105    {
;;;106        rt_free_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_free_hook
;;;107    }
000004  4770              BX       lr
;;;108    RTM_EXPORT(rt_free_sethook);
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      rt_free_hook

                          AREA ||i.rt_malloc||, CODE, READONLY, ALIGN=2

                  rt_malloc PROC
;;;487     */
;;;488    void *rt_malloc(rt_size_t size)
000000  e92d43f1          PUSH     {r0,r4-r9,lr}
;;;489    {
;;;490        slab_zone *z;
;;;491        rt_int32_t zi;
;;;492        slab_chunk *chunk;
;;;493        struct memusage *kup;
;;;494    
;;;495        /* zero size, return RT_NULL */
;;;496        if (size == 0)
000004  9800              LDR      r0,[sp,#0]
000006  b910              CBNZ     r0,|L4.14|
;;;497            return RT_NULL;
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;498    
;;;499    #ifdef RT_USING_MODULE
;;;500        if (rt_module_self() != RT_NULL)
;;;501            return rt_module_malloc(size);
;;;502    #endif
;;;503    
;;;504        /*
;;;505         * Handle large allocations directly.  There should not be very many of
;;;506         * these so performance is not a big issue.
;;;507         */
;;;508        if (size >= zone_limit)
;;;509        {
;;;510            size = RT_ALIGN(size, RT_MM_PAGE_SIZE);
;;;511    
;;;512            chunk = rt_page_alloc(size >> RT_MM_PAGE_BITS);
;;;513            if (chunk == RT_NULL)
;;;514                return RT_NULL;
;;;515    
;;;516            /* set kup */
;;;517            kup = btokup(chunk);
;;;518            kup->type = PAGE_TYPE_LARGE;
;;;519            kup->size = size >> RT_MM_PAGE_BITS;
;;;520    
;;;521            RT_DEBUG_LOG(RT_DEBUG_SLAB,
;;;522                         ("malloc a large memory 0x%x, page cnt %d, kup %d\n",
;;;523                          size,
;;;524                          size >> RT_MM_PAGE_BITS,
;;;525                          ((rt_uint32_t)chunk - heap_start) >> RT_MM_PAGE_BITS));
;;;526    
;;;527            /* lock heap */
;;;528            rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;529    
;;;530    #ifdef RT_MEM_STATS
;;;531            used_mem += size;
;;;532            if (used_mem > max_mem)
;;;533                max_mem = used_mem;
;;;534    #endif
;;;535            goto done;
;;;536        }
;;;537    
;;;538        /* lock heap */
;;;539        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;540    
;;;541        /*
;;;542         * Attempt to allocate out of an existing zone.  First try the free list,
;;;543         * then allocate out of unallocated space.  If we find a good zone move
;;;544         * it to the head of the list so later allocations find it quickly
;;;545         * (we might have thousands of zones in the list).
;;;546         *
;;;547         * Note: zoneindex() will panic of size is too large.
;;;548         */
;;;549        zi = zoneindex(&size);
;;;550        RT_ASSERT(zi < NZONES);
;;;551    
;;;552        RT_DEBUG_LOG(RT_DEBUG_SLAB, ("try to malloc 0x%x on zone: %d\n", size, zi));
;;;553    
;;;554        if ((z = zone_array[zi]) != RT_NULL)
;;;555        {
;;;556            RT_ASSERT(z->z_nfree > 0);
;;;557    
;;;558            /* Remove us from the zone_array[] when we become empty */
;;;559            if (--z->z_nfree == 0)
;;;560            {
;;;561                zone_array[zi] = z->z_next;
;;;562                z->z_next = RT_NULL;
;;;563            }
;;;564    
;;;565            /*
;;;566             * No chunks are available but nfree said we had some memory, so
;;;567             * it must be available in the never-before-used-memory area
;;;568             * governed by uindex.  The consequences are very serious if our zone
;;;569             * got corrupted so we use an explicit rt_kprintf rather then a KASSERT.
;;;570             */
;;;571            if (z->z_uindex + 1 != z->z_nmax)
;;;572            {
;;;573                z->z_uindex = z->z_uindex + 1;
;;;574                chunk = (slab_chunk *)(z->z_baseptr + z->z_uindex * size);
;;;575            }
;;;576            else
;;;577            {
;;;578                /* find on free chunk list */
;;;579                chunk = z->z_freechunk;
;;;580    
;;;581                /* remove this chunk from list */
;;;582                z->z_freechunk = z->z_freechunk->c_next;
;;;583            }
;;;584    
;;;585    #ifdef RT_MEM_STATS
;;;586            used_mem += z->z_chunksize;
;;;587            if (used_mem > max_mem)
;;;588                max_mem = used_mem;
;;;589    #endif
;;;590    
;;;591            goto done;
;;;592        }
;;;593    
;;;594        /*
;;;595         * If all zones are exhausted we need to allocate a new zone for this
;;;596         * index.
;;;597         *
;;;598         * At least one subsystem, the tty code (see CROUND) expects power-of-2
;;;599         * allocations to be power-of-2 aligned.  We maintain compatibility by
;;;600         * adjusting the base offset below.
;;;601         */
;;;602        {
;;;603            rt_int32_t off;
;;;604    
;;;605            if ((z = zone_free) != RT_NULL)
;;;606            {
;;;607                /* remove zone from free zone list */
;;;608                zone_free = z->z_next;
;;;609                -- zone_free_cnt;
;;;610            }
;;;611            else
;;;612            {
;;;613                /* unlock heap, since page allocator will think about lock */
;;;614                rt_sem_release(&heap_sem);
;;;615    
;;;616                /* allocate a zone from page */
;;;617                z = rt_page_alloc(zone_size / RT_MM_PAGE_SIZE);
;;;618                if (z == RT_NULL)
;;;619                    goto fail;
;;;620    
;;;621                /* lock heap */
;;;622                rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;623    
;;;624                RT_DEBUG_LOG(RT_DEBUG_SLAB, ("alloc a new zone: 0x%x\n",
;;;625                                             (rt_uint32_t)z));
;;;626    
;;;627                /* set message usage */
;;;628                for (off = 0, kup = btokup(z); off < zone_page_cnt; off ++)
;;;629                {
;;;630                    kup->type = PAGE_TYPE_SMALL;
;;;631                    kup->size = off;
;;;632    
;;;633                    kup ++;
;;;634                }
;;;635            }
;;;636    
;;;637            /* clear to zero */
;;;638            rt_memset(z, 0, sizeof(slab_zone));
;;;639    
;;;640            /* offset of slab zone struct in zone */
;;;641            off = sizeof(slab_zone);
;;;642    
;;;643            /*
;;;644             * Guarentee power-of-2 alignment for power-of-2-sized chunks.
;;;645             * Otherwise just 8-byte align the data.
;;;646             */
;;;647            if ((size | (size - 1)) + 1 == (size << 1))
;;;648                off = (off + size - 1) & ~(size - 1);
;;;649            else
;;;650                off = (off + MIN_CHUNK_MASK) & ~MIN_CHUNK_MASK;
;;;651    
;;;652            z->z_magic     = ZALLOC_SLAB_MAGIC;
;;;653            z->z_zoneindex = zi;
;;;654            z->z_nmax      = (zone_size - off) / size;
;;;655            z->z_nfree     = z->z_nmax - 1;
;;;656            z->z_baseptr   = (rt_uint8_t *)z + off;
;;;657            z->z_uindex    = 0;
;;;658            z->z_chunksize = size;
;;;659    
;;;660            chunk = (slab_chunk *)(z->z_baseptr + z->z_uindex * size);
;;;661    
;;;662            /* link to zone array */
;;;663            z->z_next = zone_array[zi];
;;;664            zone_array[zi] = z;
;;;665    
;;;666    #ifdef RT_MEM_STATS
;;;667            used_mem += z->z_chunksize;
;;;668            if (used_mem > max_mem)
;;;669                max_mem = used_mem;
;;;670    #endif
;;;671        }
;;;672    
;;;673    done:
;;;674        rt_sem_release(&heap_sem);
;;;675    
;;;676        RT_OBJECT_HOOK_CALL(rt_malloc_hook, ((char *)chunk, size));
;;;677    
;;;678        return chunk;
;;;679    
;;;680    fail:
;;;681        rt_sem_release(&heap_sem);
;;;682    
;;;683        return RT_NULL;
;;;684    }
00000a  e8bd83f8          POP      {r3-r9,pc}
                  |L4.14|
00000e  4995              LDR      r1,|L4.612|
000010  9800              LDR      r0,[sp,#0]            ;508
000012  6809              LDR      r1,[r1,#0]            ;508  ; zone_limit
000014  4288              CMP      r0,r1                 ;508
000016  d33b              BCC      |L4.144|
000018  9800              LDR      r0,[sp,#0]            ;510
00001a  f60070ff          ADD      r0,r0,#0xfff          ;510
00001e  f36f000b          BFC      r0,#0,#12             ;510
000022  9000              STR      r0,[sp,#0]            ;510
000024  9900              LDR      r1,[sp,#0]            ;512
000026  0b08              LSRS     r0,r1,#12             ;512
000028  f7fffffe          BL       rt_page_alloc
00002c  4680              MOV      r8,r0                 ;512
00002e  f1b80f00          CMP      r8,#0                 ;513
000032  d101              BNE      |L4.56|
000034  2000              MOVS     r0,#0                 ;514
000036  e7e8              B        |L4.10|
                  |L4.56|
000038  488b              LDR      r0,|L4.616|
00003a  6800              LDR      r0,[r0,#0]            ;517  ; heap_start
00003c  eba80000          SUB      r0,r8,r0              ;517
000040  0b00              LSRS     r0,r0,#12             ;517
000042  498a              LDR      r1,|L4.620|
000044  6809              LDR      r1,[r1,#0]            ;517  ; memusage
000046  eb010580          ADD      r5,r1,r0,LSL #2       ;517
00004a  6828              LDR      r0,[r5,#0]            ;518
00004c  f0200003          BIC      r0,r0,#3              ;518
000050  1c80              ADDS     r0,r0,#2              ;518
000052  6028              STR      r0,[r5,#0]            ;518
000054  9800              LDR      r0,[sp,#0]            ;519
000056  0b01              LSRS     r1,r0,#12             ;519
000058  6828              LDR      r0,[r5,#0]            ;519
00005a  f361009f          BFI      r0,r1,#2,#30          ;519
00005e  6028              STR      r0,[r5,#0]            ;519
000060  bf00              NOP                            ;521
000062  bf00              NOP                            ;521
000064  f04f31ff          MOV      r1,#0xffffffff        ;528
000068  4881              LDR      r0,|L4.624|
00006a  f7fffffe          BL       rt_sem_take
00006e  4881              LDR      r0,|L4.628|
000070  6800              LDR      r0,[r0,#0]            ;531  ; used_mem
000072  9900              LDR      r1,[sp,#0]            ;531
000074  4408              ADD      r0,r0,r1              ;531
000076  497f              LDR      r1,|L4.628|
000078  6008              STR      r0,[r1,#0]            ;531  ; used_mem
00007a  4608              MOV      r0,r1                 ;532
00007c  6800              LDR      r0,[r0,#0]            ;532  ; used_mem
00007e  497e              LDR      r1,|L4.632|
000080  6809              LDR      r1,[r1,#0]            ;532  ; max_mem
000082  4288              CMP      r0,r1                 ;532
000084  d903              BLS      |L4.142|
000086  487b              LDR      r0,|L4.628|
000088  6800              LDR      r0,[r0,#0]            ;533  ; used_mem
00008a  497b              LDR      r1,|L4.632|
00008c  6008              STR      r0,[r1,#0]            ;533  ; max_mem
                  |L4.142|
00008e  e0d4              B        |L4.570|
                  |L4.144|
000090  f04f31ff          MOV      r1,#0xffffffff        ;539
000094  4876              LDR      r0,|L4.624|
000096  f7fffffe          BL       rt_sem_take
00009a  4668              MOV      r0,sp                 ;549
00009c  f7fffffe          BL       zoneindex
0000a0  4606              MOV      r6,r0                 ;549
0000a2  2e48              CMP      r6,#0x48              ;550
0000a4  db05              BLT      |L4.178|
0000a6  f2402226          MOV      r2,#0x226             ;550
0000aa  4974              LDR      r1,|L4.636|
0000ac  a074              ADR      r0,|L4.640|
0000ae  f7fffffe          BL       rt_assert_handler
                  |L4.178|
0000b2  bf00              NOP                            ;552
0000b4  bf00              NOP                            ;552
0000b6  4875              LDR      r0,|L4.652|
0000b8  f8504026          LDR      r4,[r0,r6,LSL #2]     ;554
0000bc  2c00              CMP      r4,#0                 ;554
0000be  d036              BEQ      |L4.302|
0000c0  6860              LDR      r0,[r4,#4]            ;556
0000c2  2800              CMP      r0,#0                 ;556
0000c4  dc05              BGT      |L4.210|
0000c6  f44f720b          MOV      r2,#0x22c             ;556
0000ca  496c              LDR      r1,|L4.636|
0000cc  a070              ADR      r0,|L4.656|
0000ce  f7fffffe          BL       rt_assert_handler
                  |L4.210|
0000d2  6860              LDR      r0,[r4,#4]            ;559
0000d4  1e40              SUBS     r0,r0,#1              ;559
0000d6  6060              STR      r0,[r4,#4]            ;559
0000d8  b928              CBNZ     r0,|L4.230|
0000da  496c              LDR      r1,|L4.652|
0000dc  68e0              LDR      r0,[r4,#0xc]          ;561
0000de  f8410026          STR      r0,[r1,r6,LSL #2]     ;561
0000e2  2000              MOVS     r0,#0                 ;562
0000e4  60e0              STR      r0,[r4,#0xc]          ;562
                  |L4.230|
0000e6  6960              LDR      r0,[r4,#0x14]         ;571
0000e8  1c40              ADDS     r0,r0,#1              ;571
0000ea  68a1              LDR      r1,[r4,#8]            ;571
0000ec  4288              CMP      r0,r1                 ;571
0000ee  d008              BEQ      |L4.258|
0000f0  6960              LDR      r0,[r4,#0x14]         ;573
0000f2  1c40              ADDS     r0,r0,#1              ;573
0000f4  6160              STR      r0,[r4,#0x14]         ;573
0000f6  e9d40104          LDRD     r0,r1,[r4,#0x10]      ;574
0000fa  9a00              LDR      r2,[sp,#0]            ;574
0000fc  fb010802          MLA      r8,r1,r2,r0           ;574
000100  e004              B        |L4.268|
                  |L4.258|
000102  f8d48020          LDR      r8,[r4,#0x20]         ;579
000106  6a20              LDR      r0,[r4,#0x20]         ;582
000108  6800              LDR      r0,[r0,#0]            ;582
00010a  6220              STR      r0,[r4,#0x20]         ;582
                  |L4.268|
00010c  4959              LDR      r1,|L4.628|
00010e  69a0              LDR      r0,[r4,#0x18]         ;586
000110  6809              LDR      r1,[r1,#0]            ;586  ; used_mem
000112  4408              ADD      r0,r0,r1              ;586
000114  4957              LDR      r1,|L4.628|
000116  6008              STR      r0,[r1,#0]            ;586  ; used_mem
000118  4608              MOV      r0,r1                 ;587
00011a  6800              LDR      r0,[r0,#0]            ;587  ; used_mem
00011c  4956              LDR      r1,|L4.632|
00011e  6809              LDR      r1,[r1,#0]            ;587  ; max_mem
000120  4288              CMP      r0,r1                 ;587
000122  d903              BLS      |L4.300|
000124  4853              LDR      r0,|L4.628|
000126  6800              LDR      r0,[r0,#0]            ;588  ; used_mem
000128  4953              LDR      r1,|L4.632|
00012a  6008              STR      r0,[r1,#0]            ;588  ; max_mem
                  |L4.300|
00012c  e085              B        |L4.570|
                  |L4.302|
00012e  485c              LDR      r0,|L4.672|
000130  6800              LDR      r0,[r0,#0]            ;605  ; zone_free
000132  0004              MOVS     r4,r0                 ;605
000134  d008              BEQ      |L4.328|
000136  495a              LDR      r1,|L4.672|
000138  68e0              LDR      r0,[r4,#0xc]          ;608
00013a  6008              STR      r0,[r1,#0]            ;608  ; zone_free
00013c  4859              LDR      r0,|L4.676|
00013e  6800              LDR      r0,[r0,#0]            ;609  ; zone_free_cnt
000140  1e40              SUBS     r0,r0,#1              ;609
000142  4958              LDR      r1,|L4.676|
000144  6008              STR      r0,[r1,#0]            ;609  ; zone_free_cnt
000146  e02f              B        |L4.424|
                  |L4.328|
000148  4849              LDR      r0,|L4.624|
00014a  f7fffffe          BL       rt_sem_release
00014e  4856              LDR      r0,|L4.680|
000150  f8d09000          LDR      r9,[r0,#0]            ;617  ; zone_size
000154  ea4f71e9          ASR      r1,r9,#31             ;617
000158  eb095111          ADD      r1,r9,r1,LSR #20      ;617
00015c  1308              ASRS     r0,r1,#12             ;617
00015e  f7fffffe          BL       rt_page_alloc
000162  4604              MOV      r4,r0                 ;617
000164  b904              CBNZ     r4,|L4.360|
000166  e077              B        |L4.600|
                  |L4.360|
000168  f04f31ff          MOV      r1,#0xffffffff        ;622
00016c  4840              LDR      r0,|L4.624|
00016e  f7fffffe          BL       rt_sem_take
000172  bf00              NOP                            ;624
000174  bf00              NOP                            ;624
000176  2700              MOVS     r7,#0                 ;628
000178  483b              LDR      r0,|L4.616|
00017a  6800              LDR      r0,[r0,#0]            ;628  ; heap_start
00017c  1a20              SUBS     r0,r4,r0              ;628
00017e  0b00              LSRS     r0,r0,#12             ;628
000180  493a              LDR      r1,|L4.620|
000182  6809              LDR      r1,[r1,#0]            ;628  ; memusage
000184  eb010580          ADD      r5,r1,r0,LSL #2       ;628
000188  e00a              B        |L4.416|
                  |L4.394|
00018a  6828              LDR      r0,[r5,#0]            ;630
00018c  f0200003          BIC      r0,r0,#3              ;630
000190  1c40              ADDS     r0,r0,#1              ;630
000192  6028              STR      r0,[r5,#0]            ;630
000194  6828              LDR      r0,[r5,#0]            ;631
000196  f367009f          BFI      r0,r7,#2,#30          ;631
00019a  6028              STR      r0,[r5,#0]            ;631
00019c  1d2d              ADDS     r5,r5,#4              ;633
00019e  1c7f              ADDS     r7,r7,#1              ;628
                  |L4.416|
0001a0  4842              LDR      r0,|L4.684|
0001a2  6800              LDR      r0,[r0,#0]            ;628  ; zone_page_cnt
0001a4  4287              CMP      r7,r0                 ;628
0001a6  dbf0              BLT      |L4.394|
                  |L4.424|
0001a8  2224              MOVS     r2,#0x24              ;638
0001aa  2100              MOVS     r1,#0                 ;638
0001ac  4620              MOV      r0,r4                 ;638
0001ae  f7fffffe          BL       rt_memset
0001b2  2724              MOVS     r7,#0x24              ;641
0001b4  9800              LDR      r0,[sp,#0]            ;647
0001b6  1e40              SUBS     r0,r0,#1              ;647
0001b8  9900              LDR      r1,[sp,#0]            ;647
0001ba  4308              ORRS     r0,r0,r1              ;647
0001bc  1c40              ADDS     r0,r0,#1              ;647
0001be  ebb00f41          CMP      r0,r1,LSL #1          ;647
0001c2  d107              BNE      |L4.468|
0001c4  9800              LDR      r0,[sp,#0]            ;648
0001c6  4438              ADD      r0,r0,r7              ;648
0001c8  1e40              SUBS     r0,r0,#1              ;648
0001ca  9900              LDR      r1,[sp,#0]            ;648
0001cc  1e49              SUBS     r1,r1,#1              ;648
0001ce  ea200701          BIC      r7,r0,r1              ;648
0001d2  e002              B        |L4.474|
                  |L4.468|
0001d4  1df8              ADDS     r0,r7,#7              ;650
0001d6  f0200707          BIC      r7,r0,#7              ;650
                  |L4.474|
0001da  4835              LDR      r0,|L4.688|
0001dc  6020              STR      r0,[r4,#0]            ;652
0001de  61e6              STR      r6,[r4,#0x1c]         ;653
0001e0  4831              LDR      r0,|L4.680|
0001e2  6800              LDR      r0,[r0,#0]            ;654  ; zone_size
0001e4  1bc0              SUBS     r0,r0,r7              ;654
0001e6  9900              LDR      r1,[sp,#0]            ;654
0001e8  fbb0f0f1          UDIV     r0,r0,r1              ;654
0001ec  60a0              STR      r0,[r4,#8]            ;654
0001ee  68a0              LDR      r0,[r4,#8]            ;655
0001f0  1e40              SUBS     r0,r0,#1              ;655
0001f2  6060              STR      r0,[r4,#4]            ;655
0001f4  19e0              ADDS     r0,r4,r7              ;656
0001f6  6120              STR      r0,[r4,#0x10]         ;656
0001f8  2000              MOVS     r0,#0                 ;657
0001fa  6160              STR      r0,[r4,#0x14]         ;657
0001fc  9800              LDR      r0,[sp,#0]            ;658
0001fe  61a0              STR      r0,[r4,#0x18]         ;658
000200  e9d40104          LDRD     r0,r1,[r4,#0x10]      ;660
000204  9a00              LDR      r2,[sp,#0]            ;660
000206  fb010802          MLA      r8,r1,r2,r0           ;660
00020a  4820              LDR      r0,|L4.652|
00020c  f8500026          LDR      r0,[r0,r6,LSL #2]     ;663
000210  60e0              STR      r0,[r4,#0xc]          ;663
000212  481e              LDR      r0,|L4.652|
000214  f8404026          STR      r4,[r0,r6,LSL #2]     ;664
000218  4916              LDR      r1,|L4.628|
00021a  69a0              LDR      r0,[r4,#0x18]         ;667
00021c  6809              LDR      r1,[r1,#0]            ;667  ; used_mem
00021e  4408              ADD      r0,r0,r1              ;667
000220  4914              LDR      r1,|L4.628|
000222  6008              STR      r0,[r1,#0]            ;667  ; used_mem
000224  4608              MOV      r0,r1                 ;668
000226  6800              LDR      r0,[r0,#0]            ;668  ; used_mem
000228  4913              LDR      r1,|L4.632|
00022a  6809              LDR      r1,[r1,#0]            ;668  ; max_mem
00022c  4288              CMP      r0,r1                 ;668
00022e  d903              BLS      |L4.568|
000230  4810              LDR      r0,|L4.628|
000232  6800              LDR      r0,[r0,#0]            ;669  ; used_mem
000234  4910              LDR      r1,|L4.632|
000236  6008              STR      r0,[r1,#0]            ;669  ; max_mem
                  |L4.568|
000238  bf00              NOP                            ;673
                  |L4.570|
00023a  480d              LDR      r0,|L4.624|
00023c  f7fffffe          BL       rt_sem_release
000240  bf00              NOP                            ;676
000242  481c              LDR      r0,|L4.692|
000244  6800              LDR      r0,[r0,#0]            ;676  ; rt_malloc_hook
000246  b120              CBZ      r0,|L4.594|
000248  4640              MOV      r0,r8                 ;676
00024a  4a1a              LDR      r2,|L4.692|
00024c  9900              LDR      r1,[sp,#0]            ;676
00024e  6812              LDR      r2,[r2,#0]            ;676  ; rt_malloc_hook
000250  4790              BLX      r2                    ;676
                  |L4.594|
000252  bf00              NOP                            ;676
000254  4640              MOV      r0,r8                 ;678
000256  e6d8              B        |L4.10|
                  |L4.600|
000258  4805              LDR      r0,|L4.624|
00025a  f7fffffe          BL       rt_sem_release
00025e  2000              MOVS     r0,#0                 ;683
000260  e6d3              B        |L4.10|
;;;685    RTM_EXPORT(rt_malloc);
                          ENDP

000262  0000              DCW      0x0000
                  |L4.612|
                          DCD      zone_limit
                  |L4.616|
                          DCD      heap_start
                  |L4.620|
                          DCD      memusage
                  |L4.624|
                          DCD      heap_sem
                  |L4.628|
                          DCD      used_mem
                  |L4.632|
                          DCD      max_mem
                  |L4.636|
                          DCD      |symbol_number.46|
                  |L4.640|
000280  7a69203c          DCB      "zi < NZONES",0
000284  204e5a4f
000288  4e455300
                  |L4.652|
                          DCD      zone_array
                  |L4.656|
000290  7a2d3e7a          DCB      "z->z_nfree > 0",0
000294  5f6e6672
000298  6565203e
00029c  203000  
00029f  00                DCB      0
                  |L4.672|
                          DCD      zone_free
                  |L4.676|
                          DCD      zone_free_cnt
                  |L4.680|
                          DCD      zone_size
                  |L4.684|
                          DCD      zone_page_cnt
                  |L4.688|
                          DCD      0x51ab51ab
                  |L4.692|
                          DCD      rt_malloc_hook

                          AREA ||i.rt_malloc_sethook||, CODE, READONLY, ALIGN=2

                  rt_malloc_sethook PROC
;;;91      */
;;;92     void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size))
000000  4901              LDR      r1,|L5.8|
;;;93     {
;;;94         rt_malloc_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_malloc_hook
;;;95     }
000004  4770              BX       lr
;;;96     RTM_EXPORT(rt_malloc_sethook);
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      rt_malloc_hook

                          AREA ||i.rt_memory_info||, CODE, READONLY, ALIGN=2

                  rt_memory_info PROC
;;;938    #ifdef RT_MEM_STATS
;;;939    void rt_memory_info(rt_uint32_t *total,
000000  b510              PUSH     {r4,lr}
;;;940                        rt_uint32_t *used,
;;;941                        rt_uint32_t *max_used)
;;;942    {
;;;943        if (total != RT_NULL)
000002  b128              CBZ      r0,|L6.16|
;;;944            *total = heap_end - heap_start;
000004  4b07              LDR      r3,|L6.36|
000006  681b              LDR      r3,[r3,#0]  ; heap_end
000008  4c07              LDR      r4,|L6.40|
00000a  6824              LDR      r4,[r4,#0]  ; heap_start
00000c  1b1b              SUBS     r3,r3,r4
00000e  6003              STR      r3,[r0,#0]
                  |L6.16|
;;;945    
;;;946        if (used  != RT_NULL)
000010  b111              CBZ      r1,|L6.24|
;;;947            *used = used_mem;
000012  4b06              LDR      r3,|L6.44|
000014  681b              LDR      r3,[r3,#0]  ; used_mem
000016  600b              STR      r3,[r1,#0]
                  |L6.24|
;;;948    
;;;949        if (max_used != RT_NULL)
000018  b112              CBZ      r2,|L6.32|
;;;950            *max_used = max_mem;
00001a  4b05              LDR      r3,|L6.48|
00001c  681b              LDR      r3,[r3,#0]  ; max_mem
00001e  6013              STR      r3,[r2,#0]
                  |L6.32|
;;;951    }
000020  bd10              POP      {r4,pc}
;;;952    
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      heap_end
                  |L6.40|
                          DCD      heap_start
                  |L6.44|
                          DCD      used_mem
                  |L6.48|
                          DCD      max_mem

                          AREA ||i.rt_page_alloc||, CODE, READONLY, ALIGN=2

                  rt_page_alloc PROC
;;;245    
;;;246    void *rt_page_alloc(rt_size_t npages)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;247    {
000004  4605              MOV      r5,r0
;;;248        struct rt_page_head *b, *n;
;;;249        struct rt_page_head **prev;
;;;250    
;;;251        if(npages == 0)
000006  b915              CBNZ     r5,|L7.14|
;;;252            return RT_NULL;
000008  2000              MOVS     r0,#0
                  |L7.10|
;;;253    
;;;254        /* lock heap */
;;;255        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;256        for (prev = &rt_page_list; (b = *prev) != RT_NULL; prev = &(b->next))
;;;257        {
;;;258            if (b->page > npages)
;;;259            {
;;;260                /* splite pages */
;;;261                n       = b + npages;
;;;262                n->next = b->next;
;;;263                n->page = b->page - npages;
;;;264                *prev   = n;
;;;265                break;
;;;266            }
;;;267    
;;;268            if (b->page == npages)
;;;269            {
;;;270                /* this node fit, remove this node */
;;;271                *prev = b->next;
;;;272                break;
;;;273            }
;;;274        }
;;;275    
;;;276        /* unlock heap */
;;;277        rt_sem_release(&heap_sem);
;;;278    
;;;279        return b;
;;;280    }
00000a  e8bd81f0          POP      {r4-r8,pc}
                  |L7.14|
00000e  f04f31ff          MOV      r1,#0xffffffff        ;255
000012  4810              LDR      r0,|L7.84|
000014  f7fffffe          BL       rt_sem_take
000018  4e0f              LDR      r6,|L7.88|
00001a  e012              B        |L7.66|
                  |L7.28|
00001c  6860              LDR      r0,[r4,#4]            ;258
00001e  42a8              CMP      r0,r5                 ;258
000020  d908              BLS      |L7.52|
000022  eb043705          ADD      r7,r4,r5,LSL #12      ;261
000026  6820              LDR      r0,[r4,#0]            ;262
000028  6038              STR      r0,[r7,#0]            ;262
00002a  6860              LDR      r0,[r4,#4]            ;263
00002c  1b40              SUBS     r0,r0,r5              ;263
00002e  6078              STR      r0,[r7,#4]            ;263
000030  6037              STR      r7,[r6,#0]            ;264
000032  e009              B        |L7.72|
                  |L7.52|
000034  6860              LDR      r0,[r4,#4]            ;268
000036  42a8              CMP      r0,r5                 ;268
000038  d102              BNE      |L7.64|
00003a  6820              LDR      r0,[r4,#0]            ;271
00003c  6030              STR      r0,[r6,#0]            ;271
00003e  e003              B        |L7.72|
                  |L7.64|
000040  4626              MOV      r6,r4                 ;256
                  |L7.66|
000042  6834              LDR      r4,[r6,#0]            ;256
000044  2c00              CMP      r4,#0                 ;256
000046  d1e9              BNE      |L7.28|
                  |L7.72|
000048  bf00              NOP                            ;265
00004a  4802              LDR      r0,|L7.84|
00004c  f7fffffe          BL       rt_sem_release
000050  4620              MOV      r0,r4                 ;279
000052  e7da              B        |L7.10|
;;;281    
                          ENDP

                  |L7.84|
                          DCD      heap_sem
                  |L7.88|
                          DCD      rt_page_list

                          AREA ||i.rt_page_free||, CODE, READONLY, ALIGN=2

                  rt_page_free PROC
;;;281    
;;;282    void rt_page_free(void *addr, rt_size_t npages)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;283    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
;;;284        struct rt_page_head *b, *n;
;;;285        struct rt_page_head **prev;
;;;286    
;;;287        RT_ASSERT(addr != RT_NULL);
000008  f1b80f00          CMP      r8,#0
00000c  d105              BNE      |L8.26|
00000e  f240121f          MOV      r2,#0x11f
000012  4932              LDR      r1,|L8.220|
000014  a032              ADR      r0,|L8.224|
000016  f7fffffe          BL       rt_assert_handler
                  |L8.26|
;;;288        RT_ASSERT((rt_uint32_t)addr % RT_MM_PAGE_SIZE == 0);
00001a  f3c8000b          UBFX     r0,r8,#0,#12
00001e  b128              CBZ      r0,|L8.44|
000020  f44f7290          MOV      r2,#0x120
000024  492d              LDR      r1,|L8.220|
000026  a032              ADR      r0,|L8.240|
000028  f7fffffe          BL       rt_assert_handler
                  |L8.44|
;;;289        RT_ASSERT(npages != 0);
00002c  b92e              CBNZ     r6,|L8.58|
00002e  f2401221          MOV      r2,#0x121
000032  492a              LDR      r1,|L8.220|
000034  a039              ADR      r0,|L8.284|
000036  f7fffffe          BL       rt_assert_handler
                  |L8.58|
;;;290    
;;;291        n = (struct rt_page_head *)addr;
00003a  4645              MOV      r5,r8
;;;292    
;;;293        /* lock heap */
;;;294        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
00003c  f04f31ff          MOV      r1,#0xffffffff
000040  4839              LDR      r0,|L8.296|
000042  f7fffffe          BL       rt_sem_take
;;;295    
;;;296        for (prev = &rt_page_list; (b = *prev) != RT_NULL; prev = &(b->next))
000046  4f39              LDR      r7,|L8.300|
000048  e03b              B        |L8.194|
                  |L8.74|
;;;297        {
;;;298            RT_ASSERT(b->page > 0);
00004a  6860              LDR      r0,[r4,#4]
00004c  b928              CBNZ     r0,|L8.90|
00004e  f44f7295          MOV      r2,#0x12a
000052  4922              LDR      r1,|L8.220|
000054  a036              ADR      r0,|L8.304|
000056  f7fffffe          BL       rt_assert_handler
                  |L8.90|
;;;299            RT_ASSERT(b > n || b + b->page <= n);
00005a  42ac              CMP      r4,r5
00005c  d80a              BHI      |L8.116|
00005e  6860              LDR      r0,[r4,#4]
000060  eb043000          ADD      r0,r4,r0,LSL #12
000064  42a8              CMP      r0,r5
000066  d905              BLS      |L8.116|
000068  f240122b          MOV      r2,#0x12b
00006c  491b              LDR      r1,|L8.220|
00006e  a033              ADR      r0,|L8.316|
000070  f7fffffe          BL       rt_assert_handler
                  |L8.116|
;;;300    
;;;301            if (b + b->page == n)
000074  6860              LDR      r0,[r4,#4]
000076  eb043000          ADD      r0,r4,r0,LSL #12
00007a  42a8              CMP      r0,r5
00007c  d110              BNE      |L8.160|
;;;302            {
;;;303                if (b + (b->page += npages) == b->next)
00007e  6860              LDR      r0,[r4,#4]
000080  4430              ADD      r0,r0,r6
000082  6060              STR      r0,[r4,#4]
000084  eb043000          ADD      r0,r4,r0,LSL #12
000088  6821              LDR      r1,[r4,#0]
00008a  4288              CMP      r0,r1
00008c  d107              BNE      |L8.158|
;;;304                {
;;;305                    b->page += b->next->page;
00008e  e9d41000          LDRD     r1,r0,[r4,#0]
000092  6849              LDR      r1,[r1,#4]
000094  4408              ADD      r0,r0,r1
000096  6060              STR      r0,[r4,#4]
;;;306                    b->next  = b->next->next;
000098  6820              LDR      r0,[r4,#0]
00009a  6800              LDR      r0,[r0,#0]
00009c  6020              STR      r0,[r4,#0]
                  |L8.158|
;;;307                }
;;;308    
;;;309                goto _return;
00009e  e018              B        |L8.210|
                  |L8.160|
;;;310            }
;;;311    
;;;312            if (b == n + npages)
0000a0  eb053006          ADD      r0,r5,r6,LSL #12
0000a4  42a0              CMP      r0,r4
0000a6  d106              BNE      |L8.182|
;;;313            {
;;;314                n->page = b->page + npages;
0000a8  6860              LDR      r0,[r4,#4]
0000aa  4430              ADD      r0,r0,r6
0000ac  6068              STR      r0,[r5,#4]
;;;315                n->next = b->next;
0000ae  6820              LDR      r0,[r4,#0]
0000b0  6028              STR      r0,[r5,#0]
;;;316                *prev   = n;
0000b2  603d              STR      r5,[r7,#0]
;;;317    
;;;318                goto _return;
0000b4  e00d              B        |L8.210|
                  |L8.182|
;;;319            }
;;;320    
;;;321            if (b > n + npages)
0000b6  eb053006          ADD      r0,r5,r6,LSL #12
0000ba  42a0              CMP      r0,r4
0000bc  d200              BCS      |L8.192|
;;;322                break;
0000be  e003              B        |L8.200|
                  |L8.192|
0000c0  4627              MOV      r7,r4                 ;296
                  |L8.194|
0000c2  683c              LDR      r4,[r7,#0]            ;296
0000c4  2c00              CMP      r4,#0                 ;296
0000c6  d1c0              BNE      |L8.74|
                  |L8.200|
0000c8  bf00              NOP      
;;;323        }
;;;324    
;;;325        n->page = npages;
0000ca  606e              STR      r6,[r5,#4]
;;;326        n->next = b;
0000cc  602c              STR      r4,[r5,#0]
;;;327        *prev   = n;
0000ce  603d              STR      r5,[r7,#0]
;;;328    
;;;329    _return:
0000d0  bf00              NOP      
                  |L8.210|
;;;330        /* unlock heap */
;;;331        rt_sem_release(&heap_sem);
0000d2  4815              LDR      r0,|L8.296|
0000d4  f7fffffe          BL       rt_sem_release
;;;332    }
0000d8  e8bd81f0          POP      {r4-r8,pc}
;;;333    
                          ENDP

                  |L8.220|
                          DCD      __FUNCTION__
                  |L8.224|
0000e0  61646472          DCB      "addr != RT_NULL",0
0000e4  20213d20
0000e8  52545f4e
0000ec  554c4c00
                  |L8.240|
0000f0  2872745f          DCB      "(rt_uint32_t)addr % RT_MM_PAGE_SIZE == 0",0
0000f4  75696e74
0000f8  33325f74
0000fc  29616464
000100  72202520
000104  52545f4d
000108  4d5f5041
00010c  47455f53
000110  495a4520
000114  3d3d2030
000118  00      
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L8.284|
00011c  6e706167          DCB      "npages != 0",0
000120  65732021
000124  3d203000
                  |L8.296|
                          DCD      heap_sem
                  |L8.300|
                          DCD      rt_page_list
                  |L8.304|
000130  622d3e70          DCB      "b->page > 0",0
000134  61676520
000138  3e203000
                  |L8.316|
00013c  62203e20          DCB      "b > n || b + b->page <= n",0
000140  6e207c7c
000144  2062202b
000148  20622d3e
00014c  70616765
000150  203c3d20
000154  6e00    
000156  00                DCB      0
000157  00                DCB      0

                          AREA ||i.rt_page_init||, CODE, READONLY, ALIGN=2

                  rt_page_init PROC
;;;336     */
;;;337    static void rt_page_init(void *addr, rt_size_t npages)
000000  b570              PUSH     {r4-r6,lr}
;;;338    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;339        RT_ASSERT(addr != RT_NULL);
000006  b92d              CBNZ     r5,|L9.20|
000008  f2401253          MOV      r2,#0x153
00000c  4909              LDR      r1,|L9.52|
00000e  a00a              ADR      r0,|L9.56|
000010  f7fffffe          BL       rt_assert_handler
                  |L9.20|
;;;340        RT_ASSERT(npages != 0);
000014  b92c              CBNZ     r4,|L9.34|
000016  f44f72aa          MOV      r2,#0x154
00001a  4906              LDR      r1,|L9.52|
00001c  a00a              ADR      r0,|L9.72|
00001e  f7fffffe          BL       rt_assert_handler
                  |L9.34|
;;;341    
;;;342        rt_page_list = RT_NULL;
000022  2000              MOVS     r0,#0
000024  490b              LDR      r1,|L9.84|
000026  6008              STR      r0,[r1,#0]  ; rt_page_list
;;;343        rt_page_free(addr, npages);
000028  4621              MOV      r1,r4
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       rt_page_free
;;;344    }
000030  bd70              POP      {r4-r6,pc}
;;;345    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      |symbol_number.44|
                  |L9.56|
000038  61646472          DCB      "addr != RT_NULL",0
00003c  20213d20
000040  52545f4e
000044  554c4c00
                  |L9.72|
000048  6e706167          DCB      "npages != 0",0
00004c  65732021
000050  3d203000
                  |L9.84|
                          DCD      rt_page_list

                          AREA ||i.rt_realloc||, CODE, READONLY, ALIGN=2

                  rt_realloc PROC
;;;694     */
;;;695    void *rt_realloc(void *ptr, rt_size_t size)
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;696    {
000004  4604              MOV      r4,r0
;;;697        void *nptr;
;;;698        slab_zone *z;
;;;699        struct memusage *kup;
;;;700    
;;;701        if (ptr == RT_NULL)
000006  b924              CBNZ     r4,|L10.18|
;;;702            return rt_malloc(size);
000008  9801              LDR      r0,[sp,#4]
00000a  f7fffffe          BL       rt_malloc
                  |L10.14|
;;;703        if (size == 0)
;;;704        {
;;;705            rt_free(ptr);
;;;706    
;;;707            return RT_NULL;
;;;708        }
;;;709    
;;;710    #ifdef RT_USING_MODULE
;;;711        if (rt_module_self() != RT_NULL)
;;;712            return rt_module_realloc(ptr, size);
;;;713    #endif
;;;714    
;;;715        /*
;;;716         * Get the original allocation's zone.  If the new request winds up
;;;717         * using the same chunk size we do not have to do anything.
;;;718         */
;;;719        kup = btokup((rt_uint32_t)ptr & ~RT_MM_PAGE_MASK);
;;;720        if (kup->type == PAGE_TYPE_LARGE)
;;;721        {
;;;722            rt_size_t osize;
;;;723    
;;;724            osize = kup->size << RT_MM_PAGE_BITS;
;;;725            if ((nptr = rt_malloc(size)) == RT_NULL)
;;;726                return RT_NULL;
;;;727            rt_memcpy(nptr, ptr, size > osize ? osize : size);
;;;728            rt_free(ptr);
;;;729    
;;;730            return nptr;
;;;731        }
;;;732        else if (kup->type == PAGE_TYPE_SMALL)
;;;733        {
;;;734            z = (slab_zone *)(((rt_uint32_t)ptr & ~RT_MM_PAGE_MASK) -
;;;735                              kup->size * RT_MM_PAGE_SIZE);
;;;736            RT_ASSERT(z->z_magic == ZALLOC_SLAB_MAGIC);
;;;737    
;;;738            zoneindex(&size);
;;;739            if (z->z_chunksize == size)
;;;740                return(ptr); /* same chunk */
;;;741    
;;;742            /*
;;;743             * Allocate memory for the new request size.  Note that zoneindex has
;;;744             * already adjusted the request size to the appropriate chunk size, which
;;;745             * should optimize our bcopy().  Then copy and return the new pointer.
;;;746             */
;;;747            if ((nptr = rt_malloc(size)) == RT_NULL)
;;;748                return RT_NULL;
;;;749    
;;;750            rt_memcpy(nptr, ptr, size > z->z_chunksize ? z->z_chunksize : size);
;;;751            rt_free(ptr);
;;;752    
;;;753            return nptr;
;;;754        }
;;;755    
;;;756        return RT_NULL;
;;;757    }
00000e  e8bd81fc          POP      {r2-r8,pc}
                  |L10.18|
000012  9801              LDR      r0,[sp,#4]            ;703
000014  b920              CBNZ     r0,|L10.32|
000016  4620              MOV      r0,r4                 ;705
000018  f7fffffe          BL       rt_free
00001c  2000              MOVS     r0,#0                 ;707
00001e  e7f6              B        |L10.14|
                  |L10.32|
000020  0b20              LSRS     r0,r4,#12             ;719
000022  0300              LSLS     r0,r0,#12             ;719
000024  492f              LDR      r1,|L10.228|
000026  6809              LDR      r1,[r1,#0]            ;719  ; heap_start
000028  1a40              SUBS     r0,r0,r1              ;719
00002a  0b00              LSRS     r0,r0,#12             ;719
00002c  492e              LDR      r1,|L10.232|
00002e  6809              LDR      r1,[r1,#0]            ;719  ; memusage
000030  eb010680          ADD      r6,r1,r0,LSL #2       ;719
000034  7830              LDRB     r0,[r6,#0]            ;720
000036  f0000003          AND      r0,r0,#3              ;720
00003a  2802              CMP      r0,#2                 ;720
00003c  d119              BNE      |L10.114|
00003e  6830              LDR      r0,[r6,#0]            ;724
000040  0880              LSRS     r0,r0,#2              ;724
000042  0307              LSLS     r7,r0,#12             ;724
000044  9801              LDR      r0,[sp,#4]            ;725
000046  f7fffffe          BL       rt_malloc
00004a  ea5f0800          MOVS     r8,r0                 ;725
00004e  d100              BNE      |L10.82|
000050  e7dd              B        |L10.14|
                  |L10.82|
000052  9801              LDR      r0,[sp,#4]            ;727
000054  42b8              CMP      r0,r7                 ;727
000056  d901              BLS      |L10.92|
000058  4638              MOV      r0,r7                 ;727
00005a  e000              B        |L10.94|
                  |L10.92|
00005c  9801              LDR      r0,[sp,#4]            ;727
                  |L10.94|
00005e  4602              MOV      r2,r0                 ;727
000060  4621              MOV      r1,r4                 ;727
000062  4640              MOV      r0,r8                 ;727
000064  f7fffffe          BL       rt_memcpy
000068  4620              MOV      r0,r4                 ;728
00006a  f7fffffe          BL       rt_free
00006e  4640              MOV      r0,r8                 ;730
000070  e7cd              B        |L10.14|
                  |L10.114|
000072  7830              LDRB     r0,[r6,#0]            ;732
000074  f0000003          AND      r0,r0,#3              ;732
000078  2801              CMP      r0,#1                 ;732
00007a  d130              BNE      |L10.222|
00007c  0b21              LSRS     r1,r4,#12             ;734
00007e  0309              LSLS     r1,r1,#12             ;734
000080  6830              LDR      r0,[r6,#0]            ;734
000082  0880              LSRS     r0,r0,#2              ;734
000084  eba13500          SUB      r5,r1,r0,LSL #12      ;734
000088  4918              LDR      r1,|L10.236|
00008a  6828              LDR      r0,[r5,#0]            ;736
00008c  4288              CMP      r0,r1                 ;736
00008e  d005              BEQ      |L10.156|
000090  f44f7238          MOV      r2,#0x2e0             ;736
000094  4916              LDR      r1,|L10.240|
000096  a017              ADR      r0,|L10.244|
000098  f7fffffe          BL       rt_assert_handler
                  |L10.156|
00009c  a801              ADD      r0,sp,#4              ;738
00009e  f7fffffe          BL       zoneindex
0000a2  69a8              LDR      r0,[r5,#0x18]         ;739
0000a4  9901              LDR      r1,[sp,#4]            ;739
0000a6  4288              CMP      r0,r1                 ;739
0000a8  d101              BNE      |L10.174|
0000aa  4620              MOV      r0,r4                 ;740
0000ac  e7af              B        |L10.14|
                  |L10.174|
0000ae  9801              LDR      r0,[sp,#4]            ;747
0000b0  f7fffffe          BL       rt_malloc
0000b4  ea5f0800          MOVS     r8,r0                 ;747
0000b8  d100              BNE      |L10.188|
0000ba  e7a8              B        |L10.14|
                  |L10.188|
0000bc  69a8              LDR      r0,[r5,#0x18]         ;750
0000be  9901              LDR      r1,[sp,#4]            ;750
0000c0  4288              CMP      r0,r1                 ;750
0000c2  d201              BCS      |L10.200|
0000c4  69a8              LDR      r0,[r5,#0x18]         ;750
0000c6  e000              B        |L10.202|
                  |L10.200|
0000c8  9801              LDR      r0,[sp,#4]            ;750
                  |L10.202|
0000ca  4602              MOV      r2,r0                 ;750
0000cc  4621              MOV      r1,r4                 ;750
0000ce  4640              MOV      r0,r8                 ;750
0000d0  f7fffffe          BL       rt_memcpy
0000d4  4620              MOV      r0,r4                 ;751
0000d6  f7fffffe          BL       rt_free
0000da  4640              MOV      r0,r8                 ;753
0000dc  e797              B        |L10.14|
                  |L10.222|
0000de  2000              MOVS     r0,#0                 ;756
0000e0  e795              B        |L10.14|
;;;758    RTM_EXPORT(rt_realloc);
                          ENDP

0000e2  0000              DCW      0x0000
                  |L10.228|
                          DCD      heap_start
                  |L10.232|
                          DCD      memusage
                  |L10.236|
                          DCD      0x51ab51ab
                  |L10.240|
                          DCD      |symbol_number.47|
                  |L10.244|
0000f4  7a2d3e7a          DCB      "z->z_magic == ZALLOC_SLAB_MAGIC",0
0000f8  5f6d6167
0000fc  6963203d
000100  3d205a41
000104  4c4c4f43
000108  5f534c41
00010c  425f4d41
000110  47494300

                          AREA ||i.rt_system_heap_init||, CODE, READONLY, ALIGN=2

                  rt_system_heap_init PROC
;;;353     */
;;;354    void rt_system_heap_init(void *begin_addr, void *end_addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;355    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;356        rt_uint32_t limsize, npages;
;;;357    
;;;358        RT_DEBUG_NOT_IN_INTERRUPT;
000008  bf00              NOP      
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4680              MOV      r8,r0
000010  f7fffffe          BL       rt_interrupt_get_nest
000014  b148              CBZ      r0,|L11.42|
000016  493a              LDR      r1,|L11.256|
000018  a03a              ADR      r0,|L11.260|
00001a  f7fffffe          BL       rt_kprintf
00001e  f44f72b3          MOV      r2,#0x166
000022  4937              LDR      r1,|L11.256|
000024  a040              ADR      r0,|L11.296|
000026  f7fffffe          BL       rt_assert_handler
                  |L11.42|
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       rt_hw_interrupt_enable
000030  bf00              NOP      
;;;359    
;;;360        /* align begin and end addr to page */
;;;361        heap_start = RT_ALIGN((rt_uint32_t)begin_addr, RT_MM_PAGE_SIZE);
000032  f60570ff          ADD      r0,r5,#0xfff
000036  f36f000b          BFC      r0,#0,#12
00003a  493c              LDR      r1,|L11.300|
00003c  6008              STR      r0,[r1,#0]  ; heap_start
;;;362        heap_end   = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_MM_PAGE_SIZE);
00003e  0b30              LSRS     r0,r6,#12
000040  0300              LSLS     r0,r0,#12
000042  493b              LDR      r1,|L11.304|
000044  6008              STR      r0,[r1,#0]  ; heap_end
;;;363    
;;;364        if (heap_start >= heap_end)
000046  4839              LDR      r0,|L11.300|
000048  6800              LDR      r0,[r0,#0]  ; heap_start
00004a  6809              LDR      r1,[r1,#0]  ; heap_end
00004c  4288              CMP      r0,r1
00004e  d306              BCC      |L11.94|
;;;365        {
;;;366            rt_kprintf("rt_system_heap_init, wrong address[0x%x - 0x%x]\n",
000050  4632              MOV      r2,r6
000052  4629              MOV      r1,r5
000054  a037              ADR      r0,|L11.308|
000056  f7fffffe          BL       rt_kprintf
                  |L11.90|
;;;367                       (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);
;;;368    
;;;369            return;
;;;370        }
;;;371    
;;;372        limsize = heap_end - heap_start;
;;;373        npages  = limsize / RT_MM_PAGE_SIZE;
;;;374    
;;;375        /* initialize heap semaphore */
;;;376        rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
;;;377    
;;;378        RT_DEBUG_LOG(RT_DEBUG_SLAB, ("heap[0x%x - 0x%x], size 0x%x, 0x%x pages\n",
;;;379                                     heap_start, heap_end, limsize, npages));
;;;380    
;;;381        /* init pages */
;;;382        rt_page_init((void *)heap_start, npages);
;;;383    
;;;384        /* calculate zone size */
;;;385        zone_size = ZALLOC_MIN_ZONE_SIZE;
;;;386        while (zone_size < ZALLOC_MAX_ZONE_SIZE && (zone_size << 1) < (limsize/1024))
;;;387            zone_size <<= 1;
;;;388    
;;;389        zone_limit = zone_size / 4;
;;;390        if (zone_limit > ZALLOC_ZONE_LIMIT)
;;;391            zone_limit = ZALLOC_ZONE_LIMIT;
;;;392    
;;;393        zone_page_cnt = zone_size / RT_MM_PAGE_SIZE;
;;;394    
;;;395        RT_DEBUG_LOG(RT_DEBUG_SLAB, ("zone size 0x%x, zone page count 0x%x\n",
;;;396                                     zone_size, zone_page_cnt));
;;;397    
;;;398        /* allocate memusage array */
;;;399        limsize  = npages * sizeof(struct memusage);
;;;400        limsize  = RT_ALIGN(limsize, RT_MM_PAGE_SIZE);
;;;401        memusage = rt_page_alloc(limsize/RT_MM_PAGE_SIZE);
;;;402    
;;;403        RT_DEBUG_LOG(RT_DEBUG_SLAB, ("memusage 0x%x, size 0x%x\n",
;;;404                                     (rt_uint32_t)memusage, limsize));
;;;405    }
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L11.94|
00005e  4834              LDR      r0,|L11.304|
000060  6800              LDR      r0,[r0,#0]            ;372  ; heap_end
000062  4932              LDR      r1,|L11.300|
000064  6809              LDR      r1,[r1,#0]            ;372  ; heap_start
000066  1a44              SUBS     r4,r0,r1              ;372
000068  0b27              LSRS     r7,r4,#12             ;373
00006a  2300              MOVS     r3,#0                 ;376
00006c  2201              MOVS     r2,#1                 ;376
00006e  a13e              ADR      r1,|L11.360|
000070  483f              LDR      r0,|L11.368|
000072  f7fffffe          BL       rt_sem_init
000076  bf00              NOP                            ;378
000078  bf00              NOP                            ;378
00007a  4639              MOV      r1,r7                 ;382
00007c  482b              LDR      r0,|L11.300|
00007e  6800              LDR      r0,[r0,#0]            ;382  ; heap_start
000080  f7fffffe          BL       rt_page_init
000084  f44f4000          MOV      r0,#0x8000            ;385
000088  493a              LDR      r1,|L11.372|
00008a  6008              STR      r0,[r1,#0]            ;385  ; zone_size
00008c  e004              B        |L11.152|
                  |L11.142|
00008e  4839              LDR      r0,|L11.372|
000090  6800              LDR      r0,[r0,#0]            ;387  ; zone_size
000092  0040              LSLS     r0,r0,#1              ;387
000094  4937              LDR      r1,|L11.372|
000096  6008              STR      r0,[r1,#0]            ;387  ; zone_size
                  |L11.152|
000098  4836              LDR      r0,|L11.372|
00009a  6800              LDR      r0,[r0,#0]            ;386  ; zone_size
00009c  f5b03f00          CMP      r0,#0x20000           ;386
0000a0  da05              BGE      |L11.174|
0000a2  4834              LDR      r0,|L11.372|
0000a4  6800              LDR      r0,[r0,#0]            ;386  ; zone_size
0000a6  0040              LSLS     r0,r0,#1              ;386
0000a8  ebb02f94          CMP      r0,r4,LSR #10         ;386
0000ac  d3ef              BCC      |L11.142|
                  |L11.174|
0000ae  4931              LDR      r1,|L11.372|
0000b0  6808              LDR      r0,[r1,#0]            ;389  ; zone_size
0000b2  17c1              ASRS     r1,r0,#31             ;389
0000b4  eb007191          ADD      r1,r0,r1,LSR #30      ;389
0000b8  1089              ASRS     r1,r1,#2              ;389
0000ba  4a2f              LDR      r2,|L11.376|
0000bc  6011              STR      r1,[r2,#0]            ;389  ; zone_limit
0000be  4610              MOV      r0,r2                 ;390
0000c0  6800              LDR      r0,[r0,#0]            ;390  ; zone_limit
0000c2  f5b04f80          CMP      r0,#0x4000            ;390
0000c6  dd03              BLE      |L11.208|
0000c8  f44f4080          MOV      r0,#0x4000            ;391
0000cc  4611              MOV      r1,r2                 ;391
0000ce  6008              STR      r0,[r1,#0]            ;391  ; zone_limit
                  |L11.208|
0000d0  4928              LDR      r1,|L11.372|
0000d2  6808              LDR      r0,[r1,#0]            ;393  ; zone_size
0000d4  17c1              ASRS     r1,r0,#31             ;393
0000d6  eb005111          ADD      r1,r0,r1,LSR #20      ;393
0000da  1309              ASRS     r1,r1,#12             ;393
0000dc  4a27              LDR      r2,|L11.380|
0000de  6011              STR      r1,[r2,#0]            ;393  ; zone_page_cnt
0000e0  bf00              NOP                            ;395
0000e2  bf00              NOP                            ;395
0000e4  00bc              LSLS     r4,r7,#2              ;399
0000e6  f60470ff          ADD      r0,r4,#0xfff          ;400
0000ea  0b04              LSRS     r4,r0,#12             ;400
0000ec  0324              LSLS     r4,r4,#12             ;400
0000ee  0b20              LSRS     r0,r4,#12             ;401
0000f0  f7fffffe          BL       rt_page_alloc
0000f4  4922              LDR      r1,|L11.384|
0000f6  6008              STR      r0,[r1,#0]            ;401  ; memusage
0000f8  bf00              NOP                            ;403
0000fa  bf00              NOP                            ;403
0000fc  bf00              NOP      
0000fe  e7ac              B        |L11.90|
;;;406    
                          ENDP

                  |L11.256|
                          DCD      |symbol_number.45|
                  |L11.260|
000104  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000108  74696f6e
00010c  5b25735d
000110  20736861
000114  6c6c206e
000118  6f742075
00011c  73656420
000120  696e2049
000124  53520a00
                  |L11.296|
000128  3000              DCB      "0",0
00012a  00                DCB      0
00012b  00                DCB      0
                  |L11.300|
                          DCD      heap_start
                  |L11.304|
                          DCD      heap_end
                  |L11.308|
000134  72745f73          DCB      "rt_system_heap_init, wrong address[0x%x - 0x%x]\n",0
000138  79737465
00013c  6d5f6865
000140  61705f69
000144  6e69742c
000148  2077726f
00014c  6e672061
000150  64647265
000154  73735b30
000158  78257820
00015c  2d203078
000160  25785d0a
000164  00      
000165  00                DCB      0
000166  00                DCB      0
000167  00                DCB      0
                  |L11.360|
000168  68656170          DCB      "heap",0
00016c  00      
00016d  00                DCB      0
00016e  00                DCB      0
00016f  00                DCB      0
                  |L11.368|
                          DCD      heap_sem
                  |L11.372|
                          DCD      zone_size
                  |L11.376|
                          DCD      zone_limit
                  |L11.380|
                          DCD      zone_page_cnt
                  |L11.384|
                          DCD      memusage

                          AREA ||i.zoneindex||, CODE, READONLY, ALIGN=2

                  zoneindex PROC
;;;410     */
;;;411    rt_inline int zoneindex(rt_uint32_t *bytes)
000000  b570              PUSH     {r4-r6,lr}
;;;412    {
000002  4605              MOV      r5,r0
;;;413        /* unsigned for shift opt */
;;;414        rt_uint32_t n = (rt_uint32_t)*bytes;
000004  682c              LDR      r4,[r5,#0]
;;;415    
;;;416        if (n < 128)
000006  2c80              CMP      r4,#0x80
000008  d208              BCS      |L12.28|
;;;417        {
;;;418            *bytes = n = (n + 7) & ~7;
00000a  1de0              ADDS     r0,r4,#7
00000c  f0200007          BIC      r0,r0,#7
000010  4604              MOV      r4,r0
000012  6028              STR      r0,[r5,#0]
;;;419    
;;;420            /* 8 byte chunks, 16 zones */
;;;421            return(n / 8 - 1);
000014  2001              MOVS     r0,#1
000016  ebc000d4          RSB      r0,r0,r4,LSR #3
                  |L12.26|
;;;422        }
;;;423        if (n < 256)
;;;424        {
;;;425            *bytes = n = (n + 15) & ~15;
;;;426    
;;;427            return(n / 16 + 7);
;;;428        }
;;;429        if (n < 8192)
;;;430        {
;;;431            if (n < 512)
;;;432            {
;;;433                *bytes = n = (n + 31) & ~31;
;;;434    
;;;435                return(n / 32 + 15);
;;;436            }
;;;437            if (n < 1024)
;;;438            {
;;;439                *bytes = n = (n + 63) & ~63;
;;;440    
;;;441                return(n / 64 + 23);
;;;442            }
;;;443            if (n < 2048)
;;;444            {
;;;445                *bytes = n = (n + 127) & ~127;
;;;446    
;;;447                return(n / 128 + 31);
;;;448            }
;;;449            if (n < 4096)
;;;450            {
;;;451                *bytes = n = (n + 255) & ~255;
;;;452    
;;;453                return(n / 256 + 39);
;;;454            }
;;;455            *bytes = n = (n + 511) & ~511;
;;;456    
;;;457            return(n / 512 + 47);
;;;458        }
;;;459        if (n < 16384)
;;;460        {
;;;461            *bytes = n = (n + 1023) & ~1023;
;;;462    
;;;463            return(n / 1024 + 55);
;;;464        }
;;;465    
;;;466        rt_kprintf("Unexpected byte count %d", n);
;;;467    
;;;468        return 0;
;;;469    }
00001a  bd70              POP      {r4-r6,pc}
                  |L12.28|
00001c  2cff              CMP      r4,#0xff              ;423
00001e  d808              BHI      |L12.50|
000020  f104000f          ADD      r0,r4,#0xf            ;425
000024  f020000f          BIC      r0,r0,#0xf            ;425
000028  4604              MOV      r4,r0                 ;425
00002a  6028              STR      r0,[r5,#0]            ;425
00002c  0920              LSRS     r0,r4,#4              ;427
00002e  1dc0              ADDS     r0,r0,#7              ;427
000030  e7f3              B        |L12.26|
                  |L12.50|
000032  f5b45f00          CMP      r4,#0x2000            ;429
000036  d238              BCS      |L12.170|
000038  f5b47f00          CMP      r4,#0x200             ;431
00003c  d208              BCS      |L12.80|
00003e  f104001f          ADD      r0,r4,#0x1f           ;433
000042  f020001f          BIC      r0,r0,#0x1f           ;433
000046  4604              MOV      r4,r0                 ;433
000048  6028              STR      r0,[r5,#0]            ;433
00004a  0960              LSRS     r0,r4,#5              ;435
00004c  300f              ADDS     r0,r0,#0xf            ;435
00004e  e7e4              B        |L12.26|
                  |L12.80|
000050  f5b46f80          CMP      r4,#0x400             ;437
000054  d208              BCS      |L12.104|
000056  f104003f          ADD      r0,r4,#0x3f           ;439
00005a  f020003f          BIC      r0,r0,#0x3f           ;439
00005e  4604              MOV      r4,r0                 ;439
000060  6028              STR      r0,[r5,#0]            ;439
000062  09a0              LSRS     r0,r4,#6              ;441
000064  3017              ADDS     r0,r0,#0x17           ;441
000066  e7d8              B        |L12.26|
                  |L12.104|
000068  f5b46f00          CMP      r4,#0x800             ;443
00006c  d208              BCS      |L12.128|
00006e  f104007f          ADD      r0,r4,#0x7f           ;445
000072  f020007f          BIC      r0,r0,#0x7f           ;445
000076  4604              MOV      r4,r0                 ;445
000078  6028              STR      r0,[r5,#0]            ;445
00007a  09e0              LSRS     r0,r4,#7              ;447
00007c  301f              ADDS     r0,r0,#0x1f           ;447
00007e  e7cc              B        |L12.26|
                  |L12.128|
000080  f5b45f80          CMP      r4,#0x1000            ;449
000084  d208              BCS      |L12.152|
000086  f10400ff          ADD      r0,r4,#0xff           ;451
00008a  f02000ff          BIC      r0,r0,#0xff           ;451
00008e  4604              MOV      r4,r0                 ;451
000090  6028              STR      r0,[r5,#0]            ;451
000092  0a20              LSRS     r0,r4,#8              ;453
000094  3027              ADDS     r0,r0,#0x27           ;453
000096  e7c0              B        |L12.26|
                  |L12.152|
000098  f20410ff          ADD      r0,r4,#0x1ff          ;455
00009c  f36f0008          BFC      r0,#0,#9              ;455
0000a0  4604              MOV      r4,r0                 ;455
0000a2  6028              STR      r0,[r5,#0]            ;455
0000a4  0a60              LSRS     r0,r4,#9              ;457
0000a6  302f              ADDS     r0,r0,#0x2f           ;457
0000a8  e7b7              B        |L12.26|
                  |L12.170|
0000aa  f5b44f80          CMP      r4,#0x4000            ;459
0000ae  d208              BCS      |L12.194|
0000b0  f20430ff          ADD      r0,r4,#0x3ff          ;461
0000b4  f36f0009          BFC      r0,#0,#10             ;461
0000b8  4604              MOV      r4,r0                 ;461
0000ba  6028              STR      r0,[r5,#0]            ;461
0000bc  0aa0              LSRS     r0,r4,#10             ;463
0000be  3037              ADDS     r0,r0,#0x37           ;463
0000c0  e7ab              B        |L12.26|
                  |L12.194|
0000c2  4621              MOV      r1,r4                 ;466
0000c4  a002              ADR      r0,|L12.208|
0000c6  f7fffffe          BL       rt_kprintf
0000ca  2000              MOVS     r0,#0                 ;468
0000cc  e7a5              B        |L12.26|
;;;470    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L12.208|
0000d0  556e6578          DCB      "Unexpected byte count %d",0
0000d4  70656374
0000d8  65642062
0000dc  79746520
0000e0  636f756e
0000e4  74202564
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  zone_array
                          %        288
                  heap_sem
                          %        32

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f70          DCB      0x72,0x74,0x5f,0x70
000004  6167655f          DCB      0x61,0x67,0x65,0x5f
000008  66726565          DCB      0x66,0x72,0x65,0x65
00000c  00                DCB      0x00
                  |symbol_number.44|
00000d  72745f            DCB      0x72,0x74,0x5f
000010  70616765          DCB      0x70,0x61,0x67,0x65
000014  5f696e69          DCB      0x5f,0x69,0x6e,0x69
000018  7400              DCB      0x74,0x00
                  |symbol_number.45|
00001a  7274              DCB      0x72,0x74
00001c  5f737973          DCB      0x5f,0x73,0x79,0x73
000020  74656d5f          DCB      0x74,0x65,0x6d,0x5f
000024  68656170          DCB      0x68,0x65,0x61,0x70
000028  5f696e69          DCB      0x5f,0x69,0x6e,0x69
00002c  7400              DCB      0x74,0x00
                  |symbol_number.46|
00002e  7274              DCB      0x72,0x74
000030  5f6d616c          DCB      0x5f,0x6d,0x61,0x6c
000034  6c6f6300          DCB      0x6c,0x6f,0x63,0x00
                  |symbol_number.47|
000038  72745f72          DCB      0x72,0x74,0x5f,0x72
00003c  65616c6c          DCB      0x65,0x61,0x6c,0x6c
000040  6f6300            DCB      0x6f,0x63,0x00
                  |symbol_number.48|
000043  72                DCB      0x72
000044  745f6672          DCB      0x74,0x5f,0x66,0x72
000048  656500            DCB      0x65,0x65,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  used_mem
                          DCD      0x00000000
                  max_mem
                          DCD      0x00000000
                  rt_malloc_hook
                          DCD      0x00000000
                  rt_free_hook
                          DCD      0x00000000
                  zone_free
                          DCD      0x00000000
                  zone_free_cnt
                          DCD      0x00000000
                  zone_size
                          DCD      0x00000000
                  zone_limit
                          DCD      0x00000000
                  zone_page_cnt
                          DCD      0x00000000
                  memusage
                          DCD      0x00000000
                  heap_start
                          DCD      0x00000000
                  heap_end
                          DCD      0x00000000
                  rt_page_list
                          DCD      0x00000000
