; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\system_stm32f10x.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\system_stm32f10x.crf ..\cortex-m3\system_stm32f10x.c]
                          THUMB

                          AREA ||i.SetSysClock||, CODE, READONLY, ALIGN=1

                  SetSysClock PROC
;;;418      */
;;;419    static void SetSysClock(void)
000000  b510              PUSH     {r4,lr}
;;;420    {
;;;421    #ifdef SYSCLK_FREQ_HSE
;;;422      SetSysClockToHSE();
;;;423    #elif defined SYSCLK_FREQ_24MHz
;;;424      SetSysClockTo24();
000002  f7fffffe          BL       SetSysClockTo24
;;;425    #elif defined SYSCLK_FREQ_36MHz
;;;426      SetSysClockTo36();
;;;427    #elif defined SYSCLK_FREQ_48MHz
;;;428      SetSysClockTo48();
;;;429    #elif defined SYSCLK_FREQ_56MHz
;;;430      SetSysClockTo56();  
;;;431    #elif defined SYSCLK_FREQ_72MHz
;;;432      SetSysClockTo72();
;;;433    #endif
;;;434     
;;;435     /* If none of the define above is enabled, the HSI is used as System clock
;;;436        source (default after reset) */ 
;;;437    }
000006  bd10              POP      {r4,pc}
;;;438    
                          ENDP


                          AREA ||i.SetSysClockTo24||, CODE, READONLY, ALIGN=2

                  SetSysClockTo24 PROC
;;;578      */
;;;579    static void SetSysClockTo24(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;580    {
;;;581      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
000006  9000              STR      r0,[sp,#0]
;;;582      
;;;583      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;584      /* Enable HSE */    
;;;585      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000008  482a              LDR      r0,|L2.180|
00000a  6800              LDR      r0,[r0,#0]
00000c  f4403080          ORR      r0,r0,#0x10000
000010  4928              LDR      r1,|L2.180|
000012  6008              STR      r0,[r1,#0]
;;;586     
;;;587      /* Wait till HSE is ready and if Time out is reached exit */
;;;588      do
000014  bf00              NOP      
                  |L2.22|
;;;589      {
;;;590        HSEStatus = RCC->CR & RCC_CR_HSERDY;
000016  4827              LDR      r0,|L2.180|
000018  6800              LDR      r0,[r0,#0]
00001a  f4003000          AND      r0,r0,#0x20000
00001e  9000              STR      r0,[sp,#0]
;;;591        StartUpCounter++;  
000020  9801              LDR      r0,[sp,#4]
000022  1c40              ADDS     r0,r0,#1
000024  9001              STR      r0,[sp,#4]
;;;592      } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
000026  9800              LDR      r0,[sp,#0]
000028  b918              CBNZ     r0,|L2.50|
00002a  9801              LDR      r0,[sp,#4]
00002c  f5b06fa0          CMP      r0,#0x500
000030  d1f1              BNE      |L2.22|
                  |L2.50|
;;;593    
;;;594      if ((RCC->CR & RCC_CR_HSERDY) != RESET)
000032  4820              LDR      r0,|L2.180|
000034  6800              LDR      r0,[r0,#0]
000036  f4003000          AND      r0,r0,#0x20000
00003a  b110              CBZ      r0,|L2.66|
;;;595      {
;;;596        HSEStatus = (uint32_t)0x01;
00003c  2001              MOVS     r0,#1
00003e  9000              STR      r0,[sp,#0]
000040  e001              B        |L2.70|
                  |L2.66|
;;;597      }
;;;598      else
;;;599      {
;;;600        HSEStatus = (uint32_t)0x00;
000042  2000              MOVS     r0,#0
000044  9000              STR      r0,[sp,#0]
                  |L2.70|
;;;601      }  
;;;602    
;;;603      if (HSEStatus == (uint32_t)0x01)
000046  9800              LDR      r0,[sp,#0]
000048  2801              CMP      r0,#1
00004a  d131              BNE      |L2.176|
;;;604      {
;;;605    #if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL && !defined STM32F10X_HD_VL 
;;;606        /* Enable Prefetch Buffer */
;;;607        FLASH->ACR |= FLASH_ACR_PRFTBE;
;;;608    
;;;609        /* Flash 0 wait state */
;;;610        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
;;;611        FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;    
;;;612    #endif
;;;613     
;;;614        /* HCLK = SYSCLK */
;;;615        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
00004c  4819              LDR      r0,|L2.180|
00004e  6840              LDR      r0,[r0,#4]
000050  4918              LDR      r1,|L2.180|
000052  6048              STR      r0,[r1,#4]
;;;616          
;;;617        /* PCLK2 = HCLK */
;;;618        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000054  4608              MOV      r0,r1
000056  6840              LDR      r0,[r0,#4]
000058  6048              STR      r0,[r1,#4]
;;;619        
;;;620        /* PCLK1 = HCLK */
;;;621        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
00005a  4608              MOV      r0,r1
00005c  6840              LDR      r0,[r0,#4]
00005e  6048              STR      r0,[r1,#4]
;;;622        
;;;623    #ifdef STM32F10X_CL
;;;624        /* Configure PLLs ------------------------------------------------------*/
;;;625        /* PLL configuration: PLLCLK = PREDIV1 * 6 = 24 MHz */ 
;;;626        RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;627        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;628                                RCC_CFGR_PLLMULL6); 
;;;629    
;;;630        /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;631        /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */       
;;;632        RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;633                                  RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;634        RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;635                                 RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);
;;;636      
;;;637        /* Enable PLL2 */
;;;638        RCC->CR |= RCC_CR_PLL2ON;
;;;639        /* Wait till PLL2 is ready */
;;;640        while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;641        {
;;;642        }   
;;;643    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;644        /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */
;;;645        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
000060  4608              MOV      r0,r1
000062  6840              LDR      r0,[r0,#4]
000064  f420107c          BIC      r0,r0,#0x3f0000
000068  6048              STR      r0,[r1,#4]
;;;646        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1_Div2 | RCC_CFGR_PLLMULL6);
00006a  4608              MOV      r0,r1
00006c  6840              LDR      r0,[r0,#4]
00006e  f4401098          ORR      r0,r0,#0x130000
000072  6048              STR      r0,[r1,#4]
;;;647    #else    
;;;648        /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */
;;;649        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
;;;650        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL6);
;;;651    #endif /* STM32F10X_CL */
;;;652    
;;;653        /* Enable PLL */
;;;654        RCC->CR |= RCC_CR_PLLON;
000074  4608              MOV      r0,r1
000076  6800              LDR      r0,[r0,#0]
000078  f0407080          ORR      r0,r0,#0x1000000
00007c  6008              STR      r0,[r1,#0]
;;;655    
;;;656        /* Wait till PLL is ready */
;;;657        while((RCC->CR & RCC_CR_PLLRDY) == 0)
00007e  bf00              NOP      
                  |L2.128|
000080  480c              LDR      r0,|L2.180|
000082  6800              LDR      r0,[r0,#0]
000084  f0007000          AND      r0,r0,#0x2000000
000088  2800              CMP      r0,#0
00008a  d0f9              BEQ      |L2.128|
;;;658        {
;;;659        }
;;;660    
;;;661        /* Select PLL as system clock source */
;;;662        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
00008c  4809              LDR      r0,|L2.180|
00008e  6840              LDR      r0,[r0,#4]
000090  f0200003          BIC      r0,r0,#3
000094  4907              LDR      r1,|L2.180|
000096  6048              STR      r0,[r1,#4]
;;;663        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
000098  4608              MOV      r0,r1
00009a  6840              LDR      r0,[r0,#4]
00009c  f0400002          ORR      r0,r0,#2
0000a0  6048              STR      r0,[r1,#4]
;;;664    
;;;665        /* Wait till PLL is used as system clock source */
;;;666        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
0000a2  bf00              NOP      
                  |L2.164|
0000a4  4803              LDR      r0,|L2.180|
0000a6  6840              LDR      r0,[r0,#4]
0000a8  f000000c          AND      r0,r0,#0xc
0000ac  2808              CMP      r0,#8
0000ae  d1f9              BNE      |L2.164|
                  |L2.176|
;;;667        {
;;;668        }
;;;669      }
;;;670      else
;;;671      { /* If HSE fails to start-up, the application will have wrong clock 
;;;672             configuration. User can add here some code to deal with this error */
;;;673      } 
;;;674    }
0000b0  bd0c              POP      {r2,r3,pc}
;;;675    #elif defined SYSCLK_FREQ_36MHz
                          ENDP

0000b2  0000              DCW      0x0000
                  |L2.180|
                          DCD      0x40021000

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;305      */
;;;306    void SystemCoreClockUpdate (void)
000000  b530              PUSH     {r4,r5,lr}
;;;307    {
;;;308      uint32_t tmp = 0, pllmull = 0, pllsource = 0;
000002  2100              MOVS     r1,#0
000004  2000              MOVS     r0,#0
000006  2200              MOVS     r2,#0
;;;309    
;;;310    #ifdef  STM32F10X_CL
;;;311      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;312    #endif /* STM32F10X_CL */
;;;313    
;;;314    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;315      uint32_t prediv1factor = 0;
000008  2300              MOVS     r3,#0
;;;316    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
;;;317        
;;;318      /* Get SYSCLK source -------------------------------------------------------*/
;;;319      tmp = RCC->CFGR & RCC_CFGR_SWS;
00000a  4c20              LDR      r4,|L3.140|
00000c  6864              LDR      r4,[r4,#4]
00000e  f004010c          AND      r1,r4,#0xc
;;;320      
;;;321      switch (tmp)
000012  b121              CBZ      r1,|L3.30|
000014  2904              CMP      r1,#4
000016  d006              BEQ      |L3.38|
000018  2908              CMP      r1,#8
00001a  d125              BNE      |L3.104|
00001c  e007              B        |L3.46|
                  |L3.30|
;;;322      {
;;;323        case 0x00:  /* HSI used as system clock */
;;;324          SystemCoreClock = HSI_VALUE;
00001e  4c1c              LDR      r4,|L3.144|
000020  4d1c              LDR      r5,|L3.148|
000022  602c              STR      r4,[r5,#0]  ; SystemCoreClock
;;;325          break;
000024  e024              B        |L3.112|
                  |L3.38|
;;;326        case 0x04:  /* HSE used as system clock */
;;;327          SystemCoreClock = HSE_VALUE;
000026  4c1a              LDR      r4,|L3.144|
000028  4d1a              LDR      r5,|L3.148|
00002a  602c              STR      r4,[r5,#0]  ; SystemCoreClock
;;;328          break;
00002c  e020              B        |L3.112|
                  |L3.46|
;;;329        case 0x08:  /* PLL used as system clock */
;;;330    
;;;331          /* Get PLL clock source and multiplication factor ----------------------*/
;;;332          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
00002e  4c17              LDR      r4,|L3.140|
000030  6864              LDR      r4,[r4,#4]
000032  f4041070          AND      r0,r4,#0x3c0000
;;;333          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
000036  4c15              LDR      r4,|L3.140|
000038  6864              LDR      r4,[r4,#4]
00003a  f4043280          AND      r2,r4,#0x10000
;;;334          
;;;335    #ifndef STM32F10X_CL      
;;;336          pllmull = ( pllmull >> 18) + 2;
00003e  2402              MOVS     r4,#2
000040  eb044090          ADD      r0,r4,r0,LSR #18
;;;337          
;;;338          if (pllsource == 0x00)
000044  b922              CBNZ     r2,|L3.80|
;;;339          {
;;;340            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;341            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
000046  4c14              LDR      r4,|L3.152|
000048  4344              MULS     r4,r0,r4
00004a  4d12              LDR      r5,|L3.148|
00004c  602c              STR      r4,[r5,#0]  ; SystemCoreClock
00004e  e00a              B        |L3.102|
                  |L3.80|
;;;342          }
;;;343          else
;;;344          {
;;;345     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;346           prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
000050  4c0e              LDR      r4,|L3.140|
000052  6ae4              LDR      r4,[r4,#0x2c]
000054  f004040f          AND      r4,r4,#0xf
000058  1c63              ADDS     r3,r4,#1
;;;347           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;348           SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
00005a  4c0d              LDR      r4,|L3.144|
00005c  fbb4f4f3          UDIV     r4,r4,r3
000060  4344              MULS     r4,r0,r4
000062  4d0c              LDR      r5,|L3.148|
000064  602c              STR      r4,[r5,#0]  ; SystemCoreClock
                  |L3.102|
;;;349     #else
;;;350            /* HSE selected as PLL clock entry */
;;;351            if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
;;;352            {/* HSE oscillator clock divided by 2 */
;;;353              SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
;;;354            }
;;;355            else
;;;356            {
;;;357              SystemCoreClock = HSE_VALUE * pllmull;
;;;358            }
;;;359     #endif
;;;360          }
;;;361    #else
;;;362          pllmull = pllmull >> 18;
;;;363          
;;;364          if (pllmull != 0x0D)
;;;365          {
;;;366             pllmull += 2;
;;;367          }
;;;368          else
;;;369          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;370            pllmull = 13 / 2; 
;;;371          }
;;;372                
;;;373          if (pllsource == 0x00)
;;;374          {
;;;375            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;376            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;377          }
;;;378          else
;;;379          {/* PREDIV1 selected as PLL clock entry */
;;;380            
;;;381            /* Get PREDIV1 clock source and division factor */
;;;382            prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;383            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;384            
;;;385            if (prediv1source == 0)
;;;386            { 
;;;387              /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;388              SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
;;;389            }
;;;390            else
;;;391            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;392              
;;;393              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;394              prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;395              pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;396              SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;397            }
;;;398          }
;;;399    #endif /* STM32F10X_CL */ 
;;;400          break;
000066  e003              B        |L3.112|
                  |L3.104|
;;;401    
;;;402        default:
;;;403          SystemCoreClock = HSI_VALUE;
000068  4c09              LDR      r4,|L3.144|
00006a  4d0a              LDR      r5,|L3.148|
00006c  602c              STR      r4,[r5,#0]  ; SystemCoreClock
;;;404          break;
00006e  bf00              NOP      
                  |L3.112|
000070  bf00              NOP                            ;325
;;;405      }
;;;406      
;;;407      /* Compute HCLK clock frequency ----------------*/
;;;408      /* Get HCLK prescaler */
;;;409      tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
000072  4c06              LDR      r4,|L3.140|
000074  6864              LDR      r4,[r4,#4]
000076  f3c41403          UBFX     r4,r4,#4,#4
00007a  4d08              LDR      r5,|L3.156|
00007c  5d29              LDRB     r1,[r5,r4]
;;;410      /* HCLK clock frequency */
;;;411      SystemCoreClock >>= tmp;  
00007e  4c05              LDR      r4,|L3.148|
000080  6824              LDR      r4,[r4,#0]  ; SystemCoreClock
000082  40cc              LSRS     r4,r4,r1
000084  4d03              LDR      r5,|L3.148|
000086  602c              STR      r4,[r5,#0]  ; SystemCoreClock
;;;412    }
000088  bd30              POP      {r4,r5,pc}
;;;413    
                          ENDP

00008a  0000              DCW      0x0000
                  |L3.140|
                          DCD      0x40021000
                  |L3.144|
                          DCD      0x007a1200
                  |L3.148|
                          DCD      SystemCoreClock
                  |L3.152|
                          DCD      0x003d0900
                  |L3.156|
                          DCD      AHBPrescTable

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;211      */
;;;212    void SystemInit (void)
000000  b510              PUSH     {r4,lr}
;;;213    {
;;;214      /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;215      /* Set HSION bit */
;;;216      RCC->CR |= (uint32_t)0x00000001;
000002  4814              LDR      r0,|L4.84|
000004  6800              LDR      r0,[r0,#0]
000006  f0400001          ORR      r0,r0,#1
00000a  4912              LDR      r1,|L4.84|
00000c  6008              STR      r0,[r1,#0]
;;;217    
;;;218      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;219    #ifndef STM32F10X_CL
;;;220      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000e  4608              MOV      r0,r1
000010  6840              LDR      r0,[r0,#4]
000012  4911              LDR      r1,|L4.88|
000014  4008              ANDS     r0,r0,r1
000016  490f              LDR      r1,|L4.84|
000018  6048              STR      r0,[r1,#4]
;;;221    #else
;;;222      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;223    #endif /* STM32F10X_CL */   
;;;224      
;;;225      /* Reset HSEON, CSSON and PLLON bits */
;;;226      RCC->CR &= (uint32_t)0xFEF6FFFF;
00001a  4608              MOV      r0,r1
00001c  6800              LDR      r0,[r0,#0]
00001e  490f              LDR      r1,|L4.92|
000020  4008              ANDS     r0,r0,r1
000022  490c              LDR      r1,|L4.84|
000024  6008              STR      r0,[r1,#0]
;;;227    
;;;228      /* Reset HSEBYP bit */
;;;229      RCC->CR &= (uint32_t)0xFFFBFFFF;
000026  4608              MOV      r0,r1
000028  6800              LDR      r0,[r0,#0]
00002a  f4202080          BIC      r0,r0,#0x40000
00002e  6008              STR      r0,[r1,#0]
;;;230    
;;;231      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;232      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000030  4608              MOV      r0,r1
000032  6840              LDR      r0,[r0,#4]
000034  f42000fe          BIC      r0,r0,#0x7f0000
000038  6048              STR      r0,[r1,#4]
;;;233    
;;;234    #ifdef STM32F10X_CL
;;;235      /* Reset PLL2ON and PLL3ON bits */
;;;236      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;237    
;;;238      /* Disable all interrupts and clear pending bits  */
;;;239      RCC->CIR = 0x00FF0000;
;;;240    
;;;241      /* Reset CFGR2 register */
;;;242      RCC->CFGR2 = 0x00000000;
;;;243    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;244      /* Disable all interrupts and clear pending bits  */
;;;245      RCC->CIR = 0x009F0000;
00003a  f44f001f          MOV      r0,#0x9f0000
00003e  6088              STR      r0,[r1,#8]
;;;246    
;;;247      /* Reset CFGR2 register */
;;;248      RCC->CFGR2 = 0x00000000;      
000040  2000              MOVS     r0,#0
000042  62c8              STR      r0,[r1,#0x2c]
;;;249    #else
;;;250      /* Disable all interrupts and clear pending bits  */
;;;251      RCC->CIR = 0x009F0000;
;;;252    #endif /* STM32F10X_CL */
;;;253        
;;;254    #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
;;;255      #ifdef DATA_IN_ExtSRAM
;;;256        SystemInit_ExtMemCtl(); 
;;;257      #endif /* DATA_IN_ExtSRAM */
;;;258    #endif 
;;;259    
;;;260      /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;261      /* Configure the Flash Latency cycles and enable prefetch buffer */
;;;262      SetSysClock();
000044  f7fffffe          BL       SetSysClock
;;;263    
;;;264    #ifdef VECT_TAB_SRAM
;;;265      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;266    #else
;;;267      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
000048  f04f6000          MOV      r0,#0x8000000
00004c  4904              LDR      r1,|L4.96|
00004e  6008              STR      r0,[r1,#0]
;;;268    #endif 
;;;269    }
000050  bd10              POP      {r4,pc}
;;;270    
                          ENDP

000052  0000              DCW      0x0000
                  |L4.84|
                          DCD      0x40021000
                  |L4.88|
                          DCD      0xf8ff0000
                  |L4.92|
                          DCD      0xfef6ffff
                  |L4.96|
                          DCD      0xe000ed08

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x016e3600
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
