; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\thread.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\thread.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\thread.crf ..\rt_thread\kernel\thread.c]
                          THUMB

                          AREA ||i._rt_thread_init||, CODE, READONLY, ALIGN=2

                  _rt_thread_init PROC
;;;83     
;;;84     static rt_err_t _rt_thread_init(struct rt_thread *thread,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;85                                     const char       *name,
;;;86                                     void (*entry)(void *parameter),
;;;87                                     void             *parameter,
;;;88                                     void             *stack_start,
;;;89                                     rt_uint32_t       stack_size,
;;;90                                     rt_uint8_t        priority,
;;;91                                     rt_uint32_t       tick)
;;;92     {
000004  4604              MOV      r4,r0
000006  468b              MOV      r11,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
000010  e9dd580e          LDRD     r5,r8,[sp,#0x38]
;;;93         /* init thread list */
;;;94         rt_list_init(&(thread->tlist));
000014  f1040014          ADD      r0,r4,#0x14
000018  6040              STR      r0,[r0,#4]
00001a  6000              STR      r0,[r0,#0]
00001c  bf00              NOP      
;;;95     
;;;96         thread->entry = (void *)entry;
00001e  6226              STR      r6,[r4,#0x20]
;;;97         thread->parameter = parameter;
000020  6267              STR      r7,[r4,#0x24]
;;;98     
;;;99         /* stack init */
;;;100        thread->stack_addr = stack_start;
000022  f8c49028          STR      r9,[r4,#0x28]
;;;101        thread->stack_size = stack_size;
000026  f8c4a02c          STR      r10,[r4,#0x2c]
;;;102    
;;;103        /* init thread stack */
;;;104        rt_memset(thread->stack_addr, '#', thread->stack_size);
00002a  2123              MOVS     r1,#0x23
00002c  e9d4020a          LDRD     r0,r2,[r4,#0x28]
000030  f7fffffe          BL       rt_memset
;;;105        thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
000034  e9d43c0a          LDRD     r3,r12,[r4,#0x28]
000038  4463              ADD      r3,r3,r12
00003a  1f1a              SUBS     r2,r3,#4
00003c  4b12              LDR      r3,|L1.136|
00003e  e9d40108          LDRD     r0,r1,[r4,#0x20]
000042  f7fffffe          BL       rt_hw_stack_init
000046  61e0              STR      r0,[r4,#0x1c]
;;;106            (void *)((char *)thread->stack_addr + thread->stack_size - 4),
;;;107            (void *)rt_thread_exit);
;;;108    
;;;109        /* priority init */
;;;110        RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
000048  2d20              CMP      r5,#0x20
00004a  db04              BLT      |L1.86|
00004c  226e              MOVS     r2,#0x6e
00004e  490f              LDR      r1,|L1.140|
000050  a00f              ADR      r0,|L1.144|
000052  f7fffffe          BL       rt_assert_handler
                  |L1.86|
;;;111        thread->init_priority    = priority;
000056  3430              ADDS     r4,r4,#0x30
000058  71a5              STRB     r5,[r4,#6]
;;;112        thread->current_priority = priority;
00005a  7165              STRB     r5,[r4,#5]
;;;113    
;;;114        /* tick init */
;;;115        thread->init_tick      = tick;
00005c  f8c48014          STR      r8,[r4,#0x14]
;;;116        thread->remaining_tick = tick;
000060  f8c48018          STR      r8,[r4,#0x18]
;;;117    
;;;118        /* error and flags */
;;;119        thread->error = RT_EOK;
000064  2000              MOVS     r0,#0
000066  6020              STR      r0,[r4,#0]
;;;120        thread->stat  = RT_THREAD_INIT;
000068  7120              STRB     r0,[r4,#4]
;;;121    
;;;122        /* initialize cleanup function and user data */
;;;123        thread->cleanup   = 0;
00006a  64a0              STR      r0,[r4,#0x48]
;;;124        thread->user_data = 0;
00006c  64e0              STR      r0,[r4,#0x4c]
00006e  3c30              SUBS     r4,r4,#0x30
;;;125    
;;;126        /* init thread timer */
;;;127        rt_timer_init(&(thread->thread_timer),
000070  9000              STR      r0,[sp,#0]
000072  4623              MOV      r3,r4
000074  4a0f              LDR      r2,|L1.180|
000076  4621              MOV      r1,r4
000078  9001              STR      r0,[sp,#4]
00007a  f104004c          ADD      r0,r4,#0x4c
00007e  f7fffffe          BL       rt_timer_init
;;;128                      thread->name,
;;;129                      rt_thread_timeout,
;;;130                      thread,
;;;131                      0,
;;;132                      RT_TIMER_FLAG_ONE_SHOT);
;;;133    
;;;134        return RT_EOK;
000082  2000              MOVS     r0,#0
;;;135    }
000084  e8bd9ffc          POP      {r2-r12,pc}
;;;136    
                          ENDP

                  |L1.136|
                          DCD      rt_thread_exit
                  |L1.140|
                          DCD      __FUNCTION__
                  |L1.144|
000090  7072696f          DCB      "priority < RT_THREAD_PRIORITY_MAX",0
000094  72697479
000098  203c2052
00009c  545f5448
0000a0  52454144
0000a4  5f505249
0000a8  4f524954
0000ac  595f4d41
0000b0  5800    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L1.180|
                          DCD      rt_thread_timeout

                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
000002  6051              STR      r1,[r2,#4]
;;;65         n->next = l->next;
000004  6802              LDR      r2,[r0,#0]
000006  600a              STR      r2,[r1,#0]
;;;66     
;;;67         l->next = n;
000008  6001              STR      r1,[r0,#0]
;;;68         n->prev = l;
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_remove||, CODE, READONLY, ALIGN=1

                  rt_list_remove PROC
;;;89      */
;;;90     rt_inline void rt_list_remove(rt_list_t *n)
000000  e9d02100          LDRD     r2,r1,[r0,#0]
;;;91     {
;;;92         n->next->prev = n->prev;
000004  6051              STR      r1,[r2,#4]
;;;93         n->prev->next = n->next;
000006  e9d01200          LDRD     r1,r2,[r0,#0]
00000a  6011              STR      r1,[r2,#0]
;;;94     
;;;95         n->next = n->prev = n;
00000c  6040              STR      r0,[r0,#4]
00000e  6000              STR      r0,[r0,#0]
;;;96     }
000010  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.rt_thread_control||, CODE, READONLY, ALIGN=2

                  rt_thread_control PROC
;;;475     */
;;;476    rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;477    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;478        register rt_base_t temp;
;;;479    
;;;480        /* thread check */
;;;481        RT_ASSERT(thread != RT_NULL);
00000a  b92c              CBNZ     r4,|L4.24|
00000c  f24012e1          MOV      r2,#0x1e1
000010  491b              LDR      r1,|L4.128|
000012  a01c              ADR      r0,|L4.132|
000014  f7fffffe          BL       rt_assert_handler
                  |L4.24|
;;;482    
;;;483        switch (cmd)
000018  b32e              CBZ      r6,|L4.102|
00001a  2e01              CMP      r6,#1
00001c  d028              BEQ      |L4.112|
00001e  2e02              CMP      r6,#2
000020  d12a              BNE      |L4.120|
;;;484        {
;;;485        case RT_THREAD_CTRL_CHANGE_PRIORITY:
;;;486            /* disable interrupt */
;;;487            temp = rt_hw_interrupt_disable();
000022  f7fffffe          BL       rt_hw_interrupt_disable
000026  4607              MOV      r7,r0
;;;488    
;;;489            /* for ready thread, change queue */
;;;490            if (thread->stat == RT_THREAD_READY)
000028  f8940034          LDRB     r0,[r4,#0x34]
00002c  2801              CMP      r0,#1
00002e  d10e              BNE      |L4.78|
;;;491            {
;;;492                /* remove thread from schedule queue first */
;;;493                rt_schedule_remove_thread(thread);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       rt_schedule_remove_thread
;;;494    
;;;495                /* change thread priority */
;;;496                thread->current_priority = *(rt_uint8_t *)arg;
000036  7828              LDRB     r0,[r5,#0]
000038  f8840035          STRB     r0,[r4,#0x35]
;;;497    
;;;498                /* recalculate priority attribute */
;;;499    #if RT_THREAD_PRIORITY_MAX > 32
;;;500                thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;501                thread->number_mask = 1 << thread->number;
;;;502                thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
;;;503    #else
;;;504                thread->number_mask = 1 << thread->current_priority;
00003c  f8941035          LDRB     r1,[r4,#0x35]
000040  2001              MOVS     r0,#1
000042  4088              LSLS     r0,r0,r1
000044  63a0              STR      r0,[r4,#0x38]
;;;505    #endif
;;;506    
;;;507                /* insert thread to schedule queue again */
;;;508                rt_schedule_insert_thread(thread);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       rt_schedule_insert_thread
00004c  e007              B        |L4.94|
                  |L4.78|
;;;509            }
;;;510            else
;;;511            {
;;;512                thread->current_priority = *(rt_uint8_t *)arg;
00004e  7828              LDRB     r0,[r5,#0]
000050  f8840035          STRB     r0,[r4,#0x35]
;;;513    
;;;514                /* recalculate priority attribute */
;;;515    #if RT_THREAD_PRIORITY_MAX > 32
;;;516                thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;517                thread->number_mask = 1 << thread->number;
;;;518                thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
;;;519    #else
;;;520                thread->number_mask = 1 << thread->current_priority;
000054  f8941035          LDRB     r1,[r4,#0x35]
000058  2001              MOVS     r0,#1
00005a  4088              LSLS     r0,r0,r1
00005c  63a0              STR      r0,[r4,#0x38]
                  |L4.94|
;;;521    #endif
;;;522            }
;;;523    
;;;524            /* enable interrupt */
;;;525            rt_hw_interrupt_enable(temp);
00005e  4638              MOV      r0,r7
000060  f7fffffe          BL       rt_hw_interrupt_enable
;;;526            break;
000064  e009              B        |L4.122|
                  |L4.102|
;;;527    
;;;528        case RT_THREAD_CTRL_STARTUP:
;;;529            return rt_thread_startup(thread);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       rt_thread_startup
                  |L4.108|
;;;530    
;;;531    #ifdef RT_USING_HEAP
;;;532        case RT_THREAD_CTRL_CLOSE:
;;;533            return rt_thread_delete(thread);
;;;534    #endif
;;;535    
;;;536        default:
;;;537            break;
;;;538        }
;;;539    
;;;540        return RT_EOK;
;;;541    }
00006c  e8bd81f0          POP      {r4-r8,pc}
                  |L4.112|
000070  4620              MOV      r0,r4                 ;533
000072  f7fffffe          BL       rt_thread_delete
000076  e7f9              B        |L4.108|
                  |L4.120|
000078  bf00              NOP                            ;537
                  |L4.122|
00007a  bf00              NOP                            ;526
00007c  2000              MOVS     r0,#0                 ;540
00007e  e7f5              B        |L4.108|
;;;542    RTM_EXPORT(rt_thread_control);
                          ENDP

                  |L4.128|
                          DCD      |symbol_number.60|
                  |L4.132|
000084  74687265          DCB      "thread != RT_NULL",0
000088  61642021
00008c  3d205254
000090  5f4e554c
000094  4c00    
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.rt_thread_create||, CODE, READONLY, ALIGN=1

                  rt_thread_create PROC
;;;294     */
;;;295    rt_thread_t rt_thread_create(const char *name,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;296                                 void (*entry)(void *parameter),
;;;297                                 void       *parameter,
;;;298                                 rt_uint32_t stack_size,
;;;299                                 rt_uint8_t  priority,
;;;300                                 rt_uint32_t tick)
;;;301    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
00000c  e9ddab0e          LDRD     r10,r11,[sp,#0x38]
;;;302        struct rt_thread *thread;
;;;303        void *stack_start;
;;;304    
;;;305        thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
000010  4631              MOV      r1,r6
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       rt_object_allocate
000018  4681              MOV      r9,r0
;;;306                                                        name);
;;;307        if (thread == RT_NULL)
00001a  f1b90f00          CMP      r9,#0
00001e  d103              BNE      |L5.40|
;;;308            return RT_NULL;
000020  2000              MOVS     r0,#0
                  |L5.34|
;;;309    
;;;310        stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
;;;311        if (stack_start == RT_NULL)
;;;312        {
;;;313            /* allocate stack failure */
;;;314            rt_object_delete((rt_object_t)thread);
;;;315    
;;;316            return RT_NULL;
;;;317        }
;;;318    
;;;319        _rt_thread_init(thread,
;;;320                        name,
;;;321                        entry,
;;;322                        parameter,
;;;323                        stack_start,
;;;324                        stack_size,
;;;325                        priority,
;;;326                        tick);
;;;327    
;;;328        return thread;
;;;329    }
000022  b004              ADD      sp,sp,#0x10
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L5.40|
000028  4628              MOV      r0,r5                 ;310
00002a  f7fffffe          BL       rt_malloc
00002e  4604              MOV      r4,r0                 ;310
000030  b924              CBNZ     r4,|L5.60|
000032  4648              MOV      r0,r9                 ;314
000034  f7fffffe          BL       rt_object_delete
000038  2000              MOVS     r0,#0                 ;316
00003a  e7f2              B        |L5.34|
                  |L5.60|
00003c  4643              MOV      r3,r8                 ;319
00003e  463a              MOV      r2,r7                 ;319
000040  4631              MOV      r1,r6                 ;319
000042  4648              MOV      r0,r9                 ;319
000044  e88d0c30          STM      sp,{r4,r5,r10,r11}    ;319
000048  f7fffffe          BL       _rt_thread_init
00004c  4648              MOV      r0,r9                 ;328
00004e  e7e8              B        |L5.34|
;;;330    RTM_EXPORT(rt_thread_create);
                          ENDP


                          AREA ||i.rt_thread_delay||, CODE, READONLY, ALIGN=1

                  rt_thread_delay PROC
;;;457     */
;;;458    rt_err_t rt_thread_delay(rt_tick_t tick)
000000  b510              PUSH     {r4,lr}
;;;459    {
000002  4604              MOV      r4,r0
;;;460        return rt_thread_sleep(tick);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       rt_thread_sleep
;;;461    }
00000a  bd10              POP      {r4,pc}
;;;462    RTM_EXPORT(rt_thread_delay);
                          ENDP


                          AREA ||i.rt_thread_delete||, CODE, READONLY, ALIGN=2

                  rt_thread_delete PROC
;;;339     */
;;;340    rt_err_t rt_thread_delete(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;341    {
000002  4604              MOV      r4,r0
;;;342        rt_base_t lock;
;;;343    
;;;344        /* thread check */
;;;345        RT_ASSERT(thread != RT_NULL);
000004  b92c              CBNZ     r4,|L7.18|
000006  f2401259          MOV      r2,#0x159
00000a  490d              LDR      r1,|L7.64|
00000c  a00d              ADR      r0,|L7.68|
00000e  f7fffffe          BL       rt_assert_handler
                  |L7.18|
;;;346    
;;;347        /* remove from schedule */
;;;348        rt_schedule_remove_thread(thread);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       rt_schedule_remove_thread
;;;349    
;;;350        /* release thread timer */
;;;351        rt_timer_detach(&(thread->thread_timer));
000018  f104004c          ADD      r0,r4,#0x4c
00001c  f7fffffe          BL       rt_timer_detach
;;;352    
;;;353        /* change stat */
;;;354        thread->stat = RT_THREAD_CLOSE;
000020  2004              MOVS     r0,#4
000022  f8840034          STRB     r0,[r4,#0x34]
;;;355    
;;;356        /* disable interrupt */
;;;357        lock = rt_hw_interrupt_disable();
000026  f7fffffe          BL       rt_hw_interrupt_disable
00002a  4605              MOV      r5,r0
;;;358    
;;;359        /* insert to defunct thread list */
;;;360        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
00002c  f1040114          ADD      r1,r4,#0x14
000030  4809              LDR      r0,|L7.88|
000032  f7fffffe          BL       rt_list_insert_after
;;;361    
;;;362        /* enable interrupt */
;;;363        rt_hw_interrupt_enable(lock);
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       rt_hw_interrupt_enable
;;;364    
;;;365        return RT_EOK;
00003c  2000              MOVS     r0,#0
;;;366    }
00003e  bd70              POP      {r4-r6,pc}
;;;367    RTM_EXPORT(rt_thread_delete);
                          ENDP

                  |L7.64|
                          DCD      |symbol_number.58|
                  |L7.68|
000044  74687265          DCB      "thread != RT_NULL",0
000048  61642021
00004c  3d205254
000050  5f4e554c
000054  4c00    
000056  00                DCB      0
000057  00                DCB      0
                  |L7.88|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_detach||, CODE, READONLY, ALIGN=2

                  rt_thread_detach PROC
;;;244     */
;;;245    rt_err_t rt_thread_detach(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;246    {
000002  4604              MOV      r4,r0
;;;247        rt_base_t lock;
;;;248    
;;;249        /* thread check */
;;;250        RT_ASSERT(thread != RT_NULL);
000004  b924              CBNZ     r4,|L8.16|
000006  22fa              MOVS     r2,#0xfa
000008  490f              LDR      r1,|L8.72|
00000a  a010              ADR      r0,|L8.76|
00000c  f7fffffe          BL       rt_assert_handler
                  |L8.16|
;;;251    
;;;252        /* remove from schedule */
;;;253        rt_schedule_remove_thread(thread);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       rt_schedule_remove_thread
;;;254    
;;;255        /* release thread timer */
;;;256        rt_timer_detach(&(thread->thread_timer));
000016  f104004c          ADD      r0,r4,#0x4c
00001a  f7fffffe          BL       rt_timer_detach
;;;257    
;;;258        /* change stat */
;;;259        thread->stat = RT_THREAD_CLOSE;
00001e  2004              MOVS     r0,#4
000020  f8840034          STRB     r0,[r4,#0x34]
;;;260    
;;;261        /* detach object */
;;;262        rt_object_detach((rt_object_t)thread);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       rt_object_detach
;;;263    
;;;264        if (thread->cleanup != RT_NULL)
00002a  6fa0              LDR      r0,[r4,#0x78]
00002c  b150              CBZ      r0,|L8.68|
;;;265        {
;;;266            /* disable interrupt */
;;;267            lock = rt_hw_interrupt_disable();
00002e  f7fffffe          BL       rt_hw_interrupt_disable
000032  4605              MOV      r5,r0
;;;268    
;;;269            /* insert to defunct thread list */
;;;270            rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000034  f1040114          ADD      r1,r4,#0x14
000038  4809              LDR      r0,|L8.96|
00003a  f7fffffe          BL       rt_list_insert_after
;;;271    
;;;272            /* enable interrupt */
;;;273            rt_hw_interrupt_enable(lock);
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       rt_hw_interrupt_enable
                  |L8.68|
;;;274        }
;;;275    
;;;276        return RT_EOK;
000044  2000              MOVS     r0,#0
;;;277    }
000046  bd70              POP      {r4-r6,pc}
;;;278    RTM_EXPORT(rt_thread_detach);
                          ENDP

                  |L8.72|
                          DCD      |symbol_number.57|
                  |L8.76|
00004c  74687265          DCB      "thread != RT_NULL",0
000050  61642021
000054  3d205254
000058  5f4e554c
00005c  4c00    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L8.96|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_exit||, CODE, READONLY, ALIGN=2

                  rt_thread_exit PROC
;;;46     
;;;47     void rt_thread_exit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;48     {
;;;49         struct rt_thread *thread;
;;;50         register rt_base_t level;
;;;51     
;;;52         /* get current thread */
;;;53         thread = rt_current_thread;
000002  4812              LDR      r0,|L9.76|
000004  6804              LDR      r4,[r0,#0]  ; rt_current_thread
;;;54     
;;;55         /* disable interrupt */
;;;56         level = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
;;;57     
;;;58         /* remove from schedule */
;;;59         rt_schedule_remove_thread(thread);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       rt_schedule_remove_thread
;;;60         /* change stat */
;;;61         thread->stat = RT_THREAD_CLOSE;
000012  2004              MOVS     r0,#4
000014  f8840034          STRB     r0,[r4,#0x34]
;;;62     
;;;63         /* remove it from timer list */
;;;64         rt_timer_detach(&thread->thread_timer);
000018  f104004c          ADD      r0,r4,#0x4c
00001c  f7fffffe          BL       rt_timer_detach
;;;65     
;;;66         if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       rt_object_is_systemobject
000026  2801              CMP      r0,#1
000028  d105              BNE      |L9.54|
;;;67             thread->cleanup == RT_NULL)
00002a  6fa0              LDR      r0,[r4,#0x78]
00002c  b918              CBNZ     r0,|L9.54|
;;;68         {
;;;69             rt_object_detach((rt_object_t)thread);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       rt_object_detach
000034  e004              B        |L9.64|
                  |L9.54|
;;;70         }
;;;71         else
;;;72         {
;;;73             /* insert to defunct thread list */
;;;74             rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000036  f1040114          ADD      r1,r4,#0x14
00003a  4805              LDR      r0,|L9.80|
00003c  f7fffffe          BL       rt_list_insert_after
                  |L9.64|
;;;75         }
;;;76     
;;;77         /* enable interrupt */
;;;78         rt_hw_interrupt_enable(level);
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       rt_hw_interrupt_enable
;;;79     
;;;80         /* switch to next task */
;;;81         rt_schedule();
000046  f7fffffe          BL       rt_schedule
;;;82     }
00004a  bd70              POP      {r4-r6,pc}
;;;83     
                          ENDP

                  |L9.76|
                          DCD      rt_current_thread
                  |L9.80|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_find||, CODE, READONLY, ALIGN=2

                  rt_thread_find PROC
;;;668     */
;;;669    rt_thread_t rt_thread_find(char *name)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;670    {
000004  4606              MOV      r6,r0
;;;671        struct rt_object_information *information;
;;;672        struct rt_object *object;
;;;673        struct rt_list_node *node;
;;;674    
;;;675        extern struct rt_object_information rt_object_container[];
;;;676    
;;;677        /* enter critical */
;;;678        if (rt_thread_self() != RT_NULL)
000006  f7fffffe          BL       rt_thread_self
00000a  b108              CBZ      r0,|L10.16|
;;;679            rt_enter_critical();
00000c  f7fffffe          BL       rt_enter_critical
                  |L10.16|
;;;680    
;;;681        /* try to find device object */
;;;682        information = &rt_object_container[RT_Object_Class_Thread];
000010  4d0e              LDR      r5,|L10.76|
;;;683        for (node  = information->object_list.next;
000012  686c              LDR      r4,[r5,#4]
000014  e010              B        |L10.56|
                  |L10.22|
;;;684             node != &(information->object_list);
;;;685             node  = node->next)
;;;686        {
;;;687            object = rt_list_entry(node, struct rt_object, list);
000016  f1a4070c          SUB      r7,r4,#0xc
;;;688            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
00001a  2208              MOVS     r2,#8
00001c  4631              MOV      r1,r6
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       rt_strncmp
000024  b938              CBNZ     r0,|L10.54|
;;;689            {
;;;690                /* leave critical */
;;;691                if (rt_thread_self() != RT_NULL)
000026  f7fffffe          BL       rt_thread_self
00002a  b108              CBZ      r0,|L10.48|
;;;692                    rt_exit_critical();
00002c  f7fffffe          BL       rt_exit_critical
                  |L10.48|
;;;693    
;;;694                return (rt_thread_t)object;
000030  4638              MOV      r0,r7
                  |L10.50|
;;;695            }
;;;696        }
;;;697    
;;;698        /* leave critical */
;;;699        if (rt_thread_self() != RT_NULL)
;;;700            rt_exit_critical();
;;;701    
;;;702        /* not found */
;;;703        return RT_NULL;
;;;704    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L10.54|
000036  6824              LDR      r4,[r4,#0]            ;685
                  |L10.56|
000038  1d28              ADDS     r0,r5,#4              ;684
00003a  4284              CMP      r4,r0                 ;684
00003c  d1eb              BNE      |L10.22|
00003e  f7fffffe          BL       rt_thread_self
000042  b108              CBZ      r0,|L10.72|
000044  f7fffffe          BL       rt_exit_critical
                  |L10.72|
000048  2000              MOVS     r0,#0                 ;703
00004a  e7f2              B        |L10.50|
;;;705    RTM_EXPORT(rt_thread_find);
                          ENDP

                  |L10.76|
                          DCD      rt_object_container

                          AREA ||i.rt_thread_init||, CODE, READONLY, ALIGN=2

                  rt_thread_init PROC
;;;157     */
;;;158    rt_err_t rt_thread_init(struct rt_thread *thread,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;159                            const char       *name,
;;;160                            void (*entry)(void *parameter),
;;;161                            void             *parameter,
;;;162                            void             *stack_start,
;;;163                            rt_uint32_t       stack_size,
;;;164                            rt_uint8_t        priority,
;;;165                            rt_uint32_t       tick)
;;;166    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  ae0e              ADD      r6,sp,#0x38
00000e  e8960e40          LDM      r6,{r6,r9-r11}
;;;167        /* thread check */
;;;168        RT_ASSERT(thread != RT_NULL);
000012  b924              CBNZ     r4,|L11.30|
000014  22a8              MOVS     r2,#0xa8
000016  490d              LDR      r1,|L11.76|
000018  a00d              ADR      r0,|L11.80|
00001a  f7fffffe          BL       rt_assert_handler
                  |L11.30|
;;;169        RT_ASSERT(stack_start != RT_NULL);
00001e  b926              CBNZ     r6,|L11.42|
000020  22a9              MOVS     r2,#0xa9
000022  490a              LDR      r1,|L11.76|
000024  a00f              ADR      r0,|L11.100|
000026  f7fffffe          BL       rt_assert_handler
                  |L11.42|
;;;170    
;;;171        /* init thread object */
;;;172        rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
00002a  462a              MOV      r2,r5
00002c  2100              MOVS     r1,#0
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       rt_object_init
;;;173    
;;;174        return _rt_thread_init(thread,
000034  4643              MOV      r3,r8
000036  463a              MOV      r2,r7
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  e88d0e40          STM      sp,{r6,r9-r11}
000040  f7fffffe          BL       _rt_thread_init
;;;175                               name,
;;;176                               entry,
;;;177                               parameter,
;;;178                               stack_start,
;;;179                               stack_size,
;;;180                               priority,
;;;181                               tick);
;;;182    }
000044  b004              ADD      sp,sp,#0x10
000046  e8bd9ff0          POP      {r4-r12,pc}
;;;183    RTM_EXPORT(rt_thread_init);
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      |symbol_number.55|
                  |L11.80|
000050  74687265          DCB      "thread != RT_NULL",0
000054  61642021
000058  3d205254
00005c  5f4e554c
000060  4c00    
000062  00                DCB      0
000063  00                DCB      0
                  |L11.100|
000064  73746163          DCB      "stack_start != RT_NULL",0
000068  6b5f7374
00006c  61727420
000070  213d2052
000074  545f4e55
000078  4c4c00  
00007b  00                DCB      0

                          AREA ||i.rt_thread_resume||, CODE, READONLY, ALIGN=2

                  rt_thread_resume PROC
;;;594     */
;;;595    rt_err_t rt_thread_resume(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;596    {
000002  4604              MOV      r4,r0
;;;597        register rt_base_t temp;
;;;598    
;;;599        /* thread check */
;;;600        RT_ASSERT(thread != RT_NULL);
000004  b92c              CBNZ     r4,|L12.18|
000006  f44f7216          MOV      r2,#0x258
00000a  4911              LDR      r1,|L12.80|
00000c  a011              ADR      r0,|L12.84|
00000e  f7fffffe          BL       rt_assert_handler
                  |L12.18|
;;;601    
;;;602        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));
000012  bf00              NOP      
000014  bf00              NOP      
;;;603    
;;;604        if (thread->stat != RT_THREAD_SUSPEND)
000016  f8940034          LDRB     r0,[r4,#0x34]
00001a  2802              CMP      r0,#2
00001c  d004              BEQ      |L12.40|
;;;605        {
;;;606            RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
00001e  bf00              NOP      
000020  bf00              NOP      
;;;607                                           thread->stat));
;;;608    
;;;609            return -RT_ERROR;
000022  f04f30ff          MOV      r0,#0xffffffff
                  |L12.38|
;;;610        }
;;;611    
;;;612        /* disable interrupt */
;;;613        temp = rt_hw_interrupt_disable();
;;;614    
;;;615        /* remove from suspend list */
;;;616        rt_list_remove(&(thread->tlist));
;;;617    
;;;618        rt_timer_stop(&thread->thread_timer);
;;;619    
;;;620        /* enable interrupt */
;;;621        rt_hw_interrupt_enable(temp);
;;;622    
;;;623        /* insert to schedule ready list */
;;;624        rt_schedule_insert_thread(thread);
;;;625    
;;;626        return RT_EOK;
;;;627    }
000026  bd70              POP      {r4-r6,pc}
                  |L12.40|
000028  f7fffffe          BL       rt_hw_interrupt_disable
00002c  4605              MOV      r5,r0                 ;613
00002e  f1040014          ADD      r0,r4,#0x14           ;616
000032  f7fffffe          BL       rt_list_remove
000036  f104004c          ADD      r0,r4,#0x4c           ;618
00003a  f7fffffe          BL       rt_timer_stop
00003e  4628              MOV      r0,r5                 ;621
000040  f7fffffe          BL       rt_hw_interrupt_enable
000044  4620              MOV      r0,r4                 ;624
000046  f7fffffe          BL       rt_schedule_insert_thread
00004a  2000              MOVS     r0,#0                 ;626
00004c  e7eb              B        |L12.38|
;;;628    RTM_EXPORT(rt_thread_resume);
                          ENDP

00004e  0000              DCW      0x0000
                  |L12.80|
                          DCD      |symbol_number.62|
                  |L12.84|
000054  74687265          DCB      "thread != RT_NULL",0
000058  61642021
00005c  3d205254
000060  5f4e554c
000064  4c00    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.rt_thread_self||, CODE, READONLY, ALIGN=2

                  rt_thread_self PROC
;;;189     */
;;;190    rt_thread_t rt_thread_self(void)
000000  4801              LDR      r0,|L13.8|
;;;191    {
;;;192        return rt_current_thread;
000002  6800              LDR      r0,[r0,#0]  ; rt_current_thread
;;;193    }
000004  4770              BX       lr
;;;194    RTM_EXPORT(rt_thread_self);
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      rt_current_thread

                          AREA ||i.rt_thread_sleep||, CODE, READONLY, ALIGN=2

                  rt_thread_sleep PROC
;;;420     */
;;;421    rt_err_t rt_thread_sleep(rt_tick_t tick)
000000  b531              PUSH     {r0,r4,r5,lr}
;;;422    {
;;;423        register rt_base_t temp;
;;;424        struct rt_thread *thread;
;;;425    
;;;426        /* disable interrupt */
;;;427        temp = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4605              MOV      r5,r0
;;;428        /* set to current thread */
;;;429        thread = rt_current_thread;
000008  4810              LDR      r0,|L14.76|
00000a  6804              LDR      r4,[r0,#0]  ; rt_current_thread
;;;430        RT_ASSERT(thread != RT_NULL);
00000c  b92c              CBNZ     r4,|L14.26|
00000e  f44f72d7          MOV      r2,#0x1ae
000012  490f              LDR      r1,|L14.80|
000014  a00f              ADR      r0,|L14.84|
000016  f7fffffe          BL       rt_assert_handler
                  |L14.26|
;;;431    
;;;432        /* suspend thread */
;;;433        rt_thread_suspend(thread);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_thread_suspend
;;;434    
;;;435        /* reset the timeout of thread timer and start it */
;;;436        rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
000020  466a              MOV      r2,sp
000022  2100              MOVS     r1,#0
000024  f104004c          ADD      r0,r4,#0x4c
000028  f7fffffe          BL       rt_timer_control
;;;437        rt_timer_start(&(thread->thread_timer));
00002c  f104004c          ADD      r0,r4,#0x4c
000030  f7fffffe          BL       rt_timer_start
;;;438    
;;;439        /* enable interrupt */
;;;440        rt_hw_interrupt_enable(temp);
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       rt_hw_interrupt_enable
;;;441    
;;;442        rt_schedule();
00003a  f7fffffe          BL       rt_schedule
;;;443    
;;;444        /* clear error number of this thread to RT_EOK */
;;;445        if (thread->error == -RT_ETIMEOUT)
00003e  6b20              LDR      r0,[r4,#0x30]
000040  1c80              ADDS     r0,r0,#2
000042  b908              CBNZ     r0,|L14.72|
;;;446            thread->error = RT_EOK;
000044  2000              MOVS     r0,#0
000046  6320              STR      r0,[r4,#0x30]
                  |L14.72|
;;;447    
;;;448        return RT_EOK;
000048  2000              MOVS     r0,#0
;;;449    }
00004a  bd38              POP      {r3-r5,pc}
;;;450    
                          ENDP

                  |L14.76|
                          DCD      rt_current_thread
                  |L14.80|
                          DCD      |symbol_number.59|
                  |L14.84|
000054  74687265          DCB      "thread != RT_NULL",0
000058  61642021
00005c  3d205254
000060  5f4e554c
000064  4c00    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.rt_thread_startup||, CODE, READONLY, ALIGN=2

                  rt_thread_startup PROC
;;;202     */
;;;203    rt_err_t rt_thread_startup(rt_thread_t thread)
000000  b510              PUSH     {r4,lr}
;;;204    {
000002  4604              MOV      r4,r0
;;;205        /* thread check */
;;;206        RT_ASSERT(thread != RT_NULL);
000004  b924              CBNZ     r4,|L15.16|
000006  22ce              MOVS     r2,#0xce
000008  4911              LDR      r1,|L15.80|
00000a  a012              ADR      r0,|L15.84|
00000c  f7fffffe          BL       rt_assert_handler
                  |L15.16|
;;;207        RT_ASSERT(thread->stat == RT_THREAD_INIT);
000010  f8940034          LDRB     r0,[r4,#0x34]
000014  b120              CBZ      r0,|L15.32|
000016  22cf              MOVS     r2,#0xcf
000018  490d              LDR      r1,|L15.80|
00001a  a013              ADR      r0,|L15.104|
00001c  f7fffffe          BL       rt_assert_handler
                  |L15.32|
;;;208    
;;;209        /* set current priority to init priority */
;;;210        thread->current_priority = thread->init_priority;
000020  f8940036          LDRB     r0,[r4,#0x36]
000024  f8840035          STRB     r0,[r4,#0x35]
;;;211    
;;;212        /* calculate priority attribute */
;;;213    #if RT_THREAD_PRIORITY_MAX > 32
;;;214        thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;215        thread->number_mask = 1L << thread->number;
;;;216        thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
;;;217    #else
;;;218        thread->number_mask = 1L << thread->current_priority;
000028  f8941035          LDRB     r1,[r4,#0x35]
00002c  2001              MOVS     r0,#1
00002e  4088              LSLS     r0,r0,r1
000030  63a0              STR      r0,[r4,#0x38]
;;;219    #endif
;;;220    
;;;221        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
000032  bf00              NOP      
000034  bf00              NOP      
;;;222                                       thread->name, thread->init_priority));
;;;223        /* change thread stat */
;;;224        thread->stat = RT_THREAD_SUSPEND;
000036  2002              MOVS     r0,#2
000038  f8840034          STRB     r0,[r4,#0x34]
;;;225        /* then resume it */
;;;226        rt_thread_resume(thread);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       rt_thread_resume
;;;227        if (rt_thread_self() != RT_NULL)
000042  f7fffffe          BL       rt_thread_self
000046  b108              CBZ      r0,|L15.76|
;;;228        {
;;;229            /* do a scheduling */
;;;230            rt_schedule();
000048  f7fffffe          BL       rt_schedule
                  |L15.76|
;;;231        }
;;;232    
;;;233        return RT_EOK;
00004c  2000              MOVS     r0,#0
;;;234    }
00004e  bd10              POP      {r4,pc}
;;;235    RTM_EXPORT(rt_thread_startup);
                          ENDP

                  |L15.80|
                          DCD      |symbol_number.56|
                  |L15.84|
000054  74687265          DCB      "thread != RT_NULL",0
000058  61642021
00005c  3d205254
000060  5f4e554c
000064  4c00    
000066  00                DCB      0
000067  00                DCB      0
                  |L15.104|
000068  74687265          DCB      "thread->stat == RT_THREAD_INIT",0
00006c  61642d3e
000070  73746174
000074  203d3d20
000078  52545f54
00007c  48524541
000080  445f494e
000084  495400  
000087  00                DCB      0

                          AREA ||i.rt_thread_suspend||, CODE, READONLY, ALIGN=2

                  rt_thread_suspend PROC
;;;553     */
;;;554    rt_err_t rt_thread_suspend(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;555    {
000002  4604              MOV      r4,r0
;;;556        register rt_base_t temp;
;;;557    
;;;558        /* thread check */
;;;559        RT_ASSERT(thread != RT_NULL);
000004  b92c              CBNZ     r4,|L16.18|
000006  f240222f          MOV      r2,#0x22f
00000a  4910              LDR      r1,|L16.76|
00000c  a010              ADR      r0,|L16.80|
00000e  f7fffffe          BL       rt_assert_handler
                  |L16.18|
;;;560    
;;;561        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));
000012  bf00              NOP      
000014  bf00              NOP      
;;;562    
;;;563        if (thread->stat != RT_THREAD_READY)
000016  f8940034          LDRB     r0,[r4,#0x34]
00001a  2801              CMP      r0,#1
00001c  d004              BEQ      |L16.40|
;;;564        {
;;;565            RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, %d\n",
00001e  bf00              NOP      
000020  bf00              NOP      
;;;566                                           thread->stat));
;;;567    
;;;568            return -RT_ERROR;
000022  f04f30ff          MOV      r0,#0xffffffff
                  |L16.38|
;;;569        }
;;;570    
;;;571        /* disable interrupt */
;;;572        temp = rt_hw_interrupt_disable();
;;;573    
;;;574        /* change thread stat */
;;;575        thread->stat = RT_THREAD_SUSPEND;
;;;576        rt_schedule_remove_thread(thread);
;;;577    
;;;578        /* stop thread timer anyway */
;;;579        rt_timer_stop(&(thread->thread_timer));
;;;580    
;;;581        /* enable interrupt */
;;;582        rt_hw_interrupt_enable(temp);
;;;583    
;;;584        return RT_EOK;
;;;585    }
000026  bd70              POP      {r4-r6,pc}
                  |L16.40|
000028  f7fffffe          BL       rt_hw_interrupt_disable
00002c  4605              MOV      r5,r0                 ;572
00002e  2002              MOVS     r0,#2                 ;575
000030  f8840034          STRB     r0,[r4,#0x34]         ;575
000034  4620              MOV      r0,r4                 ;576
000036  f7fffffe          BL       rt_schedule_remove_thread
00003a  f104004c          ADD      r0,r4,#0x4c           ;579
00003e  f7fffffe          BL       rt_timer_stop
000042  4628              MOV      r0,r5                 ;582
000044  f7fffffe          BL       rt_hw_interrupt_enable
000048  2000              MOVS     r0,#0                 ;584
00004a  e7ec              B        |L16.38|
;;;586    RTM_EXPORT(rt_thread_suspend);
                          ENDP

                  |L16.76|
                          DCD      |symbol_number.61|
                  |L16.80|
000050  74687265          DCB      "thread != RT_NULL",0
000054  61642021
000058  3d205254
00005c  5f4e554c
000060  4c00    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.rt_thread_timeout||, CODE, READONLY, ALIGN=2

                  rt_thread_timeout PROC
;;;635     */
;;;636    void rt_thread_timeout(void *parameter)
000000  b570              PUSH     {r4-r6,lr}
;;;637    {
000002  4605              MOV      r5,r0
;;;638        struct rt_thread *thread;
;;;639    
;;;640        thread = (struct rt_thread *)parameter;
000004  462c              MOV      r4,r5
;;;641    
;;;642        /* thread check */
;;;643        RT_ASSERT(thread != RT_NULL);
000006  b92c              CBNZ     r4,|L17.20|
000008  f2402283          MOV      r2,#0x283
00000c  490d              LDR      r1,|L17.68|
00000e  a00e              ADR      r0,|L17.72|
000010  f7fffffe          BL       rt_assert_handler
                  |L17.20|
;;;644        RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);
000014  f8940034          LDRB     r0,[r4,#0x34]
000018  2802              CMP      r0,#2
00001a  d005              BEQ      |L17.40|
00001c  f44f7221          MOV      r2,#0x284
000020  4908              LDR      r1,|L17.68|
000022  a00e              ADR      r0,|L17.92|
000024  f7fffffe          BL       rt_assert_handler
                  |L17.40|
;;;645    
;;;646        /* set error number */
;;;647        thread->error = -RT_ETIMEOUT;
000028  f06f0001          MVN      r0,#1
00002c  6320              STR      r0,[r4,#0x30]
;;;648    
;;;649        /* remove from suspend list */
;;;650        rt_list_remove(&(thread->tlist));
00002e  f1040014          ADD      r0,r4,#0x14
000032  f7fffffe          BL       rt_list_remove
;;;651    
;;;652        /* insert to schedule ready list */
;;;653        rt_schedule_insert_thread(thread);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       rt_schedule_insert_thread
;;;654    
;;;655        /* do schedule */
;;;656        rt_schedule();
00003c  f7fffffe          BL       rt_schedule
;;;657    }
000040  bd70              POP      {r4-r6,pc}
;;;658    RTM_EXPORT(rt_thread_timeout);
                          ENDP

000042  0000              DCW      0x0000
                  |L17.68|
                          DCD      |symbol_number.63|
                  |L17.72|
000048  74687265          DCB      "thread != RT_NULL",0
00004c  61642021
000050  3d205254
000054  5f4e554c
000058  4c00    
00005a  00                DCB      0
00005b  00                DCB      0
                  |L17.92|
00005c  74687265          DCB      "thread->stat == RT_THREAD_SUSPEND",0
000060  61642d3e
000064  73746174
000068  203d3d20
00006c  52545f54
000070  48524541
000074  445f5355
000078  5350454e
00007c  4400    
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.rt_thread_yield||, CODE, READONLY, ALIGN=2

                  rt_thread_yield PROC
;;;376     */
;;;377    rt_err_t rt_thread_yield(void)
000000  b570              PUSH     {r4-r6,lr}
;;;378    {
;;;379        register rt_base_t level;
;;;380        struct rt_thread *thread;
;;;381    
;;;382        /* disable interrupt */
;;;383        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4605              MOV      r5,r0
;;;384    
;;;385        /* set to current thread */
;;;386        thread = rt_current_thread;
000008  4813              LDR      r0,|L18.88|
00000a  6804              LDR      r4,[r0,#0]  ; rt_current_thread
;;;387    
;;;388        /* if the thread stat is READY and on ready queue list */
;;;389        if (thread->stat == RT_THREAD_READY &&
00000c  f8940034          LDRB     r0,[r4,#0x34]
000010  2801              CMP      r0,#1
000012  d11c              BNE      |L18.78|
;;;390            thread->tlist.next != thread->tlist.prev)
000014  e9d41005          LDRD     r1,r0,[r4,#0x14]
000018  4281              CMP      r1,r0
00001a  d018              BEQ      |L18.78|
;;;391        {
;;;392            /* remove thread from thread list */
;;;393            rt_list_remove(&(thread->tlist));
00001c  f1040014          ADD      r0,r4,#0x14
000020  f7fffffe          BL       rt_list_remove
;;;394    
;;;395            /* put thread to end of ready queue */
;;;396            rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
000024  f8942035          LDRB     r2,[r4,#0x35]
000028  4b0c              LDR      r3,|L18.92|
00002a  eb0300c2          ADD      r0,r3,r2,LSL #3
00002e  f1040114          ADD      r1,r4,#0x14
000032  6842              LDR      r2,[r0,#4]
000034  6011              STR      r1,[r2,#0]
000036  6842              LDR      r2,[r0,#4]
000038  604a              STR      r2,[r1,#4]
00003a  6041              STR      r1,[r0,#4]
00003c  6008              STR      r0,[r1,#0]
00003e  bf00              NOP      
;;;397                                  &(thread->tlist));
;;;398    
;;;399            /* enable interrupt */
;;;400            rt_hw_interrupt_enable(level);
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       rt_hw_interrupt_enable
;;;401    
;;;402            rt_schedule();
000046  f7fffffe          BL       rt_schedule
;;;403    
;;;404            return RT_EOK;
00004a  2000              MOVS     r0,#0
                  |L18.76|
;;;405        }
;;;406    
;;;407        /* enable interrupt */
;;;408        rt_hw_interrupt_enable(level);
;;;409    
;;;410        return RT_EOK;
;;;411    }
00004c  bd70              POP      {r4-r6,pc}
                  |L18.78|
00004e  4628              MOV      r0,r5                 ;408
000050  f7fffffe          BL       rt_hw_interrupt_enable
000054  2000              MOVS     r0,#0                 ;410
000056  e7f9              B        |L18.76|
;;;412    RTM_EXPORT(rt_thread_yield);
                          ENDP

                  |L18.88|
                          DCD      rt_current_thread
                  |L18.92|
                          DCD      rt_thread_priority_table

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  5f72745f          DCB      0x5f,0x72,0x74,0x5f
000004  74687265          DCB      0x74,0x68,0x72,0x65
000008  61645f69          DCB      0x61,0x64,0x5f,0x69
00000c  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.55|
000010  72745f74          DCB      0x72,0x74,0x5f,0x74
000014  68726561          DCB      0x68,0x72,0x65,0x61
000018  645f696e          DCB      0x64,0x5f,0x69,0x6e
00001c  697400            DCB      0x69,0x74,0x00
                  |symbol_number.56|
00001f  72                DCB      0x72
000020  745f7468          DCB      0x74,0x5f,0x74,0x68
000024  72656164          DCB      0x72,0x65,0x61,0x64
000028  5f737461          DCB      0x5f,0x73,0x74,0x61
00002c  72747570          DCB      0x72,0x74,0x75,0x70
000030  00                DCB      0x00
                  |symbol_number.57|
000031  72745f            DCB      0x72,0x74,0x5f
000034  74687265          DCB      0x74,0x68,0x72,0x65
000038  61645f64          DCB      0x61,0x64,0x5f,0x64
00003c  65746163          DCB      0x65,0x74,0x61,0x63
000040  6800              DCB      0x68,0x00
                  |symbol_number.58|
000042  7274              DCB      0x72,0x74
000044  5f746872          DCB      0x5f,0x74,0x68,0x72
000048  6561645f          DCB      0x65,0x61,0x64,0x5f
00004c  64656c65          DCB      0x64,0x65,0x6c,0x65
000050  746500            DCB      0x74,0x65,0x00
                  |symbol_number.59|
000053  72                DCB      0x72
000054  745f7468          DCB      0x74,0x5f,0x74,0x68
000058  72656164          DCB      0x72,0x65,0x61,0x64
00005c  5f736c65          DCB      0x5f,0x73,0x6c,0x65
000060  657000            DCB      0x65,0x70,0x00
                  |symbol_number.60|
000063  72                DCB      0x72
000064  745f7468          DCB      0x74,0x5f,0x74,0x68
000068  72656164          DCB      0x72,0x65,0x61,0x64
00006c  5f636f6e          DCB      0x5f,0x63,0x6f,0x6e
000070  74726f6c          DCB      0x74,0x72,0x6f,0x6c
000074  00                DCB      0x00
                  |symbol_number.61|
000075  72745f            DCB      0x72,0x74,0x5f
000078  74687265          DCB      0x74,0x68,0x72,0x65
00007c  61645f73          DCB      0x61,0x64,0x5f,0x73
000080  75737065          DCB      0x75,0x73,0x70,0x65
000084  6e6400            DCB      0x6e,0x64,0x00
                  |symbol_number.62|
000087  72                DCB      0x72
000088  745f7468          DCB      0x74,0x5f,0x74,0x68
00008c  72656164          DCB      0x72,0x65,0x61,0x64
000090  5f726573          DCB      0x5f,0x72,0x65,0x73
000094  756d6500          DCB      0x75,0x6d,0x65,0x00
                  |symbol_number.63|
000098  72745f74          DCB      0x72,0x74,0x5f,0x74
00009c  68726561          DCB      0x68,0x72,0x65,0x61
0000a0  645f7469          DCB      0x64,0x5f,0x74,0x69
0000a4  6d656f75          DCB      0x6d,0x65,0x6f,0x75
0000a8  7400              DCB      0x74,0x00
