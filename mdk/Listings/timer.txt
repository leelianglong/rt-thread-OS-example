; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\timer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\timer.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\timer.crf ..\rt_thread\kernel\timer.c]
                          THUMB

                          AREA ||i._rt_timer_init||, CODE, READONLY, ALIGN=1

                  _rt_timer_init PROC
;;;81     
;;;82     static void _rt_timer_init(rt_timer_t timer,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;83                                void (*timeout)(void *parameter),
;;;84                                void      *parameter,
;;;85                                rt_tick_t  time,
;;;86                                rt_uint8_t flag)
;;;87     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;88         int i;
;;;89     
;;;90         /* set flag */
;;;91         timer->parent.flag  = flag;
000010  f8849009          STRB     r9,[r4,#9]
;;;92     
;;;93         /* set deactivated */
;;;94         timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000014  7a60              LDRB     r0,[r4,#9]
000016  f0200001          BIC      r0,r0,#1
00001a  7260              STRB     r0,[r4,#9]
;;;95     
;;;96         timer->timeout_func = timeout;
00001c  61e6              STR      r6,[r4,#0x1c]
;;;97         timer->parameter    = parameter;
00001e  6227              STR      r7,[r4,#0x20]
;;;98     
;;;99         timer->timeout_tick = 0;
000020  2000              MOVS     r0,#0
000022  62a0              STR      r0,[r4,#0x28]
;;;100        timer->init_tick    = time;
000024  f8c48024          STR      r8,[r4,#0x24]
;;;101    
;;;102        /* initialize timer list */
;;;103        for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
000028  2500              MOVS     r5,#0
00002a  e006              B        |L1.58|
                  |L1.44|
;;;104        {
;;;105            rt_list_init(&(timer->row[i]));
00002c  f1040114          ADD      r1,r4,#0x14
000030  eb0100c5          ADD      r0,r1,r5,LSL #3
000034  f7fffffe          BL       rt_list_init
000038  1c6d              ADDS     r5,r5,#1              ;103
                  |L1.58|
00003a  2d01              CMP      r5,#1                 ;103
00003c  dbf6              BLT      |L1.44|
;;;106        }
;;;107    }
00003e  e8bd87f0          POP      {r4-r10,pc}
;;;108    
                          ENDP


                          AREA ||i._rt_timer_remove||, CODE, READONLY, ALIGN=1

                  _rt_timer_remove PROC
;;;122    
;;;123    rt_inline void _rt_timer_remove(rt_timer_t timer)
000000  b510              PUSH     {r4,lr}
;;;124    {
000002  4602              MOV      r2,r0
;;;125        int i;
;;;126    
;;;127        for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
000004  2000              MOVS     r0,#0
000006  4601              MOV      r1,r0
000008  e00e              B        |L2.40|
                  |L2.10|
;;;128        {
;;;129            rt_list_remove(&timer->row[i]);
00000a  f1020314          ADD      r3,r2,#0x14
00000e  eb0300c1          ADD      r0,r3,r1,LSL #3
000012  e9d04300          LDRD     r4,r3,[r0,#0]
000016  6063              STR      r3,[r4,#4]
000018  e9d03400          LDRD     r3,r4,[r0,#0]
00001c  6023              STR      r3,[r4,#0]
00001e  6040              STR      r0,[r0,#4]
000020  6000              STR      r0,[r0,#0]
000022  bf00              NOP      
000024  1c48              ADDS     r0,r1,#1              ;127
000026  4601              MOV      r1,r0                 ;127
                  |L2.40|
000028  2901              CMP      r1,#1                 ;127
00002a  dbee              BLT      |L2.10|
;;;130        }
;;;131    }
00002c  bd10              POP      {r4,pc}
;;;132    
                          ENDP


                          AREA ||i.rt_list_init||, CODE, READONLY, ALIGN=1

                  rt_list_init PROC
;;;50      */
;;;51     rt_inline void rt_list_init(rt_list_t *l)
000000  6040              STR      r0,[r0,#4]
;;;52     {
;;;53         l->next = l->prev = l;
000002  6000              STR      r0,[r0,#0]
;;;54     }
000004  4770              BX       lr
;;;55     
                          ENDP


                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
000002  6051              STR      r1,[r2,#4]
;;;65         n->next = l->next;
000004  6802              LDR      r2,[r0,#0]
000006  600a              STR      r2,[r1,#0]
;;;66     
;;;67         l->next = n;
000008  6001              STR      r1,[r0,#0]
;;;68         n->prev = l;
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;101     */
;;;102    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  4601              MOV      r1,r0
;;;103    {
;;;104        return l->next == l;
000002  6808              LDR      r0,[r1,#0]
000004  4288              CMP      r0,r1
000006  d101              BNE      |L5.12|
000008  2001              MOVS     r0,#1
                  |L5.10|
;;;105    }
00000a  4770              BX       lr
                  |L5.12|
00000c  2000              MOVS     r0,#0                 ;104
00000e  e7fc              B        |L5.10|
;;;106    
                          ENDP


                          AREA ||i.rt_system_timer_init||, CODE, READONLY, ALIGN=2

                  rt_system_timer_init PROC
;;;670     */
;;;671    void rt_system_timer_init(void)
000000  b510              PUSH     {r4,lr}
;;;672    {
;;;673        int i;
;;;674    
;;;675        for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
000002  2400              MOVS     r4,#0
000004  e005              B        |L6.18|
                  |L6.6|
;;;676        {
;;;677            rt_list_init(rt_timer_list+i);
000006  4904              LDR      r1,|L6.24|
000008  eb0100c4          ADD      r0,r1,r4,LSL #3
00000c  f7fffffe          BL       rt_list_init
000010  1c64              ADDS     r4,r4,#1              ;675
                  |L6.18|
000012  2c00              CMP      r4,#0                 ;675
000014  d0f7              BEQ      |L6.6|
;;;678        }
;;;679    }
000016  bd10              POP      {r4,pc}
;;;680    
                          ENDP

                  |L6.24|
                          DCD      rt_timer_list

                          AREA ||i.rt_system_timer_thread_init||, CODE, READONLY, ALIGN=1

                  rt_system_timer_thread_init PROC
;;;685     */
;;;686    void rt_system_timer_thread_init(void)
000000  4770              BX       lr
;;;687    {
;;;688    #ifdef RT_USING_TIMER_SOFT
;;;689        int i;
;;;690    
;;;691        for (i = 0;
;;;692             i < sizeof(rt_soft_timer_list)/sizeof(rt_soft_timer_list[0]);
;;;693             i++)
;;;694        {
;;;695            rt_list_init(rt_soft_timer_list+i);
;;;696        }
;;;697    
;;;698        /* start software timer thread */
;;;699        rt_thread_init(&timer_thread,
;;;700                       "timer",
;;;701                       rt_thread_timer_entry,
;;;702                       RT_NULL,
;;;703                       &timer_thread_stack[0],
;;;704                       sizeof(timer_thread_stack),
;;;705                       RT_TIMER_THREAD_PRIO,
;;;706                       10);
;;;707    
;;;708        /* startup */
;;;709        rt_thread_startup(&timer_thread);
;;;710    #endif
;;;711    }
;;;712    
                          ENDP


                          AREA ||i.rt_timer_check||, CODE, READONLY, ALIGN=2

                  rt_timer_check PROC
;;;487     */
;;;488    void rt_timer_check(void)
000000  b570              PUSH     {r4-r6,lr}
;;;489    {
;;;490        struct rt_timer *t;
;;;491        rt_tick_t current_tick;
;;;492        register rt_base_t level;
;;;493    
;;;494        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));
000002  bf00              NOP      
000004  bf00              NOP      
;;;495    
;;;496        current_tick = rt_tick_get();
000006  f7fffffe          BL       rt_tick_get
00000a  4605              MOV      r5,r0
;;;497    
;;;498        /* disable interrupt */
;;;499        level = rt_hw_interrupt_disable();
00000c  f7fffffe          BL       rt_hw_interrupt_disable
000010  4606              MOV      r6,r0
;;;500    
;;;501        while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
000012  e033              B        |L8.124|
                  |L8.20|
;;;502        {
;;;503            t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
000014  481f              LDR      r0,|L8.148|
000016  6800              LDR      r0,[r0,#0]  ; rt_timer_list
000018  f1a00414          SUB      r4,r0,#0x14
;;;504                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
;;;505    
;;;506            /*
;;;507             * It supposes that the new tick shall less than the half duration of
;;;508             * tick max.
;;;509             */
;;;510            if ((current_tick - t->timeout_tick) < RT_TICK_MAX/2)
00001c  6aa0              LDR      r0,[r4,#0x28]
00001e  1a28              SUBS     r0,r5,r0
000020  f06f4100          MVN      r1,#0x80000000
000024  4288              CMP      r0,r1
000026  d228              BCS      |L8.122|
;;;511            {
;;;512                RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
000028  bf00              NOP      
00002a  481b              LDR      r0,|L8.152|
00002c  6800              LDR      r0,[r0,#0]  ; rt_timer_timeout_hook
00002e  b118              CBZ      r0,|L8.56|
000030  4620              MOV      r0,r4
000032  4919              LDR      r1,|L8.152|
000034  6809              LDR      r1,[r1,#0]  ; rt_timer_timeout_hook
000036  4788              BLX      r1
                  |L8.56|
000038  bf00              NOP      
;;;513    
;;;514                /* remove timer from timer list firstly */
;;;515                _rt_timer_remove(t);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       _rt_timer_remove
;;;516    
;;;517                /* call timeout function */
;;;518                t->timeout_func(t->parameter);
000040  e9d41007          LDRD     r1,r0,[r4,#0x1c]
000044  4788              BLX      r1
;;;519    
;;;520                /* re-get tick */
;;;521                current_tick = rt_tick_get();
000046  f7fffffe          BL       rt_tick_get
00004a  4605              MOV      r5,r0
;;;522    
;;;523                RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));
00004c  bf00              NOP      
00004e  bf00              NOP      
;;;524    
;;;525                if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
000050  7a60              LDRB     r0,[r4,#9]
000052  f0000002          AND      r0,r0,#2
000056  b158              CBZ      r0,|L8.112|
;;;526                    (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
000058  7a60              LDRB     r0,[r4,#9]
00005a  f0000001          AND      r0,r0,#1
00005e  b138              CBZ      r0,|L8.112|
;;;527                {
;;;528                    /* start it */
;;;529                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000060  7a60              LDRB     r0,[r4,#9]
000062  f0200001          BIC      r0,r0,#1
000066  7260              STRB     r0,[r4,#9]
;;;530                    rt_timer_start(t);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       rt_timer_start
00006e  e005              B        |L8.124|
                  |L8.112|
;;;531                }
;;;532                else
;;;533                {
;;;534                    /* stop timer */
;;;535                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000070  7a60              LDRB     r0,[r4,#9]
000072  f0200001          BIC      r0,r0,#1
000076  7260              STRB     r0,[r4,#9]
000078  e000              B        |L8.124|
                  |L8.122|
;;;536                }
;;;537            }
;;;538            else
;;;539                break;
00007a  e004              B        |L8.134|
                  |L8.124|
00007c  4805              LDR      r0,|L8.148|
00007e  f7fffffe          BL       rt_list_isempty
000082  2800              CMP      r0,#0                 ;501
000084  d0c6              BEQ      |L8.20|
                  |L8.134|
000086  bf00              NOP      
;;;540        }
;;;541    
;;;542        /* enable interrupt */
;;;543        rt_hw_interrupt_enable(level);
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       rt_hw_interrupt_enable
;;;544    
;;;545        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
00008e  bf00              NOP      
000090  bf00              NOP      
;;;546    }
000092  bd70              POP      {r4-r6,pc}
;;;547    
                          ENDP

                  |L8.148|
                          DCD      rt_timer_list
                  |L8.152|
                          DCD      rt_timer_timeout_hook

                          AREA ||i.rt_timer_control||, CODE, READONLY, ALIGN=2

                  rt_timer_control PROC
;;;453     */
;;;454    rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;455    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;456        /* timer check */
;;;457        RT_ASSERT(timer != RT_NULL);
000008  b92c              CBNZ     r4,|L9.22|
00000a  f24012c9          MOV      r2,#0x1c9
00000e  490f              LDR      r1,|L9.76|
000010  a00f              ADR      r0,|L9.80|
000012  f7fffffe          BL       rt_assert_handler
                  |L9.22|
;;;458    
;;;459        switch (cmd)
000016  b14e              CBZ      r6,|L9.44|
000018  2e01              CMP      r6,#1
00001a  d004              BEQ      |L9.38|
00001c  2e02              CMP      r6,#2
00001e  d008              BEQ      |L9.50|
000020  2e03              CMP      r6,#3
000022  d110              BNE      |L9.70|
000024  e00a              B        |L9.60|
                  |L9.38|
;;;460        {
;;;461        case RT_TIMER_CTRL_GET_TIME:
;;;462            *(rt_tick_t *)arg = timer->init_tick;
000026  6a60              LDR      r0,[r4,#0x24]
000028  6028              STR      r0,[r5,#0]
;;;463            break;
00002a  e00c              B        |L9.70|
                  |L9.44|
;;;464    
;;;465        case RT_TIMER_CTRL_SET_TIME:
;;;466            timer->init_tick = *(rt_tick_t *)arg;
00002c  6828              LDR      r0,[r5,#0]
00002e  6260              STR      r0,[r4,#0x24]
;;;467            break;
000030  e009              B        |L9.70|
                  |L9.50|
;;;468    
;;;469        case RT_TIMER_CTRL_SET_ONESHOT:
;;;470            timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
000032  7a60              LDRB     r0,[r4,#9]
000034  f0200002          BIC      r0,r0,#2
000038  7260              STRB     r0,[r4,#9]
;;;471            break;
00003a  e004              B        |L9.70|
                  |L9.60|
;;;472    
;;;473        case RT_TIMER_CTRL_SET_PERIODIC:
;;;474            timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
00003c  7a60              LDRB     r0,[r4,#9]
00003e  f0400002          ORR      r0,r0,#2
000042  7260              STRB     r0,[r4,#9]
;;;475            break;
000044  bf00              NOP      
                  |L9.70|
000046  bf00              NOP                            ;463
;;;476        }
;;;477    
;;;478        return RT_EOK;
000048  2000              MOVS     r0,#0
;;;479    }
00004a  bd70              POP      {r4-r6,pc}
;;;480    RTM_EXPORT(rt_timer_control);
                          ENDP

                  |L9.76|
                          DCD      |symbol_number.56|
                  |L9.80|
000050  74696d65          DCB      "timer != RT_NULL",0
000054  7220213d
000058  2052545f
00005c  4e554c4c
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.rt_timer_create||, CODE, READONLY, ALIGN=1

                  rt_timer_create PROC
;;;236     */
;;;237    rt_timer_t rt_timer_create(const char *name,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;238                               void (*timeout)(void *parameter),
;;;239                               void       *parameter,
;;;240                               rt_tick_t   time,
;;;241                               rt_uint8_t  flag)
;;;242    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;243        struct rt_timer *timer;
;;;244    
;;;245        /* allocate a object */
;;;246        timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
000010  4621              MOV      r1,r4
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       rt_object_allocate
000018  4605              MOV      r5,r0
;;;247        if (timer == RT_NULL)
00001a  b915              CBNZ     r5,|L10.34|
;;;248        {
;;;249            return RT_NULL;
00001c  2000              MOVS     r0,#0
                  |L10.30|
;;;250        }
;;;251    
;;;252        _rt_timer_init(timer, timeout, parameter, time, flag);
;;;253    
;;;254        return timer;
;;;255    }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L10.34|
000022  4643              MOV      r3,r8                 ;252
000024  463a              MOV      r2,r7                 ;252
000026  4631              MOV      r1,r6                 ;252
000028  4628              MOV      r0,r5                 ;252
00002a  f8cd9000          STR      r9,[sp,#0]            ;252
00002e  f7fffffe          BL       _rt_timer_init
000032  4628              MOV      r0,r5                 ;254
000034  e7f3              B        |L10.30|
;;;256    RTM_EXPORT(rt_timer_create);
                          ENDP


                          AREA ||i.rt_timer_delete||, CODE, READONLY, ALIGN=2

                  rt_timer_delete PROC
;;;264     */
;;;265    rt_err_t rt_timer_delete(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
000002  4604              MOV      r4,r0
;;;267        register rt_base_t level;
;;;268    
;;;269        /* timer check */
;;;270        RT_ASSERT(timer != RT_NULL);
000004  b92c              CBNZ     r4,|L11.18|
000006  f44f7287          MOV      r2,#0x10e
00000a  4909              LDR      r1,|L11.48|
00000c  a009              ADR      r0,|L11.52|
00000e  f7fffffe          BL       rt_assert_handler
                  |L11.18|
;;;271    
;;;272        /* disable interrupt */
;;;273        level = rt_hw_interrupt_disable();
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4605              MOV      r5,r0
;;;274    
;;;275        _rt_timer_remove(timer);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       _rt_timer_remove
;;;276    
;;;277        /* enable interrupt */
;;;278        rt_hw_interrupt_enable(level);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       rt_hw_interrupt_enable
;;;279    
;;;280        rt_object_delete((rt_object_t)timer);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       rt_object_delete
;;;281    
;;;282        return -RT_EOK;
00002a  2000              MOVS     r0,#0
;;;283    }
00002c  bd70              POP      {r4-r6,pc}
;;;284    RTM_EXPORT(rt_timer_delete);
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      |symbol_number.53|
                  |L11.52|
000034  74696d65          DCB      "timer != RT_NULL",0
000038  7220213d
00003c  2052545f
000040  4e554c4c
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.rt_timer_detach||, CODE, READONLY, ALIGN=2

                  rt_timer_detach PROC
;;;203     */
;;;204    rt_err_t rt_timer_detach(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;205    {
000002  4604              MOV      r4,r0
;;;206        register rt_base_t level;
;;;207    
;;;208        /* timer check */
;;;209        RT_ASSERT(timer != RT_NULL);
000004  b924              CBNZ     r4,|L12.16|
000006  22d1              MOVS     r2,#0xd1
000008  4908              LDR      r1,|L12.44|
00000a  a009              ADR      r0,|L12.48|
00000c  f7fffffe          BL       rt_assert_handler
                  |L12.16|
;;;210    
;;;211        /* disable interrupt */
;;;212        level = rt_hw_interrupt_disable();
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4605              MOV      r5,r0
;;;213    
;;;214        _rt_timer_remove(timer);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       _rt_timer_remove
;;;215    
;;;216        /* enable interrupt */
;;;217        rt_hw_interrupt_enable(level);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       rt_hw_interrupt_enable
;;;218    
;;;219        rt_object_detach((rt_object_t)timer);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_object_detach
;;;220    
;;;221        return -RT_EOK;
000028  2000              MOVS     r0,#0
;;;222    }
00002a  bd70              POP      {r4-r6,pc}
;;;223    RTM_EXPORT(rt_timer_detach);
                          ENDP

                  |L12.44|
                          DCD      |symbol_number.52|
                  |L12.48|
000030  74696d65          DCB      "timer != RT_NULL",0
000034  7220213d
000038  2052545f
00003c  4e554c4c
000040  00      
000041  00                DCB      0
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.rt_timer_init||, CODE, READONLY, ALIGN=2

                  rt_timer_init PROC
;;;179     */
;;;180    void rt_timer_init(rt_timer_t  timer,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;181                       const char *name,
;;;182                       void (*timeout)(void *parameter),
;;;183                       void       *parameter,
;;;184                       rt_tick_t   time,
;;;185                       rt_uint8_t  flag)
;;;186    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;187        /* timer check */
;;;188        RT_ASSERT(timer != RT_NULL);
000010  b924              CBNZ     r4,|L13.28|
000012  22bc              MOVS     r2,#0xbc
000014  4909              LDR      r1,|L13.60|
000016  a00a              ADR      r0,|L13.64|
000018  f7fffffe          BL       rt_assert_handler
                  |L13.28|
;;;189    
;;;190        /* timer object initialization */
;;;191        rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
00001c  462a              MOV      r2,r5
00001e  2108              MOVS     r1,#8
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       rt_object_init
;;;192    
;;;193        _rt_timer_init(timer, timeout, parameter, time, flag);
000026  4643              MOV      r3,r8
000028  463a              MOV      r2,r7
00002a  4631              MOV      r1,r6
00002c  4620              MOV      r0,r4
00002e  f8cd9000          STR      r9,[sp,#0]
000032  f7fffffe          BL       _rt_timer_init
;;;194    }
000036  e8bd83f8          POP      {r3-r9,pc}
;;;195    RTM_EXPORT(rt_timer_init);
                          ENDP

00003a  0000              DCW      0x0000
                  |L13.60|
                          DCD      __FUNCTION__
                  |L13.64|
000040  74696d65          DCB      "timer != RT_NULL",0
000044  7220213d
000048  2052545f
00004c  4e554c4c
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.rt_timer_list_next_timeout||, CODE, READONLY, ALIGN=1

                  rt_timer_list_next_timeout PROC
;;;109    /* the fist timer always in the last row */
;;;110    static rt_tick_t rt_timer_list_next_timeout(rt_list_t timer_list[])
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
000002  4604              MOV      r4,r0
;;;112        struct rt_timer *timer;
;;;113    
;;;114        if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       rt_list_isempty
00000a  b110              CBZ      r0,|L14.18|
;;;115            return RT_TICK_MAX;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L14.16|
;;;116    
;;;117        timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
;;;118                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
;;;119    
;;;120        return timer->timeout_tick;
;;;121    }
000010  bd70              POP      {r4-r6,pc}
                  |L14.18|
000012  6820              LDR      r0,[r4,#0]            ;117
000014  f1a00514          SUB      r5,r0,#0x14           ;117
000018  6aa8              LDR      r0,[r5,#0x28]         ;120
00001a  e7f9              B        |L14.16|
;;;122    
                          ENDP


                          AREA ||i.rt_timer_next_timeout_tick||, CODE, READONLY, ALIGN=2

                  rt_timer_next_timeout_tick PROC
;;;552     */
;;;553    rt_tick_t rt_timer_next_timeout_tick(void)
000000  b510              PUSH     {r4,lr}
;;;554    {
;;;555        return rt_timer_list_next_timeout(rt_timer_list);
000002  4802              LDR      r0,|L15.12|
000004  f7fffffe          BL       rt_timer_list_next_timeout
;;;556    }
000008  bd10              POP      {r4,pc}
;;;557    
                          ENDP

00000a  0000              DCW      0x0000
                  |L15.12|
                          DCD      rt_timer_list

                          AREA ||i.rt_timer_start||, CODE, READONLY, ALIGN=2

                  rt_timer_start PROC
;;;293     */
;;;294    rt_err_t rt_timer_start(rt_timer_t timer)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;295    {
000004  4605              MOV      r5,r0
;;;296        unsigned int row_lvl;
;;;297        rt_list_t *timer_list;
;;;298        register rt_base_t level;
;;;299        rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
;;;300        unsigned int tst_nr;
;;;301        static unsigned int random_nr;
;;;302    
;;;303        /* timer check */
;;;304        RT_ASSERT(timer != RT_NULL);
000006  b92d              CBNZ     r5,|L16.20|
000008  f44f7298          MOV      r2,#0x130
00000c  4945              LDR      r1,|L16.292|
00000e  a046              ADR      r0,|L16.296|
000010  f7fffffe          BL       rt_assert_handler
                  |L16.20|
;;;305    
;;;306    	/* stop timer firstly */
;;;307    	level = rt_hw_interrupt_disable();
000014  f7fffffe          BL       rt_hw_interrupt_disable
000018  4680              MOV      r8,r0
;;;308    	/* remove timer from list */
;;;309        _rt_timer_remove(timer);
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       _rt_timer_remove
;;;310        /* change status of timer */
;;;311        timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000020  7a68              LDRB     r0,[r5,#9]
000022  f0200001          BIC      r0,r0,#1
000026  7268              STRB     r0,[r5,#9]
;;;312        rt_hw_interrupt_enable(level);
000028  4640              MOV      r0,r8
00002a  f7fffffe          BL       rt_hw_interrupt_enable
;;;313    
;;;314        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
00002e  bf00              NOP      
000030  4842              LDR      r0,|L16.316|
000032  6800              LDR      r0,[r0,#0]  ; rt_object_take_hook
000034  b118              CBZ      r0,|L16.62|
000036  4628              MOV      r0,r5
000038  4940              LDR      r1,|L16.316|
00003a  6809              LDR      r1,[r1,#0]  ; rt_object_take_hook
00003c  4788              BLX      r1
                  |L16.62|
00003e  bf00              NOP      
;;;315    
;;;316        /*
;;;317         * get timeout tick,
;;;318         * the max timeout tick shall not great than RT_TICK_MAX/2
;;;319         */
;;;320        RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
000040  f06f4100          MVN      r1,#0x80000000
000044  6a68              LDR      r0,[r5,#0x24]
000046  4288              CMP      r0,r1
000048  d305              BCC      |L16.86|
00004a  f44f72a0          MOV      r2,#0x140
00004e  4935              LDR      r1,|L16.292|
000050  a03b              ADR      r0,|L16.320|
000052  f7fffffe          BL       rt_assert_handler
                  |L16.86|
;;;321        timer->timeout_tick = rt_tick_get() + timer->init_tick;
000056  f7fffffe          BL       rt_tick_get
00005a  6a69              LDR      r1,[r5,#0x24]
00005c  4408              ADD      r0,r0,r1
00005e  62a8              STR      r0,[r5,#0x28]
;;;322    
;;;323        /* disable interrupt */
;;;324        level = rt_hw_interrupt_disable();
000060  f7fffffe          BL       rt_hw_interrupt_disable
000064  4680              MOV      r8,r0
;;;325    
;;;326    #ifdef RT_USING_TIMER_SOFT
;;;327        if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
;;;328        {
;;;329            /* insert timer to soft timer list */
;;;330            timer_list = rt_soft_timer_list;
;;;331        }
;;;332        else
;;;333    #endif
;;;334        {
;;;335            /* insert timer to system timer list */
;;;336            timer_list = rt_timer_list;
000066  4e3f              LDR      r6,|L16.356|
;;;337        }
;;;338    
;;;339        row_head[0]  = &timer_list[0];
000068  9600              STR      r6,[sp,#0]
;;;340        for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
00006a  2400              MOVS     r4,#0
00006c  e02a              B        |L16.196|
                  |L16.110|
;;;341        {
;;;342            for (;row_head[row_lvl] != timer_list[row_lvl].prev;
00006e  e019              B        |L16.164|
                  |L16.112|
;;;343                 row_head[row_lvl]  = row_head[row_lvl]->next)
;;;344            {
;;;345                struct rt_timer *t;
;;;346                rt_list_t *p = row_head[row_lvl]->next;
000070  f85d2024          LDR      r2,[sp,r4,LSL #2]
000074  6811              LDR      r1,[r2,#0]
;;;347    
;;;348                /* fix up the entry pointer */
;;;349                t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
000076  2214              MOVS     r2,#0x14
000078  eb0202c4          ADD      r2,r2,r4,LSL #3
00007c  1a88              SUBS     r0,r1,r2
;;;350    
;;;351                /* If we have two timers that timeout at the same time, it's
;;;352                 * preferred that the timer inserted early get called early.
;;;353                 * So insert the new timer to the end the the some-timeout timer
;;;354                 * list.
;;;355                 */
;;;356                if ((t->timeout_tick - timer->timeout_tick) == 0)
00007e  6a82              LDR      r2,[r0,#0x28]
000080  6aab              LDR      r3,[r5,#0x28]
000082  1ad2              SUBS     r2,r2,r3
000084  d100              BNE      |L16.136|
;;;357                {
;;;358                    continue;
000086  e008              B        |L16.154|
                  |L16.136|
;;;359                }
;;;360                else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
000088  6a82              LDR      r2,[r0,#0x28]
00008a  6aab              LDR      r3,[r5,#0x28]
00008c  1ad2              SUBS     r2,r2,r3
00008e  f06f4300          MVN      r3,#0x80000000
000092  429a              CMP      r2,r3
000094  d200              BCS      |L16.152|
;;;361                {
;;;362                    break;
000096  e00c              B        |L16.178|
                  |L16.152|
000098  bf00              NOP                            ;358
                  |L16.154|
00009a  f85d0024          LDR      r0,[sp,r4,LSL #2]     ;343
00009e  6800              LDR      r0,[r0,#0]            ;343
0000a0  f84d0024          STR      r0,[sp,r4,LSL #2]     ;343
                  |L16.164|
0000a4  f85d0024          LDR      r0,[sp,r4,LSL #2]     ;342
0000a8  eb0601c4          ADD      r1,r6,r4,LSL #3       ;342
0000ac  6849              LDR      r1,[r1,#4]            ;342
0000ae  4288              CMP      r0,r1                 ;342
0000b0  d1de              BNE      |L16.112|
                  |L16.178|
0000b2  bf00              NOP      
;;;363                }
;;;364            }
;;;365            if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
0000b4  b12c              CBZ      r4,|L16.194|
;;;366                row_head[row_lvl+1] = row_head[row_lvl]+1;
0000b6  f85d0024          LDR      r0,[sp,r4,LSL #2]
0000ba  3008              ADDS     r0,r0,#8
0000bc  1c61              ADDS     r1,r4,#1
0000be  f84d0021          STR      r0,[sp,r1,LSL #2]
                  |L16.194|
0000c2  1c64              ADDS     r4,r4,#1              ;340
                  |L16.196|
0000c4  2c00              CMP      r4,#0                 ;340
0000c6  d0d2              BEQ      |L16.110|
;;;367        }
;;;368    
;;;369        /* Interestingly, this super simple timer insert counter works very very
;;;370         * well on distributing the list height uniformly. By means of "very very
;;;371         * well", I mean it beats the randomness of timer->timeout_tick very easily
;;;372         * (actually, the timeout_tick is not random and easy to be attacked). */
;;;373        random_nr++;
0000c8  4827              LDR      r0,|L16.360|
0000ca  6800              LDR      r0,[r0,#0]  ; random_nr
0000cc  1c40              ADDS     r0,r0,#1
0000ce  4926              LDR      r1,|L16.360|
0000d0  6008              STR      r0,[r1,#0]  ; random_nr
;;;374        tst_nr = random_nr;
0000d2  4608              MOV      r0,r1
0000d4  6807              LDR      r7,[r0,#0]  ; random_nr
;;;375    
;;;376        rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
0000d6  f1050114          ADD      r1,r5,#0x14
0000da  9800              LDR      r0,[sp,#0]
0000dc  f7fffffe          BL       rt_list_insert_after
;;;377                             &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
;;;378        for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
0000e0  2402              MOVS     r4,#2
0000e2  e012              B        |L16.266|
                  |L16.228|
;;;379        {
;;;380            if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
0000e4  f0070003          AND      r0,r7,#3
0000e8  b960              CBNZ     r0,|L16.260|
;;;381                rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
0000ea  f1c40301          RSB      r3,r4,#1
0000ee  f1050214          ADD      r2,r5,#0x14
0000f2  eb0201c3          ADD      r1,r2,r3,LSL #3
0000f6  f1c40201          RSB      r2,r4,#1
0000fa  f85d0022          LDR      r0,[sp,r2,LSL #2]
0000fe  f7fffffe          BL       rt_list_insert_after
000102  e000              B        |L16.262|
                  |L16.260|
;;;382                                     &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
;;;383            else
;;;384                break;
000104  e003              B        |L16.270|
                  |L16.262|
;;;385            /* Shift over the bits we have tested. Works well with 1 bit and 2
;;;386             * bits. */
;;;387            tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
000106  08bf              LSRS     r7,r7,#2
000108  1c64              ADDS     r4,r4,#1              ;378
                  |L16.266|
00010a  2c01              CMP      r4,#1                 ;378
00010c  d9ea              BLS      |L16.228|
                  |L16.270|
00010e  bf00              NOP                            ;384
;;;388        }
;;;389    
;;;390        timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
000110  7a68              LDRB     r0,[r5,#9]
000112  f0400001          ORR      r0,r0,#1
000116  7268              STRB     r0,[r5,#9]
;;;391    
;;;392        /* enable interrupt */
;;;393        rt_hw_interrupt_enable(level);
000118  4640              MOV      r0,r8
00011a  f7fffffe          BL       rt_hw_interrupt_enable
;;;394    
;;;395    #ifdef RT_USING_TIMER_SOFT
;;;396        if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
;;;397        {
;;;398            /* check whether timer thread is ready */
;;;399            if (timer_thread.stat != RT_THREAD_READY)
;;;400            {
;;;401                /* resume timer thread to check soft timer */
;;;402                rt_thread_resume(&timer_thread);
;;;403                rt_schedule();
;;;404            }
;;;405        }
;;;406    #endif
;;;407    
;;;408        return -RT_EOK;
00011e  2000              MOVS     r0,#0
;;;409    }
000120  e8bd83f8          POP      {r3-r9,pc}
;;;410    RTM_EXPORT(rt_timer_start);
                          ENDP

                  |L16.292|
                          DCD      |symbol_number.54|
                  |L16.296|
000128  74696d65          DCB      "timer != RT_NULL",0
00012c  7220213d
000130  2052545f
000134  4e554c4c
000138  00      
000139  00                DCB      0
00013a  00                DCB      0
00013b  00                DCB      0
                  |L16.316|
                          DCD      rt_object_take_hook
                  |L16.320|
000140  74696d65          DCB      "timer->init_tick < RT_TICK_MAX / 2",0
000144  722d3e69
000148  6e69745f
00014c  7469636b
000150  203c2052
000154  545f5449
000158  434b5f4d
00015c  4158202f
000160  203200  
000163  00                DCB      0
                  |L16.356|
                          DCD      rt_timer_list
                  |L16.360|
                          DCD      random_nr

                          AREA ||i.rt_timer_stop||, CODE, READONLY, ALIGN=2

                  rt_timer_stop PROC
;;;418     */
;;;419    rt_err_t rt_timer_stop(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;420    {
000002  4604              MOV      r4,r0
;;;421        register rt_base_t level;
;;;422    
;;;423        /* timer check */
;;;424        RT_ASSERT(timer != RT_NULL);
000004  b92c              CBNZ     r4,|L17.18|
000006  f44f72d4          MOV      r2,#0x1a8
00000a  4911              LDR      r1,|L17.80|
00000c  a011              ADR      r0,|L17.84|
00000e  f7fffffe          BL       rt_assert_handler
                  |L17.18|
;;;425        if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
000012  7a60              LDRB     r0,[r4,#9]
000014  f0000001          AND      r0,r0,#1
000018  b910              CBNZ     r0,|L17.32|
;;;426            return -RT_ERROR;
00001a  f04f30ff          MOV      r0,#0xffffffff
                  |L17.30|
;;;427    
;;;428        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
;;;429    
;;;430        /* disable interrupt */
;;;431        level = rt_hw_interrupt_disable();
;;;432    
;;;433        _rt_timer_remove(timer);
;;;434    
;;;435        /* enable interrupt */
;;;436        rt_hw_interrupt_enable(level);
;;;437    
;;;438        /* change stat */
;;;439        timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
;;;440    
;;;441        return RT_EOK;
;;;442    }
00001e  bd70              POP      {r4-r6,pc}
                  |L17.32|
000020  bf00              NOP                            ;428
000022  4811              LDR      r0,|L17.104|
000024  6800              LDR      r0,[r0,#0]            ;428  ; rt_object_put_hook
000026  b118              CBZ      r0,|L17.48|
000028  4620              MOV      r0,r4                 ;428
00002a  490f              LDR      r1,|L17.104|
00002c  6809              LDR      r1,[r1,#0]            ;428  ; rt_object_put_hook
00002e  4788              BLX      r1                    ;428
                  |L17.48|
000030  bf00              NOP                            ;428
000032  f7fffffe          BL       rt_hw_interrupt_disable
000036  4605              MOV      r5,r0                 ;431
000038  4620              MOV      r0,r4                 ;433
00003a  f7fffffe          BL       _rt_timer_remove
00003e  4628              MOV      r0,r5                 ;436
000040  f7fffffe          BL       rt_hw_interrupt_enable
000044  7a60              LDRB     r0,[r4,#9]            ;439
000046  f0200001          BIC      r0,r0,#1              ;439
00004a  7260              STRB     r0,[r4,#9]            ;439
00004c  2000              MOVS     r0,#0                 ;441
00004e  e7e6              B        |L17.30|
;;;443    RTM_EXPORT(rt_timer_stop);
                          ENDP

                  |L17.80|
                          DCD      |symbol_number.55|
                  |L17.84|
000054  74696d65          DCB      "timer != RT_NULL",0
000058  7220213d
00005c  2052545f
000060  4e554c4c
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L17.104|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_timer_timeout_sethook||, CODE, READONLY, ALIGN=2

                  rt_timer_timeout_sethook PROC
;;;73      */
;;;74     void rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer))
000000  4901              LDR      r1,|L18.8|
;;;75     {
;;;76         rt_timer_timeout_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_timer_timeout_hook
;;;77     }
000004  4770              BX       lr
;;;78     
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      rt_timer_timeout_hook

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f74          DCB      0x72,0x74,0x5f,0x74
000004  696d6572          DCB      0x69,0x6d,0x65,0x72
000008  5f696e69          DCB      0x5f,0x69,0x6e,0x69
00000c  7400              DCB      0x74,0x00
                  |symbol_number.52|
00000e  7274              DCB      0x72,0x74
000010  5f74696d          DCB      0x5f,0x74,0x69,0x6d
000014  65725f64          DCB      0x65,0x72,0x5f,0x64
000018  65746163          DCB      0x65,0x74,0x61,0x63
00001c  6800              DCB      0x68,0x00
                  |symbol_number.53|
00001e  7274              DCB      0x72,0x74
000020  5f74696d          DCB      0x5f,0x74,0x69,0x6d
000024  65725f64          DCB      0x65,0x72,0x5f,0x64
000028  656c6574          DCB      0x65,0x6c,0x65,0x74
00002c  6500              DCB      0x65,0x00
                  |symbol_number.54|
00002e  7274              DCB      0x72,0x74
000030  5f74696d          DCB      0x5f,0x74,0x69,0x6d
000034  65725f73          DCB      0x65,0x72,0x5f,0x73
000038  74617274          DCB      0x74,0x61,0x72,0x74
00003c  00                DCB      0x00
                  |symbol_number.55|
00003d  72745f            DCB      0x72,0x74,0x5f
000040  74696d65          DCB      0x74,0x69,0x6d,0x65
000044  725f7374          DCB      0x72,0x5f,0x73,0x74
000048  6f7000            DCB      0x6f,0x70,0x00
                  |symbol_number.56|
00004b  72                DCB      0x72
00004c  745f7469          DCB      0x74,0x5f,0x74,0x69
000050  6d65725f          DCB      0x6d,0x65,0x72,0x5f
000054  636f6e74          DCB      0x63,0x6f,0x6e,0x74
000058  726f6c00          DCB      0x72,0x6f,0x6c,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  rt_timer_list
                          %        8
                  rt_timer_timeout_hook
                          DCD      0x00000000
                  random_nr
                          DCD      0x00000000
