; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\app -I..\bsp -I..\common -I..\cortex-m3 -I..\rt_thread\include -I..\STM32F10x_StdPeriph_Driver\inc -IF:\work\Keil_rtthread_experient\mdk\RTE -ID:\EngineeringSoftware\Keil_core\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0 -ID:\EngineeringSoftware\Keil_core\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_MD_VL -DSTM32F10X_MD_VL -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\usart.crf ..\bsp\usart.c]
                          THUMB

                          AREA ||i.DMA1_Channel5_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Channel5_IRQHandler PROC
;;;289    
;;;290    void DMA1_Channel5_IRQHandler(void) {
000000  b510              PUSH     {r4,lr}
;;;291        /* enter interrupt */
;;;292        rt_interrupt_enter();
000002  f7fffffe          BL       rt_interrupt_enter
;;;293    
;;;294        dma_rx_done_isr(&serial1);
000006  4803              LDR      r0,|L1.20|
000008  f7fffffe          BL       dma_rx_done_isr
;;;295    
;;;296        /* leave interrupt */
;;;297        rt_interrupt_leave();
00000c  f7fffffe          BL       rt_interrupt_leave
;;;298    }
000010  bd10              POP      {r4,pc}
;;;299    #endif /* RT_USING_UART1 */
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      serial1

                          AREA ||i.DMA_Configuration||, CODE, READONLY, ALIGN=1

                  DMA_Configuration PROC
;;;505    
;;;506    static void DMA_Configuration(struct rt_serial_device *serial) {
000000  b570              PUSH     {r4-r6,lr}
000002  b08c              SUB      sp,sp,#0x30
000004  4605              MOV      r5,r0
;;;507        struct stm32_uart *uart = (struct stm32_uart *) serial->parent.user_data;
000006  6bec              LDR      r4,[r5,#0x3c]
;;;508        struct rt_serial_rx_fifo *rx_fifo = (struct rt_serial_rx_fifo *)serial->serial_rx;
000008  6cee              LDR      r6,[r5,#0x4c]
;;;509        DMA_InitTypeDef DMA_InitStructure;
;;;510        NVIC_InitTypeDef NVIC_InitStructure;
;;;511    
;;;512        /* enable transmit idle interrupt */
;;;513        USART_ITConfig(uart->uart_device, USART_IT_IDLE , ENABLE);
00000a  2201              MOVS     r2,#1
00000c  f2404124          MOV      r1,#0x424
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_ITConfig
;;;514    
;;;515        /* DMA clock enable */
;;;516        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000016  2101              MOVS     r1,#1
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;517        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;518    
;;;519        /* rx dma config */
;;;520        DMA_DeInit(uart->dma.rx_ch);
000026  68a0              LDR      r0,[r4,#8]
000028  f7fffffe          BL       DMA_DeInit
;;;521        DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&(uart->uart_device->DR);
00002c  6820              LDR      r0,[r4,#0]
00002e  1d00              ADDS     r0,r0,#4
000030  9001              STR      r0,[sp,#4]
;;;522        DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) rx_fifo->buffer;
000032  6830              LDR      r0,[r6,#0]
000034  9002              STR      r0,[sp,#8]
;;;523        DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
000036  2000              MOVS     r0,#0
000038  9003              STR      r0,[sp,#0xc]
;;;524        DMA_InitStructure.DMA_BufferSize = serial->config.bufsz;
00003a  6ca8              LDR      r0,[r5,#0x48]
00003c  f3c0208f          UBFX     r0,r0,#10,#16
000040  9004              STR      r0,[sp,#0x10]
;;;525        DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000042  2000              MOVS     r0,#0
000044  9005              STR      r0,[sp,#0x14]
;;;526        DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000046  2080              MOVS     r0,#0x80
000048  9006              STR      r0,[sp,#0x18]
;;;527        DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
00004a  2000              MOVS     r0,#0
00004c  9007              STR      r0,[sp,#0x1c]
;;;528        DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
00004e  9008              STR      r0,[sp,#0x20]
;;;529        DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
000050  9009              STR      r0,[sp,#0x24]
;;;530        DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000052  f44f5000          MOV      r0,#0x2000
000056  900a              STR      r0,[sp,#0x28]
;;;531        DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000058  2000              MOVS     r0,#0
00005a  900b              STR      r0,[sp,#0x2c]
;;;532        DMA_Init(uart->dma.rx_ch, &DMA_InitStructure);
00005c  a901              ADD      r1,sp,#4
00005e  68a0              LDR      r0,[r4,#8]
000060  f7fffffe          BL       DMA_Init
;;;533        DMA_ClearFlag(uart->dma.rx_gl_flag);
000064  68e0              LDR      r0,[r4,#0xc]
000066  f7fffffe          BL       DMA_ClearFlag
;;;534        DMA_ITConfig(uart->dma.rx_ch, DMA_IT_TC, ENABLE);
00006a  2201              MOVS     r2,#1
00006c  2102              MOVS     r1,#2
00006e  68a0              LDR      r0,[r4,#8]
000070  f7fffffe          BL       DMA_ITConfig
;;;535        USART_DMACmd(uart->uart_device, USART_DMAReq_Rx, ENABLE);
000074  2201              MOVS     r2,#1
000076  2140              MOVS     r1,#0x40
000078  6820              LDR      r0,[r4,#0]
00007a  f7fffffe          BL       USART_DMACmd
;;;536        DMA_Cmd(uart->dma.rx_ch, ENABLE);
00007e  2101              MOVS     r1,#1
000080  68a0              LDR      r0,[r4,#8]
000082  f7fffffe          BL       DMA_Cmd
;;;537    
;;;538        /* rx dma interrupt config */
;;;539        NVIC_InitStructure.NVIC_IRQChannel = uart->dma.rx_irq_ch;
000086  7c20              LDRB     r0,[r4,#0x10]
000088  f88d0000          STRB     r0,[sp,#0]
;;;540        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00008c  2000              MOVS     r0,#0
00008e  f88d0001          STRB     r0,[sp,#1]
;;;541        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000092  2001              MOVS     r0,#1
000094  f88d0002          STRB     r0,[sp,#2]
;;;542        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000098  f88d0003          STRB     r0,[sp,#3]
;;;543        NVIC_Init(&NVIC_InitStructure);
00009c  4668              MOV      r0,sp
00009e  f7fffffe          BL       NVIC_Init
;;;544    }
0000a2  b00c              ADD      sp,sp,#0x30
0000a4  bd70              POP      {r4-r6,pc}
;;;545    
                          ENDP


                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;442    
;;;443    static void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;444    {
;;;445        GPIO_InitTypeDef GPIO_InitStructure;
;;;446    
;;;447        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000002  2002              MOVS     r0,#2
000004  f88d0002          STRB     r0,[sp,#2]
;;;448    
;;;449    #if defined(RT_USING_UART1)
;;;450        /* Configure USART Rx/tx PIN */
;;;451        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000008  2004              MOVS     r0,#4
00000a  f88d0003          STRB     r0,[sp,#3]
;;;452        GPIO_InitStructure.GPIO_Pin = UART1_GPIO_RX;
00000e  0200              LSLS     r0,r0,#8
000010  f8ad0000          STRH     r0,[sp,#0]
;;;453        GPIO_Init(UART1_GPIO, &GPIO_InitStructure);
000014  4669              MOV      r1,sp
000016  4807              LDR      r0,|L3.52|
000018  f7fffffe          BL       GPIO_Init
;;;454    
;;;455        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0003          STRB     r0,[sp,#3]
;;;456        GPIO_InitStructure.GPIO_Pin = UART1_GPIO_TX;
000022  f44f7000          MOV      r0,#0x200
000026  f8ad0000          STRH     r0,[sp,#0]
;;;457        GPIO_Init(UART1_GPIO, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4801              LDR      r0,|L3.52|
00002e  f7fffffe          BL       GPIO_Init
;;;458    #endif /* RT_USING_UART1 */
;;;459    
;;;460    #if defined(RT_USING_UART2)
;;;461        /* Configure USART Rx/tx PIN */
;;;462        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;463        GPIO_InitStructure.GPIO_Pin = UART2_GPIO_RX;
;;;464        GPIO_Init(UART2_GPIO, &GPIO_InitStructure);
;;;465    
;;;466        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;467        GPIO_InitStructure.GPIO_Pin = UART2_GPIO_TX;
;;;468        GPIO_Init(UART2_GPIO, &GPIO_InitStructure);
;;;469    #endif /* RT_USING_UART2 */
;;;470    
;;;471    #if defined(RT_USING_UART3)
;;;472        /* Configure USART Rx/tx PIN */
;;;473        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;474        GPIO_InitStructure.GPIO_Pin = UART3_GPIO_RX;
;;;475        GPIO_Init(UART3_GPIO, &GPIO_InitStructure);
;;;476    
;;;477        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;478        GPIO_InitStructure.GPIO_Pin = UART3_GPIO_TX;
;;;479        GPIO_Init(UART3_GPIO, &GPIO_InitStructure);
;;;480    #endif /* RT_USING_UART3 */
;;;481    
;;;482    #if defined(RT_USING_UART4)
;;;483        /* Configure USART Rx/tx PIN */
;;;484        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;485        GPIO_InitStructure.GPIO_Pin = UART4_GPIO_RX;
;;;486        GPIO_Init(UART4_GPIO, &GPIO_InitStructure);
;;;487    
;;;488        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;489        GPIO_InitStructure.GPIO_Pin = UART4_GPIO_TX;
;;;490        GPIO_Init(UART4_GPIO, &GPIO_InitStructure);
;;;491    #endif /* RT_USING_UART4 */
;;;492    }
000032  bd08              POP      {r3,pc}
;;;493    
                          ENDP

                  |L3.52|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;493    
;;;494    static void NVIC_Configuration(struct stm32_uart* uart)
000000  b538              PUSH     {r3-r5,lr}
;;;495    {
000002  4604              MOV      r4,r0
;;;496        NVIC_InitTypeDef NVIC_InitStructure;
;;;497    
;;;498        /* Enable the USART1 Interrupt */
;;;499        NVIC_InitStructure.NVIC_IRQChannel = uart->irq;
000004  7920              LDRB     r0,[r4,#4]
000006  f88d0000          STRB     r0,[sp,#0]
;;;500        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00000a  2000              MOVS     r0,#0
00000c  f88d0001          STRB     r0,[sp,#1]
;;;501        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000010  f88d0002          STRB     r0,[sp,#2]
;;;502        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;503        NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;504    }
000020  bd38              POP      {r3-r5,pc}
;;;505    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;411    
;;;412    static void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;413    {
;;;414    #if defined(RT_USING_UART1)
;;;415        /* Enable UART GPIO clocks */
;;;416        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000002  2101              MOVS     r1,#1
000004  2005              MOVS     r0,#5
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;417        /* Enable UART clock */
;;;418        RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0388              LSLS     r0,r1,#14
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;419    #endif /* RT_USING_UART1 */
;;;420    
;;;421    #if defined(RT_USING_UART2)
;;;422        /* Enable UART GPIO clocks */
;;;423        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
;;;424        /* Enable UART clock */
;;;425        RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
;;;426    #endif /* RT_USING_UART2 */
;;;427    
;;;428    #if defined(RT_USING_UART3)
;;;429        /* Enable UART GPIO clocks */
;;;430        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
;;;431        /* Enable UART clock */
;;;432        RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
;;;433    #endif /* RT_USING_UART3 */
;;;434    
;;;435    #if defined(RT_USING_UART4)
;;;436        /* Enable UART GPIO clocks */
;;;437        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
;;;438        /* Enable UART clock */
;;;439        RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;440    #endif /* RT_USING_UART4 */
;;;441    }
000012  bd10              POP      {r4,pc}
;;;442    
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;278    
;;;279    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;280    {
;;;281        /* enter interrupt */
;;;282        rt_interrupt_enter();
000002  f7fffffe          BL       rt_interrupt_enter
;;;283    
;;;284        uart_isr(&serial1);
000006  4803              LDR      r0,|L6.20|
000008  f7fffffe          BL       uart_isr
;;;285    
;;;286        /* leave interrupt */
;;;287        rt_interrupt_leave();
00000c  f7fffffe          BL       rt_interrupt_leave
;;;288    }
000010  bd10              POP      {r4,pc}
;;;289    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      serial1

                          AREA ||i.dma_rx_done_isr||, CODE, READONLY, ALIGN=1

                  dma_rx_done_isr PROC
;;;202     */
;;;203    static void dma_rx_done_isr(struct rt_serial_device *serial) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
;;;204        struct stm32_uart *uart = (struct stm32_uart *) serial->parent.user_data;
000006  6bec              LDR      r4,[r5,#0x3c]
;;;205        rt_size_t recv_total_len, recv_len;
;;;206        /* disable dma, stop receive data */
;;;207        DMA_Cmd(uart->dma.rx_ch, DISABLE);
000008  2100              MOVS     r1,#0
00000a  68a0              LDR      r0,[r4,#8]
00000c  f7fffffe          BL       DMA_Cmd
;;;208    
;;;209        recv_total_len = serial->config.bufsz - DMA_GetCurrDataCounter(uart->dma.rx_ch);
000010  68a0              LDR      r0,[r4,#8]
000012  f7fffffe          BL       DMA_GetCurrDataCounter
000016  6ca9              LDR      r1,[r5,#0x48]
000018  f3c1218f          UBFX     r1,r1,#10,#16
00001c  1a0e              SUBS     r6,r1,r0
;;;210        if (recv_total_len > uart->dma.last_recv_len) {
00001e  6960              LDR      r0,[r4,#0x14]
000020  42b0              CMP      r0,r6
000022  d202              BCS      |L7.42|
;;;211            recv_len = recv_total_len - uart->dma.last_recv_len;
000024  6960              LDR      r0,[r4,#0x14]
000026  1a37              SUBS     r7,r6,r0
000028  e000              B        |L7.44|
                  |L7.42|
;;;212        } else {
;;;213            recv_len = recv_total_len;
00002a  4637              MOV      r7,r6
                  |L7.44|
;;;214        }
;;;215        uart->dma.last_recv_len = recv_total_len;
00002c  6166              STR      r6,[r4,#0x14]
;;;216    
;;;217        rt_hw_serial_isr(serial, RT_SERIAL_EVENT_RX_DMADONE | (recv_len << 8));
00002e  2003              MOVS     r0,#3
000030  ea402107          ORR      r1,r0,r7,LSL #8
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       rt_hw_serial_isr
;;;218    
;;;219        DMA_ClearFlag(uart->dma.rx_gl_flag);
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  f7fffffe          BL       DMA_ClearFlag
;;;220        /* reload */
;;;221        DMA_SetCurrDataCounter(uart->dma.rx_ch, serial->config.bufsz);
000040  6caa              LDR      r2,[r5,#0x48]
000042  f3c2218f          UBFX     r1,r2,#10,#16
000046  68a0              LDR      r0,[r4,#8]
000048  f7fffffe          BL       DMA_SetCurrDataCounter
;;;222        DMA_Cmd(uart->dma.rx_ch, ENABLE);
00004c  2101              MOVS     r1,#1
00004e  68a0              LDR      r0,[r4,#8]
000050  f7fffffe          BL       DMA_Cmd
;;;223    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;224    
                          ENDP


                          AREA ||i.dma_uart_rx_idle_isr||, CODE, READONLY, ALIGN=1

                  dma_uart_rx_idle_isr PROC
;;;175     */
;;;176    static void dma_uart_rx_idle_isr(struct rt_serial_device *serial) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;177        struct stm32_uart *uart = (struct stm32_uart *) serial->parent.user_data;
000006  6bf4              LDR      r4,[r6,#0x3c]
;;;178        rt_size_t recv_total_len, recv_len;
;;;179        /* disable dma, stop receive data */
;;;180        DMA_Cmd(uart->dma.rx_ch, DISABLE);
000008  2100              MOVS     r1,#0
00000a  68a0              LDR      r0,[r4,#8]
00000c  f7fffffe          BL       DMA_Cmd
;;;181    
;;;182        recv_total_len = serial->config.bufsz - DMA_GetCurrDataCounter(uart->dma.rx_ch);
000010  68a0              LDR      r0,[r4,#8]
000012  f7fffffe          BL       DMA_GetCurrDataCounter
000016  6cb1              LDR      r1,[r6,#0x48]
000018  f3c1218f          UBFX     r1,r1,#10,#16
00001c  1a0d              SUBS     r5,r1,r0
;;;183        if (recv_total_len > uart->dma.last_recv_len) {
00001e  6960              LDR      r0,[r4,#0x14]
000020  42a8              CMP      r0,r5
000022  d202              BCS      |L8.42|
;;;184            recv_len = recv_total_len - uart->dma.last_recv_len;
000024  6960              LDR      r0,[r4,#0x14]
000026  1a2f              SUBS     r7,r5,r0
000028  e000              B        |L8.44|
                  |L8.42|
;;;185        } else {
;;;186            recv_len = recv_total_len;
00002a  462f              MOV      r7,r5
                  |L8.44|
;;;187        }
;;;188        uart->dma.last_recv_len = recv_total_len;
00002c  6165              STR      r5,[r4,#0x14]
;;;189    
;;;190        rt_hw_serial_isr(serial, RT_SERIAL_EVENT_RX_DMADONE | (recv_len << 8));
00002e  2003              MOVS     r0,#3
000030  ea402107          ORR      r1,r0,r7,LSL #8
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       rt_hw_serial_isr
;;;191    
;;;192        /* read a data for clear receive idle interrupt flag */
;;;193        USART_ReceiveData(uart->uart_device);
00003a  6820              LDR      r0,[r4,#0]
00003c  f7fffffe          BL       USART_ReceiveData
;;;194        DMA_ClearFlag(uart->dma.rx_gl_flag);
000040  68e0              LDR      r0,[r4,#0xc]
000042  f7fffffe          BL       DMA_ClearFlag
;;;195        DMA_Cmd(uart->dma.rx_ch, ENABLE);
000046  2101              MOVS     r1,#1
000048  68a0              LDR      r0,[r4,#8]
00004a  f7fffffe          BL       DMA_Cmd
;;;196    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;197    
                          ENDP


                          AREA ||i.rt_hw_usart_init||, CODE, READONLY, ALIGN=2

                  rt_hw_usart_init PROC
;;;545    
;;;546    void rt_hw_usart_init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;547    {
;;;548        struct stm32_uart* uart;
;;;549        struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;
000002  490f              LDR      r1,|L9.64|
000004  c903              LDM      r1,{r0,r1}
000006  e9cd0100          STRD     r0,r1,[sp,#0]
;;;550    
;;;551        RCC_Configuration();
00000a  f7fffffe          BL       RCC_Configuration
;;;552        GPIO_Configuration();
00000e  f7fffffe          BL       GPIO_Configuration
;;;553    
;;;554    #if defined(RT_USING_UART1)
;;;555        uart = &uart1;
000012  4c0c              LDR      r4,|L9.68|
;;;556        config.baud_rate = BAUD_RATE_115200;
000014  f44f30e1          MOV      r0,#0x1c200
000018  9000              STR      r0,[sp,#0]
;;;557    
;;;558        serial1.ops    = &stm32_uart_ops;
00001a  480b              LDR      r0,|L9.72|
00001c  490b              LDR      r1,|L9.76|
00001e  6408              STR      r0,[r1,#0x40]  ; serial1
;;;559        serial1.config = config;
000020  4608              MOV      r0,r1
000022  e9dd1200          LDRD     r1,r2,[sp,#0]
000026  e9c01211          STRD     r1,r2,[r0,#0x44]
;;;560    
;;;561        NVIC_Configuration(uart);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       NVIC_Configuration
;;;562    
;;;563        /* register UART1 device */
;;;564        rt_hw_serial_register(&serial1, "uart1",
000030  4623              MOV      r3,r4
000032  f2403203          MOV      r2,#0x303
000036  a106              ADR      r1,|L9.80|
000038  4804              LDR      r0,|L9.76|
00003a  f7fffffe          BL       rt_hw_serial_register
;;;565                              RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX | RT_DEVICE_FLAG_DMA_RX,
;;;566                              uart);
;;;567    #endif /* RT_USING_UART1 */
;;;568    
;;;569    #if defined(RT_USING_UART2)
;;;570        uart = &uart2;
;;;571    
;;;572        config.baud_rate = BAUD_RATE_115200;
;;;573        serial2.ops    = &stm32_uart_ops;
;;;574        serial2.config = config;
;;;575    
;;;576        NVIC_Configuration(uart);
;;;577    
;;;578        /* register UART2 device */
;;;579        rt_hw_serial_register(&serial2, "uart2",
;;;580                              RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX | RT_DEVICE_FLAG_DMA_RX,
;;;581                              uart);
;;;582    #endif /* RT_USING_UART2 */
;;;583    
;;;584    #if defined(RT_USING_UART3)
;;;585        uart = &uart3;
;;;586    
;;;587        config.baud_rate = BAUD_RATE_115200;
;;;588    
;;;589        serial3.ops    = &stm32_uart_ops;
;;;590        serial3.config = config;
;;;591    
;;;592        NVIC_Configuration(uart);
;;;593    
;;;594        /* register UART3 device */
;;;595        rt_hw_serial_register(&serial3, "uart3",
;;;596                              RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX | RT_DEVICE_FLAG_DMA_RX,
;;;597                              uart);
;;;598    #endif /* RT_USING_UART3 */
;;;599    
;;;600    #if defined(RT_USING_UART4)
;;;601        uart = &uart4;
;;;602    
;;;603        config.baud_rate = BAUD_RATE_115200;
;;;604    
;;;605        serial4.ops    = &stm32_uart_ops;
;;;606        serial4.config = config;
;;;607    
;;;608        NVIC_Configuration(uart);
;;;609    
;;;610        /* register UART4 device */
;;;611        rt_hw_serial_register(&serial4, "uart4",
;;;612                              RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX | RT_DEVICE_FLAG_DMA_RX,
;;;613                              uart);
;;;614    #endif /* RT_USING_UART4 */
;;;615    }
00003e  bd1c              POP      {r2-r4,pc}
                          ENDP

                  |L9.64|
                          DCD      ||.constdata||+0x54
                  |L9.68|
                          DCD      uart1
                  |L9.72|
                          DCD      stm32_uart_ops
                  |L9.76|
                          DCD      serial1
                  |L9.80|
000050  75617274          DCB      "uart1",0
000054  3100    
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.stm32_configure||, CODE, READONLY, ALIGN=2

                  stm32_configure PROC
;;;64     
;;;65     static rt_err_t stm32_configure(struct rt_serial_device *serial, struct serial_configure *cfg)
000000  b57f              PUSH     {r0-r6,lr}
;;;66     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;67         struct stm32_uart* uart;
;;;68         USART_InitTypeDef USART_InitStructure;
;;;69     
;;;70         RT_ASSERT(serial != RT_NULL);
000006  b925              CBNZ     r5,|L10.18|
000008  2246              MOVS     r2,#0x46
00000a  492d              LDR      r1,|L10.192|
00000c  a02d              ADR      r0,|L10.196|
00000e  f7fffffe          BL       rt_assert_handler
                  |L10.18|
;;;71         RT_ASSERT(cfg != RT_NULL);
000012  b924              CBNZ     r4,|L10.30|
000014  2247              MOVS     r2,#0x47
000016  492a              LDR      r1,|L10.192|
000018  a02f              ADR      r0,|L10.216|
00001a  f7fffffe          BL       rt_assert_handler
                  |L10.30|
;;;72     
;;;73         uart = (struct stm32_uart *)serial->parent.user_data;
00001e  6bee              LDR      r6,[r5,#0x3c]
;;;74     
;;;75         USART_InitStructure.USART_BaudRate = cfg->baud_rate;
000020  6820              LDR      r0,[r4,#0]
000022  9000              STR      r0,[sp,#0]
;;;76     
;;;77         if (cfg->data_bits == DATA_BITS_8){
000024  7920              LDRB     r0,[r4,#4]
000026  f000000f          AND      r0,r0,#0xf
00002a  2808              CMP      r0,#8
00002c  d103              BNE      |L10.54|
;;;78             USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00002e  2000              MOVS     r0,#0
000030  f8ad0004          STRH     r0,[sp,#4]
000034  e008              B        |L10.72|
                  |L10.54|
;;;79         } else if (cfg->data_bits == DATA_BITS_9) {
000036  7920              LDRB     r0,[r4,#4]
000038  f000000f          AND      r0,r0,#0xf
00003c  2809              CMP      r0,#9
00003e  d103              BNE      |L10.72|
;;;80             USART_InitStructure.USART_WordLength = USART_WordLength_9b;
000040  f44f5080          MOV      r0,#0x1000
000044  f8ad0004          STRH     r0,[sp,#4]
                  |L10.72|
;;;81         }
;;;82     
;;;83         if (cfg->stop_bits == STOP_BITS_1){
000048  7920              LDRB     r0,[r4,#4]
00004a  f3c01001          UBFX     r0,r0,#4,#2
00004e  b918              CBNZ     r0,|L10.88|
;;;84             USART_InitStructure.USART_StopBits = USART_StopBits_1;
000050  2000              MOVS     r0,#0
000052  f8ad0006          STRH     r0,[sp,#6]
000056  e007              B        |L10.104|
                  |L10.88|
;;;85         } else if (cfg->stop_bits == STOP_BITS_2){
000058  7920              LDRB     r0,[r4,#4]
00005a  f3c01001          UBFX     r0,r0,#4,#2
00005e  2801              CMP      r0,#1
000060  d102              BNE      |L10.104|
;;;86             USART_InitStructure.USART_StopBits = USART_StopBits_2;
000062  0340              LSLS     r0,r0,#13
000064  f8ad0006          STRH     r0,[sp,#6]
                  |L10.104|
;;;87         }
;;;88     
;;;89         if (cfg->parity == PARITY_NONE){
000068  7920              LDRB     r0,[r4,#4]
00006a  f3c01081          UBFX     r0,r0,#6,#2
00006e  b918              CBNZ     r0,|L10.120|
;;;90             USART_InitStructure.USART_Parity = USART_Parity_No;
000070  2000              MOVS     r0,#0
000072  f8ad0008          STRH     r0,[sp,#8]
000076  e011              B        |L10.156|
                  |L10.120|
;;;91         } else if (cfg->parity == PARITY_ODD) {
000078  7920              LDRB     r0,[r4,#4]
00007a  f3c01081          UBFX     r0,r0,#6,#2
00007e  2801              CMP      r0,#1
000080  d104              BNE      |L10.140|
;;;92             USART_InitStructure.USART_Parity = USART_Parity_Odd;
000082  f44f60c0          MOV      r0,#0x600
000086  f8ad0008          STRH     r0,[sp,#8]
00008a  e007              B        |L10.156|
                  |L10.140|
;;;93         } else if (cfg->parity == PARITY_EVEN) {
00008c  7920              LDRB     r0,[r4,#4]
00008e  f3c01081          UBFX     r0,r0,#6,#2
000092  2802              CMP      r0,#2
000094  d102              BNE      |L10.156|
;;;94             USART_InitStructure.USART_Parity = USART_Parity_Even;
000096  0240              LSLS     r0,r0,#9
000098  f8ad0008          STRH     r0,[sp,#8]
                  |L10.156|
;;;95         }
;;;96     
;;;97         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00009c  2000              MOVS     r0,#0
00009e  f8ad000c          STRH     r0,[sp,#0xc]
;;;98         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0000a2  200c              MOVS     r0,#0xc
0000a4  f8ad000a          STRH     r0,[sp,#0xa]
;;;99         USART_Init(uart->uart_device, &USART_InitStructure);
0000a8  4669              MOV      r1,sp
0000aa  6830              LDR      r0,[r6,#0]
0000ac  f7fffffe          BL       USART_Init
;;;100    
;;;101        /* Enable USART */
;;;102        USART_Cmd(uart->uart_device, ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  6830              LDR      r0,[r6,#0]
0000b4  f7fffffe          BL       USART_Cmd
;;;103    
;;;104        return RT_EOK;
0000b8  2000              MOVS     r0,#0
;;;105    }
0000ba  b004              ADD      sp,sp,#0x10
0000bc  bd70              POP      {r4-r6,pc}
;;;106    
                          ENDP

0000be  0000              DCW      0x0000
                  |L10.192|
                          DCD      __FUNCTION__
                  |L10.196|
0000c4  73657269          DCB      "serial != RT_NULL",0
0000c8  616c2021
0000cc  3d205254
0000d0  5f4e554c
0000d4  4c00    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L10.216|
0000d8  63666720          DCB      "cfg != RT_NULL",0
0000dc  213d2052
0000e0  545f4e55
0000e4  4c4c00  
0000e7  00                DCB      0

                          AREA ||i.stm32_control||, CODE, READONLY, ALIGN=2

                  stm32_control PROC
;;;106    
;;;107    static rt_err_t stm32_control(struct rt_serial_device *serial, int cmd, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;108    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;109        struct stm32_uart* uart;
;;;110        rt_uint32_t ctrl_arg = (rt_uint32_t)(arg);
00000a  46b8              MOV      r8,r7
;;;111    
;;;112        RT_ASSERT(serial != RT_NULL);
00000c  b925              CBNZ     r5,|L11.24|
00000e  2270              MOVS     r2,#0x70
000010  491d              LDR      r1,|L11.136|
000012  a01e              ADR      r0,|L11.140|
000014  f7fffffe          BL       rt_assert_handler
                  |L11.24|
;;;113        uart = (struct stm32_uart *)serial->parent.user_data;
000018  6bec              LDR      r4,[r5,#0x3c]
;;;114    
;;;115        switch (cmd)
00001a  2e03              CMP      r6,#3
00001c  d029              BEQ      |L11.114|
00001e  2e10              CMP      r6,#0x10
000020  d013              BEQ      |L11.74|
000022  2e11              CMP      r6,#0x11
000024  d12c              BNE      |L11.128|
;;;116        {
;;;117            /* disable interrupt */
;;;118        case RT_DEVICE_CTRL_CLR_INT:
;;;119            /* disable rx irq */
;;;120            UART_DISABLE_IRQ(uart->irq);
000026  f9940004          LDRSB    r0,[r4,#4]
00002a  f000021f          AND      r2,r0,#0x1f
00002e  2101              MOVS     r1,#1
000030  4091              LSLS     r1,r1,r2
000032  4a1b              LDR      r2,|L11.160|
000034  0943              LSRS     r3,r0,#5
000036  f8421023          STR      r1,[r2,r3,LSL #2]
00003a  bf00              NOP      
;;;121            /* disable interrupt */
;;;122            USART_ITConfig(uart->uart_device, USART_IT_RXNE, DISABLE);
00003c  2200              MOVS     r2,#0
00003e  f2405125          MOV      r1,#0x525
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       USART_ITConfig
;;;123            break;
000048  e01a              B        |L11.128|
                  |L11.74|
;;;124            /* enable interrupt */
;;;125        case RT_DEVICE_CTRL_SET_INT:
;;;126            /* enable rx irq */
;;;127            UART_ENABLE_IRQ(uart->irq);
00004a  f9940004          LDRSB    r0,[r4,#4]
00004e  f000021f          AND      r2,r0,#0x1f
000052  2101              MOVS     r1,#1
000054  4091              LSLS     r1,r1,r2
000056  0942              LSRS     r2,r0,#5
000058  0092              LSLS     r2,r2,#2
00005a  f10222e0          ADD      r2,r2,#0xe000e000
00005e  f8c21100          STR      r1,[r2,#0x100]
000062  bf00              NOP      
;;;128            /* enable interrupt */
;;;129            USART_ITConfig(uart->uart_device, USART_IT_RXNE, ENABLE);
000064  2201              MOVS     r2,#1
000066  f2405125          MOV      r1,#0x525
00006a  6820              LDR      r0,[r4,#0]
00006c  f7fffffe          BL       USART_ITConfig
;;;130            break;
000070  e006              B        |L11.128|
                  |L11.114|
;;;131            /* USART config */
;;;132        case RT_DEVICE_CTRL_CONFIG :
;;;133            if (ctrl_arg == RT_DEVICE_FLAG_DMA_RX) {
000072  f5b87f00          CMP      r8,#0x200
000076  d102              BNE      |L11.126|
;;;134                DMA_Configuration(serial);
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       DMA_Configuration
                  |L11.126|
;;;135            }
;;;136            break;
00007e  bf00              NOP      
                  |L11.128|
000080  bf00              NOP                            ;123
;;;137        }
;;;138        return RT_EOK;
000082  2000              MOVS     r0,#0
;;;139    }
000084  e8bd81f0          POP      {r4-r8,pc}
;;;140    
                          ENDP

                  |L11.136|
                          DCD      |symbol_number.45|
                  |L11.140|
00008c  73657269          DCB      "serial != RT_NULL",0
000090  616c2021
000094  3d205254
000098  5f4e554c
00009c  4c00    
00009e  00                DCB      0
00009f  00                DCB      0
                  |L11.160|
                          DCD      0xe000e180

                          AREA ||i.stm32_getc||, CODE, READONLY, ALIGN=2

                  stm32_getc PROC
;;;153    
;;;154    static int stm32_getc(struct rt_serial_device *serial)
000000  b570              PUSH     {r4-r6,lr}
;;;155    {
000002  4604              MOV      r4,r0
;;;156        int ch;
;;;157        struct stm32_uart* uart;
;;;158    
;;;159        RT_ASSERT(serial != RT_NULL);
000004  b924              CBNZ     r4,|L12.16|
000006  229f              MOVS     r2,#0x9f
000008  4908              LDR      r1,|L12.44|
00000a  a009              ADR      r0,|L12.48|
00000c  f7fffffe          BL       rt_assert_handler
                  |L12.16|
;;;160        uart = (struct stm32_uart *)serial->parent.user_data;
000010  6be5              LDR      r5,[r4,#0x3c]
;;;161    
;;;162        ch = -1;
000012  f04f36ff          MOV      r6,#0xffffffff
;;;163        if (uart->uart_device->SR & USART_FLAG_RXNE)
000016  6828              LDR      r0,[r5,#0]
000018  8800              LDRH     r0,[r0,#0]
00001a  f0000020          AND      r0,r0,#0x20
00001e  b110              CBZ      r0,|L12.38|
;;;164        {
;;;165            ch = uart->uart_device->DR & 0xff;
000020  6828              LDR      r0,[r5,#0]
000022  8880              LDRH     r0,[r0,#4]
000024  b2c6              UXTB     r6,r0
                  |L12.38|
;;;166        }
;;;167    
;;;168        return ch;
000026  4630              MOV      r0,r6
;;;169    }
000028  bd70              POP      {r4-r6,pc}
;;;170    
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      |symbol_number.47|
                  |L12.48|
000030  73657269          DCB      "serial != RT_NULL",0
000034  616c2021
000038  3d205254
00003c  5f4e554c
000040  4c00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.stm32_putc||, CODE, READONLY, ALIGN=2

                  stm32_putc PROC
;;;140    
;;;141    static int stm32_putc(struct rt_serial_device *serial, char c)
000000  b570              PUSH     {r4-r6,lr}
;;;142    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;143        struct stm32_uart* uart;
;;;144    
;;;145        RT_ASSERT(serial != RT_NULL);
000006  b924              CBNZ     r4,|L13.18|
000008  2291              MOVS     r2,#0x91
00000a  4908              LDR      r1,|L13.44|
00000c  a008              ADR      r0,|L13.48|
00000e  f7fffffe          BL       rt_assert_handler
                  |L13.18|
;;;146        uart = (struct stm32_uart *)serial->parent.user_data;
000012  6be5              LDR      r5,[r4,#0x3c]
;;;147    
;;;148        uart->uart_device->DR = c;
000014  6828              LDR      r0,[r5,#0]
000016  8086              STRH     r6,[r0,#4]
;;;149        while (!(uart->uart_device->SR & USART_FLAG_TC));
000018  bf00              NOP      
                  |L13.26|
00001a  6828              LDR      r0,[r5,#0]
00001c  8800              LDRH     r0,[r0,#0]
00001e  f0000040          AND      r0,r0,#0x40
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L13.26|
;;;150    
;;;151        return 1;
000026  2001              MOVS     r0,#1
;;;152    }
000028  bd70              POP      {r4-r6,pc}
;;;153    
                          ENDP

00002a  0000              DCW      0x0000
                  |L13.44|
                          DCD      |symbol_number.46|
                  |L13.48|
000030  73657269          DCB      "serial != RT_NULL",0
000034  616c2021
000038  3d205254
00003c  5f4e554c
000040  4c00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.uart_isr||, CODE, READONLY, ALIGN=2

                  uart_isr PROC
;;;229     */
;;;230    static void uart_isr(struct rt_serial_device *serial) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;231        struct stm32_uart *uart = (struct stm32_uart *) serial->parent.user_data;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;232    
;;;233        RT_ASSERT(uart != RT_NULL);
000006  b924              CBNZ     r4,|L14.18|
000008  22e9              MOVS     r2,#0xe9
00000a  4918              LDR      r1,|L14.108|
00000c  a018              ADR      r0,|L14.112|
00000e  f7fffffe          BL       rt_assert_handler
                  |L14.18|
;;;234    
;;;235        if(USART_GetITStatus(uart->uart_device, USART_IT_RXNE) != RESET)
000012  f2405125          MOV      r1,#0x525
000016  6820              LDR      r0,[r4,#0]
000018  f7fffffe          BL       USART_GetITStatus
00001c  b140              CBZ      r0,|L14.48|
;;;236        {
;;;237            rt_hw_serial_isr(serial, RT_SERIAL_EVENT_RX_IND);
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       rt_hw_serial_isr
;;;238            /* clear interrupt */
;;;239            USART_ClearITPendingBit(uart->uart_device, USART_IT_RXNE);
000026  f2405125          MOV      r1,#0x525
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       USART_ClearITPendingBit
                  |L14.48|
;;;240        }
;;;241        if(USART_GetITStatus(uart->uart_device, USART_IT_IDLE) != RESET)
000030  f2404124          MOV      r1,#0x424
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       USART_GetITStatus
00003a  b110              CBZ      r0,|L14.66|
;;;242        {
;;;243            dma_uart_rx_idle_isr(serial);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       dma_uart_rx_idle_isr
                  |L14.66|
;;;244        }
;;;245        if (USART_GetITStatus(uart->uart_device, USART_IT_TC) != RESET)
000042  f2406126          MOV      r1,#0x626
000046  6820              LDR      r0,[r4,#0]
000048  f7fffffe          BL       USART_GetITStatus
00004c  b120              CBZ      r0,|L14.88|
;;;246        {
;;;247            /* clear interrupt */
;;;248            USART_ClearITPendingBit(uart->uart_device, USART_IT_TC);
00004e  f2406126          MOV      r1,#0x626
000052  6820              LDR      r0,[r4,#0]
000054  f7fffffe          BL       USART_ClearITPendingBit
                  |L14.88|
;;;249        }
;;;250        if (USART_GetFlagStatus(uart->uart_device, USART_FLAG_ORE) == SET)
000058  2108              MOVS     r1,#8
00005a  6820              LDR      r0,[r4,#0]
00005c  f7fffffe          BL       USART_GetFlagStatus
000060  2801              CMP      r0,#1
000062  d102              BNE      |L14.106|
;;;251        {
;;;252            stm32_getc(serial);
000064  4628              MOV      r0,r5
000066  f7fffffe          BL       stm32_getc
                  |L14.106|
;;;253        }
;;;254    }
00006a  bd70              POP      {r4-r6,pc}
;;;255    
                          ENDP

                  |L14.108|
                          DCD      |symbol_number.48|
                  |L14.112|
000070  75617274          DCB      "uart != RT_NULL",0
000074  20213d20
000078  52545f4e
00007c  554c4c00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  serial1
                          %        84

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  stm32_uart_ops
                          DCD      stm32_configure
                          DCD      stm32_control
                          DCD      stm32_putc
                          DCD      stm32_getc
                          DCD      0x00000000
                  __FUNCTION__
000014  73746d33          DCB      0x73,0x74,0x6d,0x33
000018  325f636f          DCB      0x32,0x5f,0x63,0x6f
00001c  6e666967          DCB      0x6e,0x66,0x69,0x67
000020  75726500          DCB      0x75,0x72,0x65,0x00
                  |symbol_number.45|
000024  73746d33          DCB      0x73,0x74,0x6d,0x33
000028  325f636f          DCB      0x32,0x5f,0x63,0x6f
00002c  6e74726f          DCB      0x6e,0x74,0x72,0x6f
000030  6c00              DCB      0x6c,0x00
                  |symbol_number.46|
000032  7374              DCB      0x73,0x74
000034  6d33325f          DCB      0x6d,0x33,0x32,0x5f
000038  70757463          DCB      0x70,0x75,0x74,0x63
00003c  00                DCB      0x00
                  |symbol_number.47|
00003d  73746d            DCB      0x73,0x74,0x6d
000040  33325f67          DCB      0x33,0x32,0x5f,0x67
000044  65746300          DCB      0x65,0x74,0x63,0x00
                  |symbol_number.48|
000048  75617274          DCB      0x75,0x61,0x72,0x74
00004c  5f697372          DCB      0x5f,0x69,0x73,0x72
000050  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0001c200
000058  08000100          DCB      0x08,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  uart1
                          DCD      0x40013800
000004  25000000          DCB      0x25,0x00,0x00,0x00
                          DCD      0x40020058
                          DCD      0x00010000
000010  0f000000          DCB      0x0f,0x00,0x00,0x00
                          DCD      0x00000000
